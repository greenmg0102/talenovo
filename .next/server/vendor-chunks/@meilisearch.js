"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@meilisearch";
exports.ids = ["vendor-chunks/@meilisearch"];
exports.modules = {

/***/ "(ssr)/./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js":
/*!***************************************************************************************!*\
  !*** ./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js ***!
  \***************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MatchingStrategies: () => (/* binding */ MatchingStrategies),\n/* harmony export */   instantMeiliSearch: () => (/* binding */ instantMeiliSearch)\n/* harmony export */ });\n/* harmony import */ var meilisearch__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! meilisearch */ \"(ssr)/./node_modules/@meilisearch/instant-meilisearch/node_modules/meilisearch/dist/bundles/meilisearch.esm.js\");\n\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __rest(s, e) {\r\n    var t = {};\r\n    for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p) && e.indexOf(p) < 0)\r\n        t[p] = s[p];\r\n    if (s != null && typeof Object.getOwnPropertySymbols === \"function\")\r\n        for (var i = 0, p = Object.getOwnPropertySymbols(s); i < p.length; i++) {\r\n            if (e.indexOf(p[i]) < 0 && Object.prototype.propertyIsEnumerable.call(s, p[i]))\r\n                t[p[i]] = s[p[i]];\r\n        }\r\n    return t;\r\n}\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (g && (g = 0, op[0] && (_ = 0)), _) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\r\n\r\nfunction __spreadArray(to, from, pack) {\r\n    if (pack || arguments.length === 2) for (var i = 0, l = from.length, ar; i < l; i++) {\r\n        if (ar || !(i in from)) {\r\n            if (!ar) ar = Array.prototype.slice.call(from, 0, i);\r\n            ar[i] = from[i];\r\n        }\r\n    }\r\n    return to.concat(ar || Array.prototype.slice.call(from));\r\n}\n\n/**\r\n * @param  {ResponseCacher} cache\r\n */\r\nfunction SearchResolver(client, cache) {\r\n    return {\r\n        /**\r\n         * @param  {SearchContext} searchContext\r\n         * @param  {MeiliSearchParams} searchParams\r\n         * @param  {MeiliSearch} client\r\n         * @returns {Promise}\r\n         */\r\n        searchResponse: function (searchContext, searchParams) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var key, cachedResponse, searchResponse;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            key = cache.formatKey([\r\n                                searchParams,\r\n                                searchContext.indexUid,\r\n                                searchContext.query,\r\n                                searchContext.pagination,\r\n                            ]);\r\n                            cachedResponse = cache.getEntry(key);\r\n                            // Check if specific request is already cached with its associated search response.\r\n                            if (cachedResponse)\r\n                                return [2 /*return*/, cachedResponse\r\n                                    // Make search request\r\n                                ];\r\n                            return [4 /*yield*/, client\r\n                                    .index(searchContext.indexUid)\r\n                                    .search(searchContext.query, searchParams)\r\n                                // Cache response\r\n                            ];\r\n                        case 1:\r\n                            searchResponse = _a.sent();\r\n                            // Cache response\r\n                            cache.setEntry(key, searchResponse);\r\n                            return [2 /*return*/, searchResponse];\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    };\r\n}\n\n/**\r\n * @param  {number} rad\r\n * @returns {number}\r\n */\r\nfunction rad2degr(rad) {\r\n    return (rad * 180) / Math.PI;\r\n}\r\n/**\r\n * @param  {number} degr\r\n * @returns {number}\r\n */\r\nfunction degr2rad(degr) {\r\n    return (degr * Math.PI) / 180;\r\n}\r\n/**\r\n * @param  {number} lat1\r\n * @param  {number} lng1\r\n * @param  {number} lat2\r\n * @param  {number} lng2\r\n * @returns {string}\r\n */\r\nfunction middleGeoPoints(lat1, lng1, lat2, lng2) {\r\n    // convert to radians\r\n    lat1 = degr2rad(lat1);\r\n    lng1 = degr2rad(lng1);\r\n    var x1 = Math.cos(lat1) * Math.cos(lng1);\r\n    var y1 = Math.cos(lat1) * Math.sin(lng1);\r\n    var z1 = Math.sin(lat1);\r\n    // convert to radians\r\n    lat2 = degr2rad(lat2);\r\n    lng2 = degr2rad(lng2);\r\n    var x2 = Math.cos(lat2) * Math.cos(lng2);\r\n    var y2 = Math.cos(lat2) * Math.sin(lng2);\r\n    var z2 = Math.sin(lat2);\r\n    var x = x1 + x2;\r\n    var y = y1 + y2;\r\n    var z = z1 + z2;\r\n    var Hyp = Math.sqrt(x * x + y * y);\r\n    var lng3 = Math.atan2(y, x);\r\n    var lat3 = Math.atan2(z, Hyp);\r\n    if (lng1 < lng2 || (lng1 > lng2 && lng1 > Math.PI && lng2 < -Math.PI)) {\r\n        lat3 = lat3 + Math.PI;\r\n        lng3 = lng3 + Math.PI;\r\n    }\r\n    else {\r\n        lat3 = rad2degr(lat3);\r\n        lng3 = rad2degr(lng3);\r\n    }\r\n    if (Math.abs(x) < Math.pow(10, -9) &&\r\n        Math.abs(y) < Math.pow(10, -9) &&\r\n        Math.abs(z) < Math.pow(10, -9)) {\r\n        lat3 = 0;\r\n        lng3 = 0;\r\n    }\r\n    return \"\".concat(lat3, \",\").concat(lng3);\r\n}\r\n/**\r\n * @param  {number} lat1\r\n * @param  {number} lng1\r\n * @param  {number} lat2\r\n * @param  {number} lng2\r\n * @returns {number}\r\n */\r\nfunction getDistanceInMeter(lat1, lng1, lat2, lng2) {\r\n    // Haversine Algorithm\r\n    var R = 6371e3; // metres\r\n    var latRad1 = (lat1 * Math.PI) / 180;\r\n    var latRad2 = (lat2 * Math.PI) / 180;\r\n    var latCenterRad = ((lat2 - lat1) * Math.PI) / 180;\r\n    var lngCenterRad = ((lng2 - lng1) * Math.PI) / 180;\r\n    var a = Math.sin(latCenterRad / 2) * Math.sin(latCenterRad / 2) +\r\n        Math.cos(latRad1) *\r\n            Math.cos(latRad2) *\r\n            Math.sin(lngCenterRad / 2) *\r\n            Math.sin(lngCenterRad / 2);\r\n    var bearing = 2 * Math.atan2(Math.sqrt(a), Math.sqrt(1 - a));\r\n    var distance = R * bearing; // in metres\r\n    return distance;\r\n}\n\nfunction adaptGeoPointsRules(geoSearchContext) {\r\n    if (!geoSearchContext) {\r\n        return undefined;\r\n    }\r\n    var insideBoundingBox = geoSearchContext.insideBoundingBox, aroundLatLng = geoSearchContext.aroundLatLng, aroundRadius = geoSearchContext.aroundRadius, minimumAroundRadius = geoSearchContext.minimumAroundRadius;\r\n    var middlePoint;\r\n    var radius;\r\n    if (aroundLatLng) {\r\n        middlePoint = aroundLatLng;\r\n    }\r\n    if (aroundRadius != null || minimumAroundRadius != null) {\r\n        if (aroundRadius != null)\r\n            radius = aroundRadius;\r\n        else\r\n            radius = minimumAroundRadius;\r\n    }\r\n    // If insideBoundingBox is provided it takes precedent over all other options\r\n    if (insideBoundingBox && typeof insideBoundingBox === 'string') {\r\n        var _a = insideBoundingBox.split(','), lat1Raw = _a[0], lng1Raw = _a[1], lat2Raw = _a[2], lng2Raw = _a[3];\r\n        var _b = [\r\n            parseFloat(lat1Raw),\r\n            parseFloat(lng1Raw),\r\n            parseFloat(lat2Raw),\r\n            parseFloat(lng2Raw),\r\n        ], lat1 = _b[0], lng1 = _b[1], lat2 = _b[2], lng2 = _b[3];\r\n        radius = getDistanceInMeter(lat1, lng1, lat2, lng2) / 2;\r\n        middlePoint = middleGeoPoints(lat1, lng1, lat2, lng2);\r\n    }\r\n    if (middlePoint != null && radius != null) {\r\n        var _c = middlePoint.split(','), lat3 = _c[0], lng3 = _c[1];\r\n        lat3 = Number.parseFloat(lat3).toFixed(5);\r\n        lng3 = Number.parseFloat(lng3).toFixed(5);\r\n        var filter = \"_geoRadius(\".concat(lat3, \", \").concat(lng3, \", \").concat(radius, \")\");\r\n        return { filter: filter };\r\n    }\r\n    return undefined;\r\n}\r\nfunction createGeoSearchContext(searchContext) {\r\n    var geoContext = {};\r\n    var aroundLatLng = searchContext.aroundLatLng, aroundLatLngViaIP = searchContext.aroundLatLngViaIP, aroundRadius = searchContext.aroundRadius, aroundPrecision = searchContext.aroundPrecision, minimumAroundRadius = searchContext.minimumAroundRadius, insideBoundingBox = searchContext.insideBoundingBox, insidePolygon = searchContext.insidePolygon;\r\n    if (aroundLatLng) {\r\n        geoContext.aroundLatLng = aroundLatLng;\r\n    }\r\n    if (aroundLatLngViaIP) {\r\n        console.warn('instant-meilisearch: `aroundLatLngViaIP` is not supported.');\r\n    }\r\n    if (aroundRadius) {\r\n        geoContext.aroundRadius = aroundRadius;\r\n    }\r\n    if (aroundPrecision) {\r\n        console.warn(\"instant-meilisearch: `aroundPrecision` is not supported.\\n    See this discussion to track its implementation https://github.com/meilisearch/product/discussions/264\");\r\n    }\r\n    if (minimumAroundRadius) {\r\n        geoContext.minimumAroundRadius = minimumAroundRadius;\r\n    }\r\n    if (insideBoundingBox) {\r\n        geoContext.insideBoundingBox = insideBoundingBox;\r\n    }\r\n    // See related issue: https://github.com/meilisearch/instant-meilisearch/issues/555\r\n    if (insidePolygon) {\r\n        console.warn(\"instant-meilisearch: `insidePolygon` is not implented in instant-meilisearch.\");\r\n    }\r\n    return geoContext;\r\n}\n\n/**\r\n * @param  {any} str\r\n * @returns {boolean}\r\n */\r\n/**\r\n * @param  {string} filter\r\n * @returns {string}\r\n */\r\nfunction replaceColonByEqualSign(filter) {\r\n    // will only change first occurence of `:`\r\n    return filter.replace(/:(.*)/i, '=\"$1\"');\r\n}\r\n/**\r\n * @param  {any[]} arr\r\n * @returns {string}\r\n */\r\nfunction stringifyArray(arr) {\r\n    return arr.reduce(function (acc, curr) {\r\n        return (acc += JSON.stringify(curr));\r\n    }, '');\r\n}\n\nfunction isPureObject(data) {\r\n    return typeof data === 'object' && !Array.isArray(data) && data !== null;\r\n}\n\n/**\r\n * apiKey callback definition\r\n * @callback apiKeyCallback\r\n * @returns {string} - The apiKey to use\r\n */\r\n/**\r\n * Validates host and apiKey parameters, throws if invalid\r\n * @param hostUrl\r\n * @param apiKey\r\n */\r\nfunction validateInstantMeiliSearchParams(hostUrl, apiKey) {\r\n    // Validate host url\r\n    if (typeof hostUrl !== 'string') {\r\n        throw new TypeError('Provided hostUrl value (1st parameter) is not a string, expected string');\r\n    }\r\n    // Validate api key\r\n    if (typeof apiKey !== 'string' && typeof apiKey !== 'function') {\r\n        throw new TypeError('Provided apiKey value (2nd parameter) is not a string or a function, expected string or function');\r\n    }\r\n}\n\n/**\r\n * Transform InstantSearch filter to Meilisearch filter.\r\n * Change sign from `:` to `=` in nested filter object.\r\n * example: [`genres:comedy`] becomes [`genres=comedy`]\r\n *\r\n * @param  {SearchContext['facetFilters']} filters?\r\n * @returns {Filter}\r\n */\r\nfunction transformFilter(filters) {\r\n    if (typeof filters === 'string') {\r\n        return replaceColonByEqualSign(filters);\r\n    }\r\n    else if (Array.isArray(filters))\r\n        return filters\r\n            .map(function (filter) {\r\n            if (Array.isArray(filter))\r\n                return filter\r\n                    .map(function (nestedFilter) { return replaceColonByEqualSign(nestedFilter); })\r\n                    .filter(function (elem) { return elem; });\r\n            else {\r\n                return replaceColonByEqualSign(filter);\r\n            }\r\n        })\r\n            .filter(function (elem) { return elem; });\r\n    return [];\r\n}\r\n/**\r\n * Return the filter in an array if it is a string\r\n * If filter is array, return without change.\r\n *\r\n * @param  {Filter} filter\r\n * @returns {Array}\r\n */\r\nfunction filterToArray(filter) {\r\n    // Filter is a string\r\n    if (filter === '')\r\n        return [];\r\n    else if (typeof filter === 'string')\r\n        return [filter];\r\n    // Filter is either an array of strings, or an array of array of strings\r\n    return filter;\r\n}\r\n/**\r\n * Merge facetFilters, numericFilters and filters together.\r\n *\r\n * @param  {Filter} facetFilters\r\n * @param  {Filter} numericFilters\r\n * @param  {string} filters\r\n * @returns {Filter}\r\n */\r\nfunction mergeFilters(facetFilters, numericFilters, filters) {\r\n    var adaptedFilters = filters.trim();\r\n    var adaptedFacetFilters = filterToArray(facetFilters);\r\n    var adaptedNumericFilters = filterToArray(numericFilters);\r\n    var adaptedFilter = __spreadArray(__spreadArray(__spreadArray([], adaptedFacetFilters, true), adaptedNumericFilters, true), [\r\n        adaptedFilters,\r\n    ], false);\r\n    var cleanedFilters = adaptedFilter.filter(function (filter) {\r\n        if (Array.isArray(filter)) {\r\n            return filter.length;\r\n        }\r\n        return filter;\r\n    });\r\n    return cleanedFilters;\r\n}\r\n/**\r\n * Adapt instantsearch.js filters to Meilisearch filters by\r\n * combining and transforming all provided filters.\r\n *\r\n * @param  {string|undefined} filters\r\n * @param  {SearchContext['numericFilters']} numericFilters\r\n * @param  {SearchContext['facetFilters']} facetFilters\r\n * @returns {Filter}\r\n */\r\nfunction adaptFilters(filters, numericFilters, facetFilters) {\r\n    var transformedFilter = transformFilter(facetFilters || []);\r\n    var transformedNumericFilter = transformFilter(numericFilters || []);\r\n    return mergeFilters(transformedFilter, transformedNumericFilter, filters || '');\r\n}\n\nfunction isPaginationRequired(filter, query, placeholderSearch) {\r\n    // To disable pagination:\r\n    // placeholderSearch must be disabled\r\n    // The search query must be empty\r\n    // There must be no filters\r\n    if (!placeholderSearch && !query && (!filter || filter.length === 0)) {\r\n        return false;\r\n    }\r\n    return true;\r\n}\r\nfunction setScrollPagination(pagination, paginationRequired) {\r\n    var page = pagination.page, hitsPerPage = pagination.hitsPerPage;\r\n    if (!paginationRequired) {\r\n        return {\r\n            limit: 0,\r\n            offset: 0\r\n        };\r\n    }\r\n    return {\r\n        limit: hitsPerPage + 1,\r\n        offset: page * hitsPerPage\r\n    };\r\n}\r\nfunction setFinitePagination(pagination, paginationRequired) {\r\n    var page = pagination.page, hitsPerPage = pagination.hitsPerPage;\r\n    if (!paginationRequired) {\r\n        return {\r\n            hitsPerPage: 0,\r\n            page: page + 1\r\n        };\r\n    }\r\n    else {\r\n        return {\r\n            hitsPerPage: hitsPerPage,\r\n            page: page + 1\r\n        };\r\n    }\r\n}\r\n/**\r\n * Adapts instantsearch.js and instant-meilisearch options\r\n * to meilisearch search query parameters.\r\n *\r\n * @param  {SearchContext} searchContext\r\n *\r\n * @returns {MeiliSearchParams}\r\n */\r\nfunction MeiliParamsCreator(searchContext) {\r\n    var meiliSearchParams = {};\r\n    var facets = searchContext.facets, attributesToSnippet = searchContext.attributesToSnippet, snippetEllipsisText = searchContext.snippetEllipsisText, attributesToRetrieve = searchContext.attributesToRetrieve, attributesToHighlight = searchContext.attributesToHighlight, highlightPreTag = searchContext.highlightPreTag, highlightPostTag = searchContext.highlightPostTag, placeholderSearch = searchContext.placeholderSearch, query = searchContext.query, sort = searchContext.sort, pagination = searchContext.pagination, matchingStrategy = searchContext.matchingStrategy, filters = searchContext.filters, numericFilters = searchContext.numericFilters, facetFilters = searchContext.facetFilters;\r\n    var meilisearchFilters = adaptFilters(filters, numericFilters, facetFilters);\r\n    return {\r\n        getParams: function () {\r\n            return meiliSearchParams;\r\n        },\r\n        addFacets: function () {\r\n            if (Array.isArray(facets)) {\r\n                meiliSearchParams.facets = facets;\r\n            }\r\n            else if (typeof facets === 'string') {\r\n                meiliSearchParams.facets = [facets];\r\n            }\r\n        },\r\n        addAttributesToCrop: function () {\r\n            if (attributesToSnippet) {\r\n                meiliSearchParams.attributesToCrop = attributesToSnippet;\r\n            }\r\n        },\r\n        addCropMarker: function () {\r\n            // Attributes To Crop marker\r\n            if (snippetEllipsisText != null) {\r\n                meiliSearchParams.cropMarker = snippetEllipsisText;\r\n            }\r\n        },\r\n        addAttributesToRetrieve: function () {\r\n            if (attributesToRetrieve) {\r\n                meiliSearchParams.attributesToRetrieve = attributesToRetrieve;\r\n            }\r\n        },\r\n        addFilters: function () {\r\n            if (meilisearchFilters.length) {\r\n                meiliSearchParams.filter = meilisearchFilters;\r\n            }\r\n        },\r\n        addAttributesToHighlight: function () {\r\n            meiliSearchParams.attributesToHighlight = attributesToHighlight || ['*'];\r\n        },\r\n        addPreTag: function () {\r\n            if (highlightPreTag) {\r\n                meiliSearchParams.highlightPreTag = highlightPreTag;\r\n            }\r\n            else {\r\n                meiliSearchParams.highlightPreTag = '__ais-highlight__';\r\n            }\r\n        },\r\n        addPostTag: function () {\r\n            if (highlightPostTag) {\r\n                meiliSearchParams.highlightPostTag = highlightPostTag;\r\n            }\r\n            else {\r\n                meiliSearchParams.highlightPostTag = '__/ais-highlight__';\r\n            }\r\n        },\r\n        addPagination: function () {\r\n            var paginationRequired = isPaginationRequired(meilisearchFilters, query, placeholderSearch);\r\n            if (pagination.finite) {\r\n                var _a = setFinitePagination(pagination, paginationRequired), hitsPerPage = _a.hitsPerPage, page = _a.page;\r\n                meiliSearchParams.hitsPerPage = hitsPerPage;\r\n                meiliSearchParams.page = page;\r\n            }\r\n            else {\r\n                var _b = setScrollPagination(pagination, paginationRequired), limit = _b.limit, offset = _b.offset;\r\n                meiliSearchParams.limit = limit;\r\n                meiliSearchParams.offset = offset;\r\n            }\r\n        },\r\n        addSort: function () {\r\n            if (sort === null || sort === void 0 ? void 0 : sort.length) {\r\n                meiliSearchParams.sort = [sort];\r\n            }\r\n        },\r\n        addGeoSearchRules: function () {\r\n            var geoSearchContext = createGeoSearchContext(searchContext);\r\n            var geoRules = adaptGeoPointsRules(geoSearchContext);\r\n            if (geoRules === null || geoRules === void 0 ? void 0 : geoRules.filter) {\r\n                if (meiliSearchParams.filter) {\r\n                    meiliSearchParams.filter.unshift(geoRules.filter);\r\n                }\r\n                else {\r\n                    meiliSearchParams.filter = [geoRules.filter];\r\n                }\r\n            }\r\n        },\r\n        addMatchingStrategy: function () {\r\n            if (matchingStrategy) {\r\n                meiliSearchParams.matchingStrategy = matchingStrategy;\r\n            }\r\n        }\r\n    };\r\n}\r\n/**\r\n * Adapt search request from instantsearch.js\r\n * to search request compliant with Meilisearch\r\n *\r\n * @param  {SearchContext} searchContext\r\n * @returns {MeiliSearchParams}\r\n */\r\nfunction adaptSearchParams(searchContext) {\r\n    var meilisearchParams = MeiliParamsCreator(searchContext);\r\n    meilisearchParams.addFacets();\r\n    meilisearchParams.addAttributesToHighlight();\r\n    meilisearchParams.addPreTag();\r\n    meilisearchParams.addPostTag();\r\n    meilisearchParams.addAttributesToRetrieve();\r\n    meilisearchParams.addAttributesToCrop();\r\n    meilisearchParams.addCropMarker();\r\n    meilisearchParams.addPagination();\r\n    meilisearchParams.addFilters();\r\n    meilisearchParams.addSort();\r\n    meilisearchParams.addGeoSearchRules();\r\n    meilisearchParams.addMatchingStrategy();\r\n    return meilisearchParams.getParams();\r\n}\n\n/**\r\n * Stringify values following instantsearch practices.\r\n *\r\n * @param  {any} value - value that needs to be stringified\r\n */\r\nfunction stringifyValue(value) {\r\n    if (typeof value === 'string') {\r\n        // String\r\n        return value;\r\n    }\r\n    else if (value === undefined) {\r\n        // undefined\r\n        return JSON.stringify(null);\r\n    }\r\n    else {\r\n        return JSON.stringify(value);\r\n    }\r\n}\r\n/**\r\n * Recursif function wrap the deepest possible value\r\n * the following way: { value: \"xx\" }.\r\n *\r\n * For example:\r\n *\r\n * {\r\n * \"rootField\": { \"value\": \"x\" }\r\n * \"nestedField\": { child: { value: \"y\" } }\r\n * }\r\n *\r\n * recursivity continues until the value is not an array or an object.\r\n *\r\n * @param  {any} value - value of a field\r\n *\r\n * @returns Record<string, any>\r\n */\r\nfunction wrapValue(value) {\r\n    if (Array.isArray(value)) {\r\n        // Array\r\n        return value.map(function (elem) { return wrapValue(elem); });\r\n    }\r\n    else if (isPureObject(value)) {\r\n        // Object\r\n        return Object.keys(value).reduce(function (nested, key) {\r\n            nested[key] = wrapValue(value[key]);\r\n            return nested;\r\n        }, {});\r\n    }\r\n    else {\r\n        return { value: stringifyValue(value) };\r\n    }\r\n}\r\n/**\r\n * Adapt Meilisearch formatted fields to a format compliant to instantsearch.js.\r\n *\r\n * @param  {Record<string} formattedHit\r\n * @param  {SearchContext} searchContext\r\n * @returns {Record}\r\n */\r\nfunction adaptFormattedFields(hit) {\r\n    if (!hit)\r\n        return {};\r\n    var _formattedResult = wrapValue(hit);\r\n    var highlightedHit = {\r\n        // We could not determine what the differences are between those two fields.\r\n        _highlightResult: _formattedResult,\r\n        _snippetResult: _formattedResult\r\n    };\r\n    return highlightedHit;\r\n}\n\n/**\r\n * @param  {any[]} hits\r\n * @returns {Array<Record<string, any>>}\r\n */\r\nfunction adaptGeoResponse(hits) {\r\n    var _a;\r\n    for (var i = 0; i < hits.length; i++) {\r\n        var objectID = \"\".concat(i + Math.random() * 1000000);\r\n        if (hits[i]._geo) {\r\n            hits[i]._geoloc = hits[i]._geo;\r\n            hits[i].objectID = objectID;\r\n        }\r\n        if ((_a = hits[i]._formatted) === null || _a === void 0 ? void 0 : _a._geo) {\r\n            hits[i]._formatted._geoloc = hits[i]._formatted._geo;\r\n            hits[i]._formatted.objectID = objectID;\r\n        }\r\n    }\r\n    return hits;\r\n}\n\n/**\r\n * @param  {MeiliSearchResponse<Record<string, any>>} searchResponse\r\n * @param  {SearchContext} searchContext\r\n * @returns {Array<Record<string, any>>}\r\n */\r\nfunction adaptHits(searchResponse, searchContext) {\r\n    var primaryKey = searchContext.primaryKey;\r\n    var hits = searchResponse.hits;\r\n    var _a = searchContext.pagination, finite = _a.finite, hitsPerPage = _a.hitsPerPage;\r\n    // if the length of the hits is bigger than the hitsPerPage\r\n    // It means that there is still pages to come as we append limit by hitsPerPage + 1\r\n    // In which case we still need to remove the additional hit returned by Meilisearch\r\n    if (!finite && hits.length > hitsPerPage) {\r\n        hits.splice(hits.length - 1, 1);\r\n    }\r\n    var adaptedHits = hits.map(function (hit) {\r\n        // Creates Hit object compliant with InstantSearch\r\n        if (Object.keys(hit).length > 0) {\r\n            var formattedHit = hit._formatted; hit._matchesPosition; var documentFields = __rest(hit, [\"_formatted\", \"_matchesPosition\"]);\r\n            var adaptedHit = Object.assign(documentFields, adaptFormattedFields(formattedHit));\r\n            if (primaryKey) {\r\n                adaptedHit.objectID = hit[primaryKey];\r\n            }\r\n            return adaptedHit;\r\n        }\r\n        return hit;\r\n    });\r\n    adaptedHits = adaptGeoResponse(adaptedHits);\r\n    return adaptedHits;\r\n}\n\nfunction adaptTotalHits(searchResponse) {\r\n    var _a = searchResponse.hitsPerPage, hitsPerPage = _a === void 0 ? 0 : _a, _b = searchResponse.totalPages, totalPages = _b === void 0 ? 0 : _b, estimatedTotalHits = searchResponse.estimatedTotalHits, totalHits = searchResponse.totalHits;\r\n    if (estimatedTotalHits != null) {\r\n        return estimatedTotalHits;\r\n    }\r\n    else if (totalHits != null) {\r\n        return totalHits;\r\n    }\r\n    // Should not happen but safeguarding just in case\r\n    return hitsPerPage * totalPages;\r\n}\n\nfunction adaptNbPages(searchResponse, hitsPerPage) {\r\n    if (searchResponse.totalPages != null) {\r\n        return searchResponse.totalPages;\r\n    }\r\n    // Avoid dividing by 0\r\n    if (hitsPerPage === 0) {\r\n        return 0;\r\n    }\r\n    var _a = searchResponse.limit, limit = _a === void 0 ? 20 : _a, _b = searchResponse.offset, offset = _b === void 0 ? 0 : _b, hits = searchResponse.hits;\r\n    var additionalPage = hits.length >= limit ? 1 : 0;\r\n    return offset / hitsPerPage + 1 + additionalPage;\r\n}\r\nfunction adaptPaginationParameters(searchResponse, paginationState) {\r\n    var hitsPerPage = paginationState.hitsPerPage, page = paginationState.page;\r\n    var nbPages = adaptNbPages(searchResponse, hitsPerPage);\r\n    return {\r\n        page: page,\r\n        nbPages: nbPages,\r\n        hitsPerPage: hitsPerPage\r\n    };\r\n}\n\nfunction getFacetNames(facets) {\r\n    if (!facets)\r\n        return [];\r\n    else if (typeof facets === 'string')\r\n        return [facets];\r\n    return facets;\r\n}\r\n// Fills the missing facetValue in the current facet distribution if `keepZeroFacet` is true\r\n// using the initial facet distribution. Ex:\r\n//\r\n// Initial distribution: { genres: { horror: 10, comedy: 4 } }\r\n// Current distribution: { genres: { horror: 3 }}\r\n// Returned distribution: { genres: { horror: 3, comedy: 0 }}\r\nfunction fillMissingFacetValues(facets, initialFacetDistribution, facetDistribution) {\r\n    var facetNames = getFacetNames(facets);\r\n    var filledDistribution = {};\r\n    for (var _i = 0, facetNames_1 = facetNames; _i < facetNames_1.length; _i++) {\r\n        var facet = facetNames_1[_i];\r\n        for (var facetValue in initialFacetDistribution[facet]) {\r\n            if (!filledDistribution[facet]) {\r\n                // initialize sub object\r\n                filledDistribution[facet] = facetDistribution[facet] || {};\r\n            }\r\n            if (!filledDistribution[facet][facetValue]) {\r\n                filledDistribution[facet][facetValue] = 0;\r\n            }\r\n            else {\r\n                filledDistribution[facet][facetValue] =\r\n                    facetDistribution[facet][facetValue];\r\n            }\r\n        }\r\n    }\r\n    return filledDistribution;\r\n}\r\nfunction adaptFacetDistribution(keepZeroFacets, facets, initialFacetDistribution, facetDistribution) {\r\n    if (keepZeroFacets) {\r\n        facetDistribution = facetDistribution || {};\r\n        return fillMissingFacetValues(facets, initialFacetDistribution, facetDistribution);\r\n    }\r\n    return facetDistribution;\r\n}\n\n/**\r\n * Adapt search response from Meilisearch\r\n * to search response compliant with instantsearch.js\r\n *\r\n * @param  {MeiliSearchResponse<Record<string>>} searchResponse\r\n * @param  {SearchContext} searchContext\r\n * @returns {{ results: Array<AlgoliaSearchResponse<T>> }}\r\n */\r\nfunction adaptSearchResponse(searchResponse, searchContext, initialFacetDistribution) {\r\n    var searchResponseOptionals = {};\r\n    var processingTimeMs = searchResponse.processingTimeMs, query = searchResponse.query, responseFacetDistribution = searchResponse.facetDistribution;\r\n    var keepZeroFacets = searchContext.keepZeroFacets, facets = searchContext.facets;\r\n    var _a = adaptPaginationParameters(searchResponse, searchContext.pagination), hitsPerPage = _a.hitsPerPage, page = _a.page, nbPages = _a.nbPages;\r\n    var hits = adaptHits(searchResponse, searchContext);\r\n    var nbHits = adaptTotalHits(searchResponse);\r\n    var facetDistribution = adaptFacetDistribution(keepZeroFacets, facets, initialFacetDistribution, responseFacetDistribution);\r\n    // Create response object compliant with InstantSearch\r\n    var adaptedSearchResponse = __assign({ index: searchContext.indexUid, hitsPerPage: hitsPerPage, page: page, facets: facetDistribution, nbPages: nbPages, nbHits: nbHits, processingTimeMS: processingTimeMs, query: query, hits: hits, params: '', exhaustiveNbHits: false }, searchResponseOptionals);\r\n    return adaptedSearchResponse;\r\n}\n\n/**\r\n * Create the current state of the pagination\r\n *\r\n * @param  {boolean} [finite]\r\n * @param  {number} [hitsPerPage]\r\n * @param  {number} [page]\r\n * @returns {SearchContext}\r\n */\r\nfunction createPaginationState(finite, hitsPerPage, page) {\r\n    return {\r\n        hitsPerPage: hitsPerPage === undefined ? 20 : hitsPerPage,\r\n        page: page || 0,\r\n        finite: !!finite\r\n    };\r\n}\n\n/**\r\n * @param  {AlgoliaMultipleQueriesQuery} searchRequest\r\n * @param  {Context} options\r\n * @returns {SearchContext}\r\n */\r\nfunction createSearchContext(searchRequest, options) {\r\n    // Split index name and possible sorting rules\r\n    var _a = searchRequest.indexName.split(':'), indexUid = _a[0], sortByArray = _a.slice(1);\r\n    var instantSearchParams = searchRequest.params;\r\n    var paginationState = createPaginationState(options.finitePagination, instantSearchParams === null || instantSearchParams === void 0 ? void 0 : instantSearchParams.hitsPerPage, instantSearchParams === null || instantSearchParams === void 0 ? void 0 : instantSearchParams.page);\r\n    var searchContext = __assign(__assign(__assign({}, options), instantSearchParams), { sort: sortByArray.join(':') || '', indexUid: indexUid, pagination: paginationState, placeholderSearch: options.placeholderSearch !== false, keepZeroFacets: !!options.keepZeroFacets });\r\n    return searchContext;\r\n}\n\n/**\r\n * @param  {Record<string} cache\r\n * @returns {SearchCache}\r\n */\r\nfunction SearchCache(cache) {\r\n    if (cache === void 0) { cache = {}; }\r\n    var searchCache = cache;\r\n    return {\r\n        getEntry: function (key) {\r\n            if (searchCache[key]) {\r\n                try {\r\n                    return JSON.parse(searchCache[key]);\r\n                }\r\n                catch (_) {\r\n                    return searchCache[key];\r\n                }\r\n            }\r\n            return undefined;\r\n        },\r\n        formatKey: function (components) {\r\n            return stringifyArray(components);\r\n        },\r\n        setEntry: function (key, searchResponse) {\r\n            searchCache[key] = JSON.stringify(searchResponse);\r\n        },\r\n        clearCache: function () {\r\n            searchCache = {};\r\n        }\r\n    };\r\n}\n\nfunction getIndexFacetDistribution(searchResolver, searchContext) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var defaultSearchContext, meilisearchParams, searchResponse;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    defaultSearchContext = __assign(__assign({}, searchContext), { \r\n                        // placeholdersearch true to ensure a request is made\r\n                        placeholderSearch: true, \r\n                        // query set to empty to ensure retrieving the default facetdistribution\r\n                        query: '' });\r\n                    meilisearchParams = MeiliParamsCreator(defaultSearchContext);\r\n                    meilisearchParams.addFacets();\r\n                    meilisearchParams.addPagination();\r\n                    return [4 /*yield*/, searchResolver.searchResponse(defaultSearchContext, meilisearchParams.getParams())];\r\n                case 1:\r\n                    searchResponse = _a.sent();\r\n                    return [2 /*return*/, searchResponse.facetDistribution || {}];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction initFacetDistribution(searchResolver, searchContext, initialFacetDistribution) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var _a, _b;\r\n        return __generator(this, function (_c) {\r\n            switch (_c.label) {\r\n                case 0:\r\n                    if (!!initialFacetDistribution[searchContext.indexUid]) return [3 /*break*/, 2];\r\n                    _a = initialFacetDistribution;\r\n                    _b = searchContext.indexUid;\r\n                    return [4 /*yield*/, getIndexFacetDistribution(searchResolver, searchContext)];\r\n                case 1:\r\n                    _a[_b] =\r\n                        _c.sent();\r\n                    _c.label = 2;\r\n                case 2: return [2 /*return*/, initialFacetDistribution];\r\n            }\r\n        });\r\n    });\r\n}\n\nvar PACKAGE_VERSION = '0.11.0';\n\nvar constructClientAgents = function (clientAgents) {\r\n    if (clientAgents === void 0) { clientAgents = []; }\r\n    var instantMeilisearchAgent = \"Meilisearch instant-meilisearch (v\".concat(PACKAGE_VERSION, \")\");\r\n    return clientAgents.concat(instantMeilisearchAgent);\r\n};\n\n/**\r\n * apiKey callback definition\r\n * @callback apiKeyCallback\r\n * @returns {string} - The apiKey to use\r\n */\r\n/**\r\n * Instantiate SearchClient required by instantsearch.js.\r\n * @param  {string} hostUrl\r\n * @param  {string | apiKeyCallback} apiKey\r\n * @param  {InstantMeiliSearchOptions={}} meiliSearchOptions\r\n * @returns {InstantMeiliSearchInstance}\r\n */\r\nfunction instantMeiliSearch(hostUrl, apiKey, instantMeiliSearchOptions) {\r\n    if (apiKey === void 0) { apiKey = ''; }\r\n    if (instantMeiliSearchOptions === void 0) { instantMeiliSearchOptions = {}; }\r\n    // Validate parameters\r\n    validateInstantMeiliSearchParams(hostUrl, apiKey);\r\n    // Resolve possible function to get apiKey\r\n    apiKey = getApiKey(apiKey);\r\n    var clientAgents = constructClientAgents(instantMeiliSearchOptions.clientAgents);\r\n    var meilisearchClient = new meilisearch__WEBPACK_IMPORTED_MODULE_0__.MeiliSearch({\r\n        host: hostUrl,\r\n        apiKey: apiKey,\r\n        clientAgents: clientAgents\r\n    });\r\n    var searchCache = SearchCache();\r\n    // create search resolver with included cache\r\n    var searchResolver = SearchResolver(meilisearchClient, searchCache);\r\n    var initialFacetDistribution = {};\r\n    return {\r\n        clearCache: function () { return searchCache.clearCache(); },\r\n        /**\r\n         * @param  {readonlyAlgoliaMultipleQueriesQuery[]} instantSearchRequests\r\n         * @returns {Array}\r\n         */\r\n        search: function (instantSearchRequests) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                var searchResponses, requests, _i, requests_1, searchRequest, searchContext, adaptedSearchRequest, searchResponse, adaptedSearchResponse, e_1;\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0:\r\n                            _a.trys.push([0, 6, , 7]);\r\n                            searchResponses = {\r\n                                results: []\r\n                            };\r\n                            requests = instantSearchRequests;\r\n                            _i = 0, requests_1 = requests;\r\n                            _a.label = 1;\r\n                        case 1:\r\n                            if (!(_i < requests_1.length)) return [3 /*break*/, 5];\r\n                            searchRequest = requests_1[_i];\r\n                            searchContext = createSearchContext(searchRequest, instantMeiliSearchOptions);\r\n                            adaptedSearchRequest = adaptSearchParams(searchContext);\r\n                            return [4 /*yield*/, initFacetDistribution(searchResolver, searchContext, initialFacetDistribution)\r\n                                // Search response from Meilisearch\r\n                            ];\r\n                        case 2:\r\n                            initialFacetDistribution = _a.sent();\r\n                            return [4 /*yield*/, searchResolver.searchResponse(searchContext, adaptedSearchRequest)\r\n                                // Adapt the Meilisearch response to a compliant instantsearch.js response\r\n                            ];\r\n                        case 3:\r\n                            searchResponse = _a.sent();\r\n                            adaptedSearchResponse = adaptSearchResponse(searchResponse, searchContext, initialFacetDistribution[searchRequest.indexName]);\r\n                            searchResponses.results.push(adaptedSearchResponse);\r\n                            _a.label = 4;\r\n                        case 4:\r\n                            _i++;\r\n                            return [3 /*break*/, 1];\r\n                        case 5: return [2 /*return*/, searchResponses];\r\n                        case 6:\r\n                            e_1 = _a.sent();\r\n                            console.error(e_1);\r\n                            throw new Error(e_1);\r\n                        case 7: return [2 /*return*/];\r\n                    }\r\n                });\r\n            });\r\n        },\r\n        searchForFacetValues: function (_) {\r\n            return __awaiter(this, void 0, void 0, function () {\r\n                return __generator(this, function (_a) {\r\n                    switch (_a.label) {\r\n                        case 0: return [4 /*yield*/, new Promise(function (resolve, reject) {\r\n                                reject(new Error('SearchForFacetValues is not compatible with Meilisearch'));\r\n                                resolve([]); // added here to avoid compilation error\r\n                            })];\r\n                        case 1: return [2 /*return*/, _a.sent()];\r\n                    }\r\n                });\r\n            });\r\n        }\r\n    };\r\n}\r\n/**\r\n * Resolves apiKey if it is a function\r\n * @param  {string | apiKeyCallback} apiKey\r\n * @returns {string} api key value\r\n */\r\nfunction getApiKey(apiKey) {\r\n    // If apiKey is function, call it to get the apiKey\r\n    if (typeof apiKey === 'function') {\r\n        var apiKeyFnValue = apiKey();\r\n        if (typeof apiKeyFnValue !== 'string') {\r\n            throw new TypeError('Provided apiKey function (2nd parameter) did not return a string, expected string');\r\n        }\r\n        return apiKeyFnValue;\r\n    }\r\n    return apiKey;\r\n}\n\nvar MatchingStrategies;\r\n(function (MatchingStrategies) {\r\n    MatchingStrategies[\"ALL\"] = \"all\";\r\n    MatchingStrategies[\"LAST\"] = \"last\";\r\n})(MatchingStrategies || (MatchingStrategies = {}));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvZGlzdC9pbnN0YW50LW1laWxpc2VhcmNoLmVzbS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBMEM7O0FBRTFDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZEQUE2RCxjQUFjO0FBQzNFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsNEJBQTRCLCtEQUErRCxpQkFBaUI7QUFDNUc7QUFDQSxvQ0FBb0MsTUFBTSwrQkFBK0IsWUFBWTtBQUNyRixtQ0FBbUMsTUFBTSxtQ0FBbUMsWUFBWTtBQUN4RixnQ0FBZ0M7QUFDaEM7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0EsY0FBYyw2QkFBNkIsMEJBQTBCLGNBQWMscUJBQXFCO0FBQ3hHLGlCQUFpQixvREFBb0QscUVBQXFFLGNBQWM7QUFDeEosdUJBQXVCLHNCQUFzQjtBQUM3QztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3Q0FBd0M7QUFDeEMsbUNBQW1DLFNBQVM7QUFDNUMsbUNBQW1DLFdBQVcsVUFBVTtBQUN4RCwwQ0FBMEMsY0FBYztBQUN4RDtBQUNBLDhHQUE4RyxPQUFPO0FBQ3JILGlGQUFpRixpQkFBaUI7QUFDbEcseURBQXlELGdCQUFnQixRQUFRO0FBQ2pGLCtDQUErQyxnQkFBZ0IsZ0JBQWdCO0FBQy9FO0FBQ0Esa0NBQWtDO0FBQ2xDO0FBQ0E7QUFDQSxVQUFVLFlBQVksYUFBYSxTQUFTLFVBQVU7QUFDdEQsb0NBQW9DLFNBQVM7QUFDN0M7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2RUFBNkUsT0FBTztBQUNwRjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZ0JBQWdCO0FBQzVCO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGVBQWU7QUFDbkMsb0JBQW9CLG1CQUFtQjtBQUN2QyxvQkFBb0IsYUFBYTtBQUNqQyxxQkFBcUI7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsaUJBQWlCO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQSxvQkFBb0I7QUFDcEI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnQ0FBZ0M7QUFDaEM7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0EsWUFBWSxLQUFLO0FBQ2pCLGFBQWE7QUFDYjtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLE9BQU87QUFDbkIsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMOztBQUVBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksK0JBQStCO0FBQzNDLGFBQWE7QUFDYjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG1EQUFtRCwrQ0FBK0M7QUFDbEcsOENBQThDLGNBQWM7QUFDNUQ7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNULHNDQUFzQyxjQUFjO0FBQ3BEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFFBQVE7QUFDcEIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxrQkFBa0I7QUFDOUIsWUFBWSxpQ0FBaUM7QUFDN0MsWUFBWSwrQkFBK0I7QUFDM0MsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLGVBQWU7QUFDM0I7QUFDQSxhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLEtBQUs7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx3QkFBd0IsYUFBYTtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBLGtCQUFrQjtBQUNsQixvQkFBb0IsU0FBUztBQUM3QjtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksS0FBSztBQUNqQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwyQ0FBMkMseUJBQXlCO0FBQ3BFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVMsSUFBSTtBQUNiO0FBQ0E7QUFDQSxpQkFBaUI7QUFDakI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVksZUFBZTtBQUMzQixZQUFZLGVBQWU7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksT0FBTztBQUNuQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CLGlCQUFpQjtBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQSxZQUFZLDBDQUEwQztBQUN0RCxZQUFZLGVBQWU7QUFDM0IsYUFBYTtBQUNiO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrQ0FBK0Msc0JBQXNCO0FBQ3JFO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsS0FBSztBQUNMO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJCQUEyQixVQUFVO0FBQ3JDLDJCQUEyQixVQUFVO0FBQ3JDLDRCQUE0QixVQUFVO0FBQ3RDO0FBQ0E7QUFDQTtBQUNBLGdEQUFnRCwwQkFBMEI7QUFDMUU7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsWUFBWSxxQ0FBcUM7QUFDakQsWUFBWSxlQUFlO0FBQzNCLGVBQWU7QUFDZjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDJDQUEyQyxxT0FBcU87QUFDaFI7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxZQUFZLFNBQVM7QUFDckIsWUFBWSxRQUFRO0FBQ3BCLFlBQVksUUFBUTtBQUNwQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTs7QUFFQTtBQUNBLFlBQVksNkJBQTZCO0FBQ3pDLFlBQVksU0FBUztBQUNyQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscURBQXFELG9DQUFvQyxzTEFBc0w7QUFDL1E7QUFDQTs7QUFFQTtBQUNBLFlBQVksZUFBZTtBQUMzQixhQUFhO0FBQ2I7QUFDQTtBQUNBLDRCQUE0QjtBQUM1QjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1Q7QUFDQTtBQUNBLFNBQVM7QUFDVDtBQUNBO0FBQ0EsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsK0RBQStEO0FBQy9EO0FBQ0E7QUFDQTtBQUNBLG1DQUFtQztBQUNuQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnRkFBZ0Y7QUFDaEY7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMOztBQUVBOztBQUVBO0FBQ0EsbUNBQW1DO0FBQ25DO0FBQ0E7QUFDQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQSxhQUFhLFFBQVE7QUFDckI7QUFDQTtBQUNBO0FBQ0EsWUFBWSxRQUFRO0FBQ3BCLFlBQVkseUJBQXlCO0FBQ3JDLFlBQVksOEJBQThCO0FBQzFDLGFBQWE7QUFDYjtBQUNBO0FBQ0EsNkJBQTZCO0FBQzdCLGdEQUFnRDtBQUNoRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0NBQWdDLG9EQUFXO0FBQzNDO0FBQ0E7QUFDQTtBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLGtDQUFrQztBQUNwRTtBQUNBLG9CQUFvQix1Q0FBdUM7QUFDM0QscUJBQXFCO0FBQ3JCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZDQUE2QztBQUM3Qyw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBLGlCQUFpQjtBQUNqQixhQUFhO0FBQ2I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFlBQVkseUJBQXlCO0FBQ3JDLGFBQWEsUUFBUTtBQUNyQjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDLGdEQUFnRDs7QUFFQyIsInNvdXJjZXMiOlsid2VicGFjazovL3N0YXJ0dXAtbmV4dGpzLXRlbXBsYXRlLy4vbm9kZV9tb2R1bGVzL0BtZWlsaXNlYXJjaC9pbnN0YW50LW1laWxpc2VhcmNoL2Rpc3QvaW5zdGFudC1tZWlsaXNlYXJjaC5lc20uanM/YzEwYSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBNZWlsaVNlYXJjaCB9IGZyb20gJ21laWxpc2VhcmNoJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKlxyXG5Db3B5cmlnaHQgKGMpIE1pY3Jvc29mdCBDb3Jwb3JhdGlvbi5cclxuXHJcblBlcm1pc3Npb24gdG8gdXNlLCBjb3B5LCBtb2RpZnksIGFuZC9vciBkaXN0cmlidXRlIHRoaXMgc29mdHdhcmUgZm9yIGFueVxyXG5wdXJwb3NlIHdpdGggb3Igd2l0aG91dCBmZWUgaXMgaGVyZWJ5IGdyYW50ZWQuXHJcblxyXG5USEUgU09GVFdBUkUgSVMgUFJPVklERUQgXCJBUyBJU1wiIEFORCBUSEUgQVVUSE9SIERJU0NMQUlNUyBBTEwgV0FSUkFOVElFUyBXSVRIXHJcblJFR0FSRCBUTyBUSElTIFNPRlRXQVJFIElOQ0xVRElORyBBTEwgSU1QTElFRCBXQVJSQU5USUVTIE9GIE1FUkNIQU5UQUJJTElUWVxyXG5BTkQgRklUTkVTUy4gSU4gTk8gRVZFTlQgU0hBTEwgVEhFIEFVVEhPUiBCRSBMSUFCTEUgRk9SIEFOWSBTUEVDSUFMLCBESVJFQ1QsXHJcbklORElSRUNULCBPUiBDT05TRVFVRU5USUFMIERBTUFHRVMgT1IgQU5ZIERBTUFHRVMgV0hBVFNPRVZFUiBSRVNVTFRJTkcgRlJPTVxyXG5MT1NTIE9GIFVTRSwgREFUQSBPUiBQUk9GSVRTLCBXSEVUSEVSIElOIEFOIEFDVElPTiBPRiBDT05UUkFDVCwgTkVHTElHRU5DRSBPUlxyXG5PVEhFUiBUT1JUSU9VUyBBQ1RJT04sIEFSSVNJTkcgT1VUIE9GIE9SIElOIENPTk5FQ1RJT04gV0lUSCBUSEUgVVNFIE9SXHJcblBFUkZPUk1BTkNFIE9GIFRISVMgU09GVFdBUkUuXHJcbioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqICovXHJcblxyXG52YXIgX19hc3NpZ24gPSBmdW5jdGlvbigpIHtcclxuICAgIF9fYXNzaWduID0gT2JqZWN0LmFzc2lnbiB8fCBmdW5jdGlvbiBfX2Fzc2lnbih0KSB7XHJcbiAgICAgICAgZm9yICh2YXIgcywgaSA9IDEsIG4gPSBhcmd1bWVudHMubGVuZ3RoOyBpIDwgbjsgaSsrKSB7XHJcbiAgICAgICAgICAgIHMgPSBhcmd1bWVudHNbaV07XHJcbiAgICAgICAgICAgIGZvciAodmFyIHAgaW4gcykgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChzLCBwKSkgdFtwXSA9IHNbcF07XHJcbiAgICAgICAgfVxyXG4gICAgICAgIHJldHVybiB0O1xyXG4gICAgfTtcclxuICAgIHJldHVybiBfX2Fzc2lnbi5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xyXG59O1xyXG5cclxuZnVuY3Rpb24gX19yZXN0KHMsIGUpIHtcclxuICAgIHZhciB0ID0ge307XHJcbiAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkgJiYgZS5pbmRleE9mKHApIDwgMClcclxuICAgICAgICB0W3BdID0gc1twXTtcclxuICAgIGlmIChzICE9IG51bGwgJiYgdHlwZW9mIE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMgPT09IFwiZnVuY3Rpb25cIilcclxuICAgICAgICBmb3IgKHZhciBpID0gMCwgcCA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMocyk7IGkgPCBwLmxlbmd0aDsgaSsrKSB7XHJcbiAgICAgICAgICAgIGlmIChlLmluZGV4T2YocFtpXSkgPCAwICYmIE9iamVjdC5wcm90b3R5cGUucHJvcGVydHlJc0VudW1lcmFibGUuY2FsbChzLCBwW2ldKSlcclxuICAgICAgICAgICAgICAgIHRbcFtpXV0gPSBzW3BbaV1dO1xyXG4gICAgICAgIH1cclxuICAgIHJldHVybiB0O1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2F3YWl0ZXIodGhpc0FyZywgX2FyZ3VtZW50cywgUCwgZ2VuZXJhdG9yKSB7XHJcbiAgICBmdW5jdGlvbiBhZG9wdCh2YWx1ZSkgeyByZXR1cm4gdmFsdWUgaW5zdGFuY2VvZiBQID8gdmFsdWUgOiBuZXcgUChmdW5jdGlvbiAocmVzb2x2ZSkgeyByZXNvbHZlKHZhbHVlKTsgfSk7IH1cclxuICAgIHJldHVybiBuZXcgKFAgfHwgKFAgPSBQcm9taXNlKSkoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgIGZ1bmN0aW9uIGZ1bGZpbGxlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvci5uZXh0KHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiByZWplY3RlZCh2YWx1ZSkgeyB0cnkgeyBzdGVwKGdlbmVyYXRvcltcInRocm93XCJdKHZhbHVlKSk7IH0gY2F0Y2ggKGUpIHsgcmVqZWN0KGUpOyB9IH1cclxuICAgICAgICBmdW5jdGlvbiBzdGVwKHJlc3VsdCkgeyByZXN1bHQuZG9uZSA/IHJlc29sdmUocmVzdWx0LnZhbHVlKSA6IGFkb3B0KHJlc3VsdC52YWx1ZSkudGhlbihmdWxmaWxsZWQsIHJlamVjdGVkKTsgfVxyXG4gICAgICAgIHN0ZXAoKGdlbmVyYXRvciA9IGdlbmVyYXRvci5hcHBseSh0aGlzQXJnLCBfYXJndW1lbnRzIHx8IFtdKSkubmV4dCgpKTtcclxuICAgIH0pO1xyXG59XHJcblxyXG5mdW5jdGlvbiBfX2dlbmVyYXRvcih0aGlzQXJnLCBib2R5KSB7XHJcbiAgICB2YXIgXyA9IHsgbGFiZWw6IDAsIHNlbnQ6IGZ1bmN0aW9uKCkgeyBpZiAodFswXSAmIDEpIHRocm93IHRbMV07IHJldHVybiB0WzFdOyB9LCB0cnlzOiBbXSwgb3BzOiBbXSB9LCBmLCB5LCB0LCBnO1xyXG4gICAgcmV0dXJuIGcgPSB7IG5leHQ6IHZlcmIoMCksIFwidGhyb3dcIjogdmVyYigxKSwgXCJyZXR1cm5cIjogdmVyYigyKSB9LCB0eXBlb2YgU3ltYm9sID09PSBcImZ1bmN0aW9uXCIgJiYgKGdbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkgeyByZXR1cm4gdGhpczsgfSksIGc7XHJcbiAgICBmdW5jdGlvbiB2ZXJiKG4pIHsgcmV0dXJuIGZ1bmN0aW9uICh2KSB7IHJldHVybiBzdGVwKFtuLCB2XSk7IH07IH1cclxuICAgIGZ1bmN0aW9uIHN0ZXAob3ApIHtcclxuICAgICAgICBpZiAoZikgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkdlbmVyYXRvciBpcyBhbHJlYWR5IGV4ZWN1dGluZy5cIik7XHJcbiAgICAgICAgd2hpbGUgKGcgJiYgKGcgPSAwLCBvcFswXSAmJiAoXyA9IDApKSwgXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XHJcblxyXG5mdW5jdGlvbiBfX3NwcmVhZEFycmF5KHRvLCBmcm9tLCBwYWNrKSB7XHJcbiAgICBpZiAocGFjayB8fCBhcmd1bWVudHMubGVuZ3RoID09PSAyKSBmb3IgKHZhciBpID0gMCwgbCA9IGZyb20ubGVuZ3RoLCBhcjsgaSA8IGw7IGkrKykge1xyXG4gICAgICAgIGlmIChhciB8fCAhKGkgaW4gZnJvbSkpIHtcclxuICAgICAgICAgICAgaWYgKCFhcikgYXIgPSBBcnJheS5wcm90b3R5cGUuc2xpY2UuY2FsbChmcm9tLCAwLCBpKTtcclxuICAgICAgICAgICAgYXJbaV0gPSBmcm9tW2ldO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiB0by5jb25jYXQoYXIgfHwgQXJyYXkucHJvdG90eXBlLnNsaWNlLmNhbGwoZnJvbSkpO1xyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHtSZXNwb25zZUNhY2hlcn0gY2FjaGVcclxuICovXHJcbmZ1bmN0aW9uIFNlYXJjaFJlc29sdmVyKGNsaWVudCwgY2FjaGUpIHtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgLyoqXHJcbiAgICAgICAgICogQHBhcmFtICB7U2VhcmNoQ29udGV4dH0gc2VhcmNoQ29udGV4dFxyXG4gICAgICAgICAqIEBwYXJhbSAge01laWxpU2VhcmNoUGFyYW1zfSBzZWFyY2hQYXJhbXNcclxuICAgICAgICAgKiBAcGFyYW0gIHtNZWlsaVNlYXJjaH0gY2xpZW50XHJcbiAgICAgICAgICogQHJldHVybnMge1Byb21pc2V9XHJcbiAgICAgICAgICovXHJcbiAgICAgICAgc2VhcmNoUmVzcG9uc2U6IGZ1bmN0aW9uIChzZWFyY2hDb250ZXh0LCBzZWFyY2hQYXJhbXMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIGtleSwgY2FjaGVkUmVzcG9uc2UsIHNlYXJjaFJlc3BvbnNlO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAga2V5ID0gY2FjaGUuZm9ybWF0S2V5KFtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hQYXJhbXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoQ29udGV4dC5pbmRleFVpZCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hDb250ZXh0LnF1ZXJ5LFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaENvbnRleHQucGFnaW5hdGlvbixcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY2FjaGVkUmVzcG9uc2UgPSBjYWNoZS5nZXRFbnRyeShrZXkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gQ2hlY2sgaWYgc3BlY2lmaWMgcmVxdWVzdCBpcyBhbHJlYWR5IGNhY2hlZCB3aXRoIGl0cyBhc3NvY2lhdGVkIHNlYXJjaCByZXNwb25zZS5cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmIChjYWNoZWRSZXNwb25zZSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgY2FjaGVkUmVzcG9uc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLy8gTWFrZSBzZWFyY2ggcmVxdWVzdFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBjbGllbnRcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmluZGV4KHNlYXJjaENvbnRleHQuaW5kZXhVaWQpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5zZWFyY2goc2VhcmNoQ29udGV4dC5xdWVyeSwgc2VhcmNoUGFyYW1zKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBzZWFyY2hSZXNwb25zZSA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIENhY2hlIHJlc3BvbnNlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjYWNoZS5zZXRFbnRyeShrZXksIHNlYXJjaFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzZWFyY2hSZXNwb25zZV07XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH1cclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gcmFkXHJcbiAqIEByZXR1cm5zIHtudW1iZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiByYWQyZGVncihyYWQpIHtcclxuICAgIHJldHVybiAocmFkICogMTgwKSAvIE1hdGguUEk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gZGVnclxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZGVncjJyYWQoZGVncikge1xyXG4gICAgcmV0dXJuIChkZWdyICogTWF0aC5QSSkgLyAxODA7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gbGF0MVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxuZzFcclxuICogQHBhcmFtICB7bnVtYmVyfSBsYXQyXHJcbiAqIEBwYXJhbSAge251bWJlcn0gbG5nMlxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfVxyXG4gKi9cclxuZnVuY3Rpb24gbWlkZGxlR2VvUG9pbnRzKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpIHtcclxuICAgIC8vIGNvbnZlcnQgdG8gcmFkaWFuc1xyXG4gICAgbGF0MSA9IGRlZ3IycmFkKGxhdDEpO1xyXG4gICAgbG5nMSA9IGRlZ3IycmFkKGxuZzEpO1xyXG4gICAgdmFyIHgxID0gTWF0aC5jb3MobGF0MSkgKiBNYXRoLmNvcyhsbmcxKTtcclxuICAgIHZhciB5MSA9IE1hdGguY29zKGxhdDEpICogTWF0aC5zaW4obG5nMSk7XHJcbiAgICB2YXIgejEgPSBNYXRoLnNpbihsYXQxKTtcclxuICAgIC8vIGNvbnZlcnQgdG8gcmFkaWFuc1xyXG4gICAgbGF0MiA9IGRlZ3IycmFkKGxhdDIpO1xyXG4gICAgbG5nMiA9IGRlZ3IycmFkKGxuZzIpO1xyXG4gICAgdmFyIHgyID0gTWF0aC5jb3MobGF0MikgKiBNYXRoLmNvcyhsbmcyKTtcclxuICAgIHZhciB5MiA9IE1hdGguY29zKGxhdDIpICogTWF0aC5zaW4obG5nMik7XHJcbiAgICB2YXIgejIgPSBNYXRoLnNpbihsYXQyKTtcclxuICAgIHZhciB4ID0geDEgKyB4MjtcclxuICAgIHZhciB5ID0geTEgKyB5MjtcclxuICAgIHZhciB6ID0gejEgKyB6MjtcclxuICAgIHZhciBIeXAgPSBNYXRoLnNxcnQoeCAqIHggKyB5ICogeSk7XHJcbiAgICB2YXIgbG5nMyA9IE1hdGguYXRhbjIoeSwgeCk7XHJcbiAgICB2YXIgbGF0MyA9IE1hdGguYXRhbjIoeiwgSHlwKTtcclxuICAgIGlmIChsbmcxIDwgbG5nMiB8fCAobG5nMSA+IGxuZzIgJiYgbG5nMSA+IE1hdGguUEkgJiYgbG5nMiA8IC1NYXRoLlBJKSkge1xyXG4gICAgICAgIGxhdDMgPSBsYXQzICsgTWF0aC5QSTtcclxuICAgICAgICBsbmczID0gbG5nMyArIE1hdGguUEk7XHJcbiAgICB9XHJcbiAgICBlbHNlIHtcclxuICAgICAgICBsYXQzID0gcmFkMmRlZ3IobGF0Myk7XHJcbiAgICAgICAgbG5nMyA9IHJhZDJkZWdyKGxuZzMpO1xyXG4gICAgfVxyXG4gICAgaWYgKE1hdGguYWJzKHgpIDwgTWF0aC5wb3coMTAsIC05KSAmJlxyXG4gICAgICAgIE1hdGguYWJzKHkpIDwgTWF0aC5wb3coMTAsIC05KSAmJlxyXG4gICAgICAgIE1hdGguYWJzKHopIDwgTWF0aC5wb3coMTAsIC05KSkge1xyXG4gICAgICAgIGxhdDMgPSAwO1xyXG4gICAgICAgIGxuZzMgPSAwO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIFwiXCIuY29uY2F0KGxhdDMsIFwiLFwiKS5jb25jYXQobG5nMyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSAge251bWJlcn0gbGF0MVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IGxuZzFcclxuICogQHBhcmFtICB7bnVtYmVyfSBsYXQyXHJcbiAqIEBwYXJhbSAge251bWJlcn0gbG5nMlxyXG4gKiBAcmV0dXJucyB7bnVtYmVyfVxyXG4gKi9cclxuZnVuY3Rpb24gZ2V0RGlzdGFuY2VJbk1ldGVyKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpIHtcclxuICAgIC8vIEhhdmVyc2luZSBBbGdvcml0aG1cclxuICAgIHZhciBSID0gNjM3MWUzOyAvLyBtZXRyZXNcclxuICAgIHZhciBsYXRSYWQxID0gKGxhdDEgKiBNYXRoLlBJKSAvIDE4MDtcclxuICAgIHZhciBsYXRSYWQyID0gKGxhdDIgKiBNYXRoLlBJKSAvIDE4MDtcclxuICAgIHZhciBsYXRDZW50ZXJSYWQgPSAoKGxhdDIgLSBsYXQxKSAqIE1hdGguUEkpIC8gMTgwO1xyXG4gICAgdmFyIGxuZ0NlbnRlclJhZCA9ICgobG5nMiAtIGxuZzEpICogTWF0aC5QSSkgLyAxODA7XHJcbiAgICB2YXIgYSA9IE1hdGguc2luKGxhdENlbnRlclJhZCAvIDIpICogTWF0aC5zaW4obGF0Q2VudGVyUmFkIC8gMikgK1xyXG4gICAgICAgIE1hdGguY29zKGxhdFJhZDEpICpcclxuICAgICAgICAgICAgTWF0aC5jb3MobGF0UmFkMikgKlxyXG4gICAgICAgICAgICBNYXRoLnNpbihsbmdDZW50ZXJSYWQgLyAyKSAqXHJcbiAgICAgICAgICAgIE1hdGguc2luKGxuZ0NlbnRlclJhZCAvIDIpO1xyXG4gICAgdmFyIGJlYXJpbmcgPSAyICogTWF0aC5hdGFuMihNYXRoLnNxcnQoYSksIE1hdGguc3FydCgxIC0gYSkpO1xyXG4gICAgdmFyIGRpc3RhbmNlID0gUiAqIGJlYXJpbmc7IC8vIGluIG1ldHJlc1xyXG4gICAgcmV0dXJuIGRpc3RhbmNlO1xyXG59XG5cbmZ1bmN0aW9uIGFkYXB0R2VvUG9pbnRzUnVsZXMoZ2VvU2VhcmNoQ29udGV4dCkge1xyXG4gICAgaWYgKCFnZW9TZWFyY2hDb250ZXh0KSB7XHJcbiAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgIH1cclxuICAgIHZhciBpbnNpZGVCb3VuZGluZ0JveCA9IGdlb1NlYXJjaENvbnRleHQuaW5zaWRlQm91bmRpbmdCb3gsIGFyb3VuZExhdExuZyA9IGdlb1NlYXJjaENvbnRleHQuYXJvdW5kTGF0TG5nLCBhcm91bmRSYWRpdXMgPSBnZW9TZWFyY2hDb250ZXh0LmFyb3VuZFJhZGl1cywgbWluaW11bUFyb3VuZFJhZGl1cyA9IGdlb1NlYXJjaENvbnRleHQubWluaW11bUFyb3VuZFJhZGl1cztcclxuICAgIHZhciBtaWRkbGVQb2ludDtcclxuICAgIHZhciByYWRpdXM7XHJcbiAgICBpZiAoYXJvdW5kTGF0TG5nKSB7XHJcbiAgICAgICAgbWlkZGxlUG9pbnQgPSBhcm91bmRMYXRMbmc7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJvdW5kUmFkaXVzICE9IG51bGwgfHwgbWluaW11bUFyb3VuZFJhZGl1cyAhPSBudWxsKSB7XHJcbiAgICAgICAgaWYgKGFyb3VuZFJhZGl1cyAhPSBudWxsKVxyXG4gICAgICAgICAgICByYWRpdXMgPSBhcm91bmRSYWRpdXM7XHJcbiAgICAgICAgZWxzZVxyXG4gICAgICAgICAgICByYWRpdXMgPSBtaW5pbXVtQXJvdW5kUmFkaXVzO1xyXG4gICAgfVxyXG4gICAgLy8gSWYgaW5zaWRlQm91bmRpbmdCb3ggaXMgcHJvdmlkZWQgaXQgdGFrZXMgcHJlY2VkZW50IG92ZXIgYWxsIG90aGVyIG9wdGlvbnNcclxuICAgIGlmIChpbnNpZGVCb3VuZGluZ0JveCAmJiB0eXBlb2YgaW5zaWRlQm91bmRpbmdCb3ggPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdmFyIF9hID0gaW5zaWRlQm91bmRpbmdCb3guc3BsaXQoJywnKSwgbGF0MVJhdyA9IF9hWzBdLCBsbmcxUmF3ID0gX2FbMV0sIGxhdDJSYXcgPSBfYVsyXSwgbG5nMlJhdyA9IF9hWzNdO1xyXG4gICAgICAgIHZhciBfYiA9IFtcclxuICAgICAgICAgICAgcGFyc2VGbG9hdChsYXQxUmF3KSxcclxuICAgICAgICAgICAgcGFyc2VGbG9hdChsbmcxUmF3KSxcclxuICAgICAgICAgICAgcGFyc2VGbG9hdChsYXQyUmF3KSxcclxuICAgICAgICAgICAgcGFyc2VGbG9hdChsbmcyUmF3KSxcclxuICAgICAgICBdLCBsYXQxID0gX2JbMF0sIGxuZzEgPSBfYlsxXSwgbGF0MiA9IF9iWzJdLCBsbmcyID0gX2JbM107XHJcbiAgICAgICAgcmFkaXVzID0gZ2V0RGlzdGFuY2VJbk1ldGVyKGxhdDEsIGxuZzEsIGxhdDIsIGxuZzIpIC8gMjtcclxuICAgICAgICBtaWRkbGVQb2ludCA9IG1pZGRsZUdlb1BvaW50cyhsYXQxLCBsbmcxLCBsYXQyLCBsbmcyKTtcclxuICAgIH1cclxuICAgIGlmIChtaWRkbGVQb2ludCAhPSBudWxsICYmIHJhZGl1cyAhPSBudWxsKSB7XHJcbiAgICAgICAgdmFyIF9jID0gbWlkZGxlUG9pbnQuc3BsaXQoJywnKSwgbGF0MyA9IF9jWzBdLCBsbmczID0gX2NbMV07XHJcbiAgICAgICAgbGF0MyA9IE51bWJlci5wYXJzZUZsb2F0KGxhdDMpLnRvRml4ZWQoNSk7XHJcbiAgICAgICAgbG5nMyA9IE51bWJlci5wYXJzZUZsb2F0KGxuZzMpLnRvRml4ZWQoNSk7XHJcbiAgICAgICAgdmFyIGZpbHRlciA9IFwiX2dlb1JhZGl1cyhcIi5jb25jYXQobGF0MywgXCIsIFwiKS5jb25jYXQobG5nMywgXCIsIFwiKS5jb25jYXQocmFkaXVzLCBcIilcIik7XHJcbiAgICAgICAgcmV0dXJuIHsgZmlsdGVyOiBmaWx0ZXIgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlR2VvU2VhcmNoQ29udGV4dChzZWFyY2hDb250ZXh0KSB7XHJcbiAgICB2YXIgZ2VvQ29udGV4dCA9IHt9O1xyXG4gICAgdmFyIGFyb3VuZExhdExuZyA9IHNlYXJjaENvbnRleHQuYXJvdW5kTGF0TG5nLCBhcm91bmRMYXRMbmdWaWFJUCA9IHNlYXJjaENvbnRleHQuYXJvdW5kTGF0TG5nVmlhSVAsIGFyb3VuZFJhZGl1cyA9IHNlYXJjaENvbnRleHQuYXJvdW5kUmFkaXVzLCBhcm91bmRQcmVjaXNpb24gPSBzZWFyY2hDb250ZXh0LmFyb3VuZFByZWNpc2lvbiwgbWluaW11bUFyb3VuZFJhZGl1cyA9IHNlYXJjaENvbnRleHQubWluaW11bUFyb3VuZFJhZGl1cywgaW5zaWRlQm91bmRpbmdCb3ggPSBzZWFyY2hDb250ZXh0Lmluc2lkZUJvdW5kaW5nQm94LCBpbnNpZGVQb2x5Z29uID0gc2VhcmNoQ29udGV4dC5pbnNpZGVQb2x5Z29uO1xyXG4gICAgaWYgKGFyb3VuZExhdExuZykge1xyXG4gICAgICAgIGdlb0NvbnRleHQuYXJvdW5kTGF0TG5nID0gYXJvdW5kTGF0TG5nO1xyXG4gICAgfVxyXG4gICAgaWYgKGFyb3VuZExhdExuZ1ZpYUlQKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKCdpbnN0YW50LW1laWxpc2VhcmNoOiBgYXJvdW5kTGF0TG5nVmlhSVBgIGlzIG5vdCBzdXBwb3J0ZWQuJyk7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJvdW5kUmFkaXVzKSB7XHJcbiAgICAgICAgZ2VvQ29udGV4dC5hcm91bmRSYWRpdXMgPSBhcm91bmRSYWRpdXM7XHJcbiAgICB9XHJcbiAgICBpZiAoYXJvdW5kUHJlY2lzaW9uKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW5zdGFudC1tZWlsaXNlYXJjaDogYGFyb3VuZFByZWNpc2lvbmAgaXMgbm90IHN1cHBvcnRlZC5cXG4gICAgU2VlIHRoaXMgZGlzY3Vzc2lvbiB0byB0cmFjayBpdHMgaW1wbGVtZW50YXRpb24gaHR0cHM6Ly9naXRodWIuY29tL21laWxpc2VhcmNoL3Byb2R1Y3QvZGlzY3Vzc2lvbnMvMjY0XCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKG1pbmltdW1Bcm91bmRSYWRpdXMpIHtcclxuICAgICAgICBnZW9Db250ZXh0Lm1pbmltdW1Bcm91bmRSYWRpdXMgPSBtaW5pbXVtQXJvdW5kUmFkaXVzO1xyXG4gICAgfVxyXG4gICAgaWYgKGluc2lkZUJvdW5kaW5nQm94KSB7XHJcbiAgICAgICAgZ2VvQ29udGV4dC5pbnNpZGVCb3VuZGluZ0JveCA9IGluc2lkZUJvdW5kaW5nQm94O1xyXG4gICAgfVxyXG4gICAgLy8gU2VlIHJlbGF0ZWQgaXNzdWU6IGh0dHBzOi8vZ2l0aHViLmNvbS9tZWlsaXNlYXJjaC9pbnN0YW50LW1laWxpc2VhcmNoL2lzc3Vlcy81NTVcclxuICAgIGlmIChpbnNpZGVQb2x5Z29uKSB7XHJcbiAgICAgICAgY29uc29sZS53YXJuKFwiaW5zdGFudC1tZWlsaXNlYXJjaDogYGluc2lkZVBvbHlnb25gIGlzIG5vdCBpbXBsZW50ZWQgaW4gaW5zdGFudC1tZWlsaXNlYXJjaC5cIik7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZ2VvQ29udGV4dDtcclxufVxuXG4vKipcclxuICogQHBhcmFtICB7YW55fSBzdHJcclxuICogQHJldHVybnMge2Jvb2xlYW59XHJcbiAqL1xyXG4vKipcclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWx0ZXJcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIHJlcGxhY2VDb2xvbkJ5RXF1YWxTaWduKGZpbHRlcikge1xyXG4gICAgLy8gd2lsbCBvbmx5IGNoYW5nZSBmaXJzdCBvY2N1cmVuY2Ugb2YgYDpgXHJcbiAgICByZXR1cm4gZmlsdGVyLnJlcGxhY2UoLzooLiopL2ksICc9XCIkMVwiJyk7XHJcbn1cclxuLyoqXHJcbiAqIEBwYXJhbSAge2FueVtdfSBhcnJcclxuICogQHJldHVybnMge3N0cmluZ31cclxuICovXHJcbmZ1bmN0aW9uIHN0cmluZ2lmeUFycmF5KGFycikge1xyXG4gICAgcmV0dXJuIGFyci5yZWR1Y2UoZnVuY3Rpb24gKGFjYywgY3Vycikge1xyXG4gICAgICAgIHJldHVybiAoYWNjICs9IEpTT04uc3RyaW5naWZ5KGN1cnIpKTtcclxuICAgIH0sICcnKTtcclxufVxuXG5mdW5jdGlvbiBpc1B1cmVPYmplY3QoZGF0YSkge1xyXG4gICAgcmV0dXJuIHR5cGVvZiBkYXRhID09PSAnb2JqZWN0JyAmJiAhQXJyYXkuaXNBcnJheShkYXRhKSAmJiBkYXRhICE9PSBudWxsO1xyXG59XG5cbi8qKlxyXG4gKiBhcGlLZXkgY2FsbGJhY2sgZGVmaW5pdGlvblxyXG4gKiBAY2FsbGJhY2sgYXBpS2V5Q2FsbGJhY2tcclxuICogQHJldHVybnMge3N0cmluZ30gLSBUaGUgYXBpS2V5IHRvIHVzZVxyXG4gKi9cclxuLyoqXHJcbiAqIFZhbGlkYXRlcyBob3N0IGFuZCBhcGlLZXkgcGFyYW1ldGVycywgdGhyb3dzIGlmIGludmFsaWRcclxuICogQHBhcmFtIGhvc3RVcmxcclxuICogQHBhcmFtIGFwaUtleVxyXG4gKi9cclxuZnVuY3Rpb24gdmFsaWRhdGVJbnN0YW50TWVpbGlTZWFyY2hQYXJhbXMoaG9zdFVybCwgYXBpS2V5KSB7XHJcbiAgICAvLyBWYWxpZGF0ZSBob3N0IHVybFxyXG4gICAgaWYgKHR5cGVvZiBob3N0VXJsICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIGhvc3RVcmwgdmFsdWUgKDFzdCBwYXJhbWV0ZXIpIGlzIG5vdCBhIHN0cmluZywgZXhwZWN0ZWQgc3RyaW5nJyk7XHJcbiAgICB9XHJcbiAgICAvLyBWYWxpZGF0ZSBhcGkga2V5XHJcbiAgICBpZiAodHlwZW9mIGFwaUtleSAhPT0gJ3N0cmluZycgJiYgdHlwZW9mIGFwaUtleSAhPT0gJ2Z1bmN0aW9uJykge1xyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIGFwaUtleSB2YWx1ZSAoMm5kIHBhcmFtZXRlcikgaXMgbm90IGEgc3RyaW5nIG9yIGEgZnVuY3Rpb24sIGV4cGVjdGVkIHN0cmluZyBvciBmdW5jdGlvbicpO1xyXG4gICAgfVxyXG59XG5cbi8qKlxyXG4gKiBUcmFuc2Zvcm0gSW5zdGFudFNlYXJjaCBmaWx0ZXIgdG8gTWVpbGlzZWFyY2ggZmlsdGVyLlxyXG4gKiBDaGFuZ2Ugc2lnbiBmcm9tIGA6YCB0byBgPWAgaW4gbmVzdGVkIGZpbHRlciBvYmplY3QuXHJcbiAqIGV4YW1wbGU6IFtgZ2VucmVzOmNvbWVkeWBdIGJlY29tZXMgW2BnZW5yZXM9Y29tZWR5YF1cclxuICpcclxuICogQHBhcmFtICB7U2VhcmNoQ29udGV4dFsnZmFjZXRGaWx0ZXJzJ119IGZpbHRlcnM/XHJcbiAqIEByZXR1cm5zIHtGaWx0ZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiB0cmFuc2Zvcm1GaWx0ZXIoZmlsdGVycykge1xyXG4gICAgaWYgKHR5cGVvZiBmaWx0ZXJzID09PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHJldHVybiByZXBsYWNlQ29sb25CeUVxdWFsU2lnbihmaWx0ZXJzKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVycykpXHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcnNcclxuICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgIGlmIChBcnJheS5pc0FycmF5KGZpbHRlcikpXHJcbiAgICAgICAgICAgICAgICByZXR1cm4gZmlsdGVyXHJcbiAgICAgICAgICAgICAgICAgICAgLm1hcChmdW5jdGlvbiAobmVzdGVkRmlsdGVyKSB7IHJldHVybiByZXBsYWNlQ29sb25CeUVxdWFsU2lnbihuZXN0ZWRGaWx0ZXIpOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgIC5maWx0ZXIoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIGVsZW07IH0pO1xyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiByZXBsYWNlQ29sb25CeUVxdWFsU2lnbihmaWx0ZXIpO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSlcclxuICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoZWxlbSkgeyByZXR1cm4gZWxlbTsgfSk7XHJcbiAgICByZXR1cm4gW107XHJcbn1cclxuLyoqXHJcbiAqIFJldHVybiB0aGUgZmlsdGVyIGluIGFuIGFycmF5IGlmIGl0IGlzIGEgc3RyaW5nXHJcbiAqIElmIGZpbHRlciBpcyBhcnJheSwgcmV0dXJuIHdpdGhvdXQgY2hhbmdlLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtGaWx0ZXJ9IGZpbHRlclxyXG4gKiBAcmV0dXJucyB7QXJyYXl9XHJcbiAqL1xyXG5mdW5jdGlvbiBmaWx0ZXJUb0FycmF5KGZpbHRlcikge1xyXG4gICAgLy8gRmlsdGVyIGlzIGEgc3RyaW5nXHJcbiAgICBpZiAoZmlsdGVyID09PSAnJylcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZmlsdGVyID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gW2ZpbHRlcl07XHJcbiAgICAvLyBGaWx0ZXIgaXMgZWl0aGVyIGFuIGFycmF5IG9mIHN0cmluZ3MsIG9yIGFuIGFycmF5IG9mIGFycmF5IG9mIHN0cmluZ3NcclxuICAgIHJldHVybiBmaWx0ZXI7XHJcbn1cclxuLyoqXHJcbiAqIE1lcmdlIGZhY2V0RmlsdGVycywgbnVtZXJpY0ZpbHRlcnMgYW5kIGZpbHRlcnMgdG9nZXRoZXIuXHJcbiAqXHJcbiAqIEBwYXJhbSAge0ZpbHRlcn0gZmFjZXRGaWx0ZXJzXHJcbiAqIEBwYXJhbSAge0ZpbHRlcn0gbnVtZXJpY0ZpbHRlcnNcclxuICogQHBhcmFtICB7c3RyaW5nfSBmaWx0ZXJzXHJcbiAqIEByZXR1cm5zIHtGaWx0ZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBtZXJnZUZpbHRlcnMoZmFjZXRGaWx0ZXJzLCBudW1lcmljRmlsdGVycywgZmlsdGVycykge1xyXG4gICAgdmFyIGFkYXB0ZWRGaWx0ZXJzID0gZmlsdGVycy50cmltKCk7XHJcbiAgICB2YXIgYWRhcHRlZEZhY2V0RmlsdGVycyA9IGZpbHRlclRvQXJyYXkoZmFjZXRGaWx0ZXJzKTtcclxuICAgIHZhciBhZGFwdGVkTnVtZXJpY0ZpbHRlcnMgPSBmaWx0ZXJUb0FycmF5KG51bWVyaWNGaWx0ZXJzKTtcclxuICAgIHZhciBhZGFwdGVkRmlsdGVyID0gX19zcHJlYWRBcnJheShfX3NwcmVhZEFycmF5KF9fc3ByZWFkQXJyYXkoW10sIGFkYXB0ZWRGYWNldEZpbHRlcnMsIHRydWUpLCBhZGFwdGVkTnVtZXJpY0ZpbHRlcnMsIHRydWUpLCBbXHJcbiAgICAgICAgYWRhcHRlZEZpbHRlcnMsXHJcbiAgICBdLCBmYWxzZSk7XHJcbiAgICB2YXIgY2xlYW5lZEZpbHRlcnMgPSBhZGFwdGVkRmlsdGVyLmZpbHRlcihmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSkge1xyXG4gICAgICAgICAgICByZXR1cm4gZmlsdGVyLmxlbmd0aDtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgIH0pO1xyXG4gICAgcmV0dXJuIGNsZWFuZWRGaWx0ZXJzO1xyXG59XHJcbi8qKlxyXG4gKiBBZGFwdCBpbnN0YW50c2VhcmNoLmpzIGZpbHRlcnMgdG8gTWVpbGlzZWFyY2ggZmlsdGVycyBieVxyXG4gKiBjb21iaW5pbmcgYW5kIHRyYW5zZm9ybWluZyBhbGwgcHJvdmlkZWQgZmlsdGVycy5cclxuICpcclxuICogQHBhcmFtICB7c3RyaW5nfHVuZGVmaW5lZH0gZmlsdGVyc1xyXG4gKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0WydudW1lcmljRmlsdGVycyddfSBudW1lcmljRmlsdGVyc1xyXG4gKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0WydmYWNldEZpbHRlcnMnXX0gZmFjZXRGaWx0ZXJzXHJcbiAqIEByZXR1cm5zIHtGaWx0ZXJ9XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGFwdEZpbHRlcnMoZmlsdGVycywgbnVtZXJpY0ZpbHRlcnMsIGZhY2V0RmlsdGVycykge1xyXG4gICAgdmFyIHRyYW5zZm9ybWVkRmlsdGVyID0gdHJhbnNmb3JtRmlsdGVyKGZhY2V0RmlsdGVycyB8fCBbXSk7XHJcbiAgICB2YXIgdHJhbnNmb3JtZWROdW1lcmljRmlsdGVyID0gdHJhbnNmb3JtRmlsdGVyKG51bWVyaWNGaWx0ZXJzIHx8IFtdKTtcclxuICAgIHJldHVybiBtZXJnZUZpbHRlcnModHJhbnNmb3JtZWRGaWx0ZXIsIHRyYW5zZm9ybWVkTnVtZXJpY0ZpbHRlciwgZmlsdGVycyB8fCAnJyk7XHJcbn1cblxuZnVuY3Rpb24gaXNQYWdpbmF0aW9uUmVxdWlyZWQoZmlsdGVyLCBxdWVyeSwgcGxhY2Vob2xkZXJTZWFyY2gpIHtcclxuICAgIC8vIFRvIGRpc2FibGUgcGFnaW5hdGlvbjpcclxuICAgIC8vIHBsYWNlaG9sZGVyU2VhcmNoIG11c3QgYmUgZGlzYWJsZWRcclxuICAgIC8vIFRoZSBzZWFyY2ggcXVlcnkgbXVzdCBiZSBlbXB0eVxyXG4gICAgLy8gVGhlcmUgbXVzdCBiZSBubyBmaWx0ZXJzXHJcbiAgICBpZiAoIXBsYWNlaG9sZGVyU2VhcmNoICYmICFxdWVyeSAmJiAoIWZpbHRlciB8fCBmaWx0ZXIubGVuZ3RoID09PSAwKSkge1xyXG4gICAgICAgIHJldHVybiBmYWxzZTtcclxuICAgIH1cclxuICAgIHJldHVybiB0cnVlO1xyXG59XHJcbmZ1bmN0aW9uIHNldFNjcm9sbFBhZ2luYXRpb24ocGFnaW5hdGlvbiwgcGFnaW5hdGlvblJlcXVpcmVkKSB7XHJcbiAgICB2YXIgcGFnZSA9IHBhZ2luYXRpb24ucGFnZSwgaGl0c1BlclBhZ2UgPSBwYWdpbmF0aW9uLmhpdHNQZXJQYWdlO1xyXG4gICAgaWYgKCFwYWdpbmF0aW9uUmVxdWlyZWQpIHtcclxuICAgICAgICByZXR1cm4ge1xyXG4gICAgICAgICAgICBsaW1pdDogMCxcclxuICAgICAgICAgICAgb2Zmc2V0OiAwXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgbGltaXQ6IGhpdHNQZXJQYWdlICsgMSxcclxuICAgICAgICBvZmZzZXQ6IHBhZ2UgKiBoaXRzUGVyUGFnZVxyXG4gICAgfTtcclxufVxyXG5mdW5jdGlvbiBzZXRGaW5pdGVQYWdpbmF0aW9uKHBhZ2luYXRpb24sIHBhZ2luYXRpb25SZXF1aXJlZCkge1xyXG4gICAgdmFyIHBhZ2UgPSBwYWdpbmF0aW9uLnBhZ2UsIGhpdHNQZXJQYWdlID0gcGFnaW5hdGlvbi5oaXRzUGVyUGFnZTtcclxuICAgIGlmICghcGFnaW5hdGlvblJlcXVpcmVkKSB7XHJcbiAgICAgICAgcmV0dXJuIHtcclxuICAgICAgICAgICAgaGl0c1BlclBhZ2U6IDAsXHJcbiAgICAgICAgICAgIHBhZ2U6IHBhZ2UgKyAxXHJcbiAgICAgICAgfTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7XHJcbiAgICAgICAgICAgIGhpdHNQZXJQYWdlOiBoaXRzUGVyUGFnZSxcclxuICAgICAgICAgICAgcGFnZTogcGFnZSArIDFcclxuICAgICAgICB9O1xyXG4gICAgfVxyXG59XHJcbi8qKlxyXG4gKiBBZGFwdHMgaW5zdGFudHNlYXJjaC5qcyBhbmQgaW5zdGFudC1tZWlsaXNlYXJjaCBvcHRpb25zXHJcbiAqIHRvIG1laWxpc2VhcmNoIHNlYXJjaCBxdWVyeSBwYXJhbWV0ZXJzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0fSBzZWFyY2hDb250ZXh0XHJcbiAqXHJcbiAqIEByZXR1cm5zIHtNZWlsaVNlYXJjaFBhcmFtc31cclxuICovXHJcbmZ1bmN0aW9uIE1laWxpUGFyYW1zQ3JlYXRvcihzZWFyY2hDb250ZXh0KSB7XHJcbiAgICB2YXIgbWVpbGlTZWFyY2hQYXJhbXMgPSB7fTtcclxuICAgIHZhciBmYWNldHMgPSBzZWFyY2hDb250ZXh0LmZhY2V0cywgYXR0cmlidXRlc1RvU25pcHBldCA9IHNlYXJjaENvbnRleHQuYXR0cmlidXRlc1RvU25pcHBldCwgc25pcHBldEVsbGlwc2lzVGV4dCA9IHNlYXJjaENvbnRleHQuc25pcHBldEVsbGlwc2lzVGV4dCwgYXR0cmlidXRlc1RvUmV0cmlldmUgPSBzZWFyY2hDb250ZXh0LmF0dHJpYnV0ZXNUb1JldHJpZXZlLCBhdHRyaWJ1dGVzVG9IaWdobGlnaHQgPSBzZWFyY2hDb250ZXh0LmF0dHJpYnV0ZXNUb0hpZ2hsaWdodCwgaGlnaGxpZ2h0UHJlVGFnID0gc2VhcmNoQ29udGV4dC5oaWdobGlnaHRQcmVUYWcsIGhpZ2hsaWdodFBvc3RUYWcgPSBzZWFyY2hDb250ZXh0LmhpZ2hsaWdodFBvc3RUYWcsIHBsYWNlaG9sZGVyU2VhcmNoID0gc2VhcmNoQ29udGV4dC5wbGFjZWhvbGRlclNlYXJjaCwgcXVlcnkgPSBzZWFyY2hDb250ZXh0LnF1ZXJ5LCBzb3J0ID0gc2VhcmNoQ29udGV4dC5zb3J0LCBwYWdpbmF0aW9uID0gc2VhcmNoQ29udGV4dC5wYWdpbmF0aW9uLCBtYXRjaGluZ1N0cmF0ZWd5ID0gc2VhcmNoQ29udGV4dC5tYXRjaGluZ1N0cmF0ZWd5LCBmaWx0ZXJzID0gc2VhcmNoQ29udGV4dC5maWx0ZXJzLCBudW1lcmljRmlsdGVycyA9IHNlYXJjaENvbnRleHQubnVtZXJpY0ZpbHRlcnMsIGZhY2V0RmlsdGVycyA9IHNlYXJjaENvbnRleHQuZmFjZXRGaWx0ZXJzO1xyXG4gICAgdmFyIG1laWxpc2VhcmNoRmlsdGVycyA9IGFkYXB0RmlsdGVycyhmaWx0ZXJzLCBudW1lcmljRmlsdGVycywgZmFjZXRGaWx0ZXJzKTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgZ2V0UGFyYW1zOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBtZWlsaVNlYXJjaFBhcmFtcztcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEZhY2V0czogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoQXJyYXkuaXNBcnJheShmYWNldHMpKSB7XHJcbiAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5mYWNldHMgPSBmYWNldHM7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSBpZiAodHlwZW9mIGZhY2V0cyA9PT0gJ3N0cmluZycpIHtcclxuICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmZhY2V0cyA9IFtmYWNldHNdO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRBdHRyaWJ1dGVzVG9Dcm9wOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChhdHRyaWJ1dGVzVG9TbmlwcGV0KSB7XHJcbiAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5hdHRyaWJ1dGVzVG9Dcm9wID0gYXR0cmlidXRlc1RvU25pcHBldDtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkQ3JvcE1hcmtlcjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAvLyBBdHRyaWJ1dGVzIFRvIENyb3AgbWFya2VyXHJcbiAgICAgICAgICAgIGlmIChzbmlwcGV0RWxsaXBzaXNUZXh0ICE9IG51bGwpIHtcclxuICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmNyb3BNYXJrZXIgPSBzbmlwcGV0RWxsaXBzaXNUZXh0O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRBdHRyaWJ1dGVzVG9SZXRyaWV2ZTogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoYXR0cmlidXRlc1RvUmV0cmlldmUpIHtcclxuICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmF0dHJpYnV0ZXNUb1JldHJpZXZlID0gYXR0cmlidXRlc1RvUmV0cmlldmU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEZpbHRlcnM6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG1laWxpc2VhcmNoRmlsdGVycy5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmZpbHRlciA9IG1laWxpc2VhcmNoRmlsdGVycztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkQXR0cmlidXRlc1RvSGlnaGxpZ2h0OiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmF0dHJpYnV0ZXNUb0hpZ2hsaWdodCA9IGF0dHJpYnV0ZXNUb0hpZ2hsaWdodCB8fCBbJyonXTtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFByZVRhZzogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICBpZiAoaGlnaGxpZ2h0UHJlVGFnKSB7XHJcbiAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQcmVUYWcgPSBoaWdobGlnaHRQcmVUYWc7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQcmVUYWcgPSAnX19haXMtaGlnaGxpZ2h0X18nO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfSxcclxuICAgICAgICBhZGRQb3N0VGFnOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIGlmIChoaWdobGlnaHRQb3N0VGFnKSB7XHJcbiAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaWdobGlnaHRQb3N0VGFnID0gaGlnaGxpZ2h0UG9zdFRhZztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICBlbHNlIHtcclxuICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmhpZ2hsaWdodFBvc3RUYWcgPSAnX18vYWlzLWhpZ2hsaWdodF9fJztcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0sXHJcbiAgICAgICAgYWRkUGFnaW5hdGlvbjogZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgcGFnaW5hdGlvblJlcXVpcmVkID0gaXNQYWdpbmF0aW9uUmVxdWlyZWQobWVpbGlzZWFyY2hGaWx0ZXJzLCBxdWVyeSwgcGxhY2Vob2xkZXJTZWFyY2gpO1xyXG4gICAgICAgICAgICBpZiAocGFnaW5hdGlvbi5maW5pdGUpIHtcclxuICAgICAgICAgICAgICAgIHZhciBfYSA9IHNldEZpbml0ZVBhZ2luYXRpb24ocGFnaW5hdGlvbiwgcGFnaW5hdGlvblJlcXVpcmVkKSwgaGl0c1BlclBhZ2UgPSBfYS5oaXRzUGVyUGFnZSwgcGFnZSA9IF9hLnBhZ2U7XHJcbiAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5oaXRzUGVyUGFnZSA9IGhpdHNQZXJQYWdlO1xyXG4gICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMucGFnZSA9IHBhZ2U7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICB2YXIgX2IgPSBzZXRTY3JvbGxQYWdpbmF0aW9uKHBhZ2luYXRpb24sIHBhZ2luYXRpb25SZXF1aXJlZCksIGxpbWl0ID0gX2IubGltaXQsIG9mZnNldCA9IF9iLm9mZnNldDtcclxuICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLmxpbWl0ID0gbGltaXQ7XHJcbiAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5vZmZzZXQgPSBvZmZzZXQ7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZFNvcnQ6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKHNvcnQgPT09IG51bGwgfHwgc29ydCA9PT0gdm9pZCAwID8gdm9pZCAwIDogc29ydC5sZW5ndGgpIHtcclxuICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLnNvcnQgPSBbc29ydF07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZEdlb1NlYXJjaFJ1bGVzOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBnZW9TZWFyY2hDb250ZXh0ID0gY3JlYXRlR2VvU2VhcmNoQ29udGV4dChzZWFyY2hDb250ZXh0KTtcclxuICAgICAgICAgICAgdmFyIGdlb1J1bGVzID0gYWRhcHRHZW9Qb2ludHNSdWxlcyhnZW9TZWFyY2hDb250ZXh0KTtcclxuICAgICAgICAgICAgaWYgKGdlb1J1bGVzID09PSBudWxsIHx8IGdlb1J1bGVzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBnZW9SdWxlcy5maWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgIGlmIChtZWlsaVNlYXJjaFBhcmFtcy5maWx0ZXIpIHtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaVNlYXJjaFBhcmFtcy5maWx0ZXIudW5zaGlmdChnZW9SdWxlcy5maWx0ZXIpO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlTZWFyY2hQYXJhbXMuZmlsdGVyID0gW2dlb1J1bGVzLmZpbHRlcl07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9LFxyXG4gICAgICAgIGFkZE1hdGNoaW5nU3RyYXRlZ3k6IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgaWYgKG1hdGNoaW5nU3RyYXRlZ3kpIHtcclxuICAgICAgICAgICAgICAgIG1laWxpU2VhcmNoUGFyYW1zLm1hdGNoaW5nU3RyYXRlZ3kgPSBtYXRjaGluZ1N0cmF0ZWd5O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogQWRhcHQgc2VhcmNoIHJlcXVlc3QgZnJvbSBpbnN0YW50c2VhcmNoLmpzXHJcbiAqIHRvIHNlYXJjaCByZXF1ZXN0IGNvbXBsaWFudCB3aXRoIE1laWxpc2VhcmNoXHJcbiAqXHJcbiAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICogQHJldHVybnMge01laWxpU2VhcmNoUGFyYW1zfVxyXG4gKi9cclxuZnVuY3Rpb24gYWRhcHRTZWFyY2hQYXJhbXMoc2VhcmNoQ29udGV4dCkge1xyXG4gICAgdmFyIG1laWxpc2VhcmNoUGFyYW1zID0gTWVpbGlQYXJhbXNDcmVhdG9yKHNlYXJjaENvbnRleHQpO1xyXG4gICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkRmFjZXRzKCk7XHJcbiAgICBtZWlsaXNlYXJjaFBhcmFtcy5hZGRBdHRyaWJ1dGVzVG9IaWdobGlnaHQoKTtcclxuICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZFByZVRhZygpO1xyXG4gICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkUG9zdFRhZygpO1xyXG4gICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkQXR0cmlidXRlc1RvUmV0cmlldmUoKTtcclxuICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZEF0dHJpYnV0ZXNUb0Nyb3AoKTtcclxuICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZENyb3BNYXJrZXIoKTtcclxuICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZFBhZ2luYXRpb24oKTtcclxuICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZEZpbHRlcnMoKTtcclxuICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZFNvcnQoKTtcclxuICAgIG1laWxpc2VhcmNoUGFyYW1zLmFkZEdlb1NlYXJjaFJ1bGVzKCk7XHJcbiAgICBtZWlsaXNlYXJjaFBhcmFtcy5hZGRNYXRjaGluZ1N0cmF0ZWd5KCk7XHJcbiAgICByZXR1cm4gbWVpbGlzZWFyY2hQYXJhbXMuZ2V0UGFyYW1zKCk7XHJcbn1cblxuLyoqXHJcbiAqIFN0cmluZ2lmeSB2YWx1ZXMgZm9sbG93aW5nIGluc3RhbnRzZWFyY2ggcHJhY3RpY2VzLlxyXG4gKlxyXG4gKiBAcGFyYW0gIHthbnl9IHZhbHVlIC0gdmFsdWUgdGhhdCBuZWVkcyB0byBiZSBzdHJpbmdpZmllZFxyXG4gKi9cclxuZnVuY3Rpb24gc3RyaW5naWZ5VmFsdWUodmFsdWUpIHtcclxuICAgIGlmICh0eXBlb2YgdmFsdWUgPT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgLy8gU3RyaW5nXHJcbiAgICAgICAgcmV0dXJuIHZhbHVlO1xyXG4gICAgfVxyXG4gICAgZWxzZSBpZiAodmFsdWUgPT09IHVuZGVmaW5lZCkge1xyXG4gICAgICAgIC8vIHVuZGVmaW5lZFxyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeShudWxsKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiBKU09OLnN0cmluZ2lmeSh2YWx1ZSk7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIFJlY3Vyc2lmIGZ1bmN0aW9uIHdyYXAgdGhlIGRlZXBlc3QgcG9zc2libGUgdmFsdWVcclxuICogdGhlIGZvbGxvd2luZyB3YXk6IHsgdmFsdWU6IFwieHhcIiB9LlxyXG4gKlxyXG4gKiBGb3IgZXhhbXBsZTpcclxuICpcclxuICoge1xyXG4gKiBcInJvb3RGaWVsZFwiOiB7IFwidmFsdWVcIjogXCJ4XCIgfVxyXG4gKiBcIm5lc3RlZEZpZWxkXCI6IHsgY2hpbGQ6IHsgdmFsdWU6IFwieVwiIH0gfVxyXG4gKiB9XHJcbiAqXHJcbiAqIHJlY3Vyc2l2aXR5IGNvbnRpbnVlcyB1bnRpbCB0aGUgdmFsdWUgaXMgbm90IGFuIGFycmF5IG9yIGFuIG9iamVjdC5cclxuICpcclxuICogQHBhcmFtICB7YW55fSB2YWx1ZSAtIHZhbHVlIG9mIGEgZmllbGRcclxuICpcclxuICogQHJldHVybnMgUmVjb3JkPHN0cmluZywgYW55PlxyXG4gKi9cclxuZnVuY3Rpb24gd3JhcFZhbHVlKHZhbHVlKSB7XHJcbiAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcclxuICAgICAgICAvLyBBcnJheVxyXG4gICAgICAgIHJldHVybiB2YWx1ZS5tYXAoZnVuY3Rpb24gKGVsZW0pIHsgcmV0dXJuIHdyYXBWYWx1ZShlbGVtKTsgfSk7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmIChpc1B1cmVPYmplY3QodmFsdWUpKSB7XHJcbiAgICAgICAgLy8gT2JqZWN0XHJcbiAgICAgICAgcmV0dXJuIE9iamVjdC5rZXlzKHZhbHVlKS5yZWR1Y2UoZnVuY3Rpb24gKG5lc3RlZCwga2V5KSB7XHJcbiAgICAgICAgICAgIG5lc3RlZFtrZXldID0gd3JhcFZhbHVlKHZhbHVlW2tleV0pO1xyXG4gICAgICAgICAgICByZXR1cm4gbmVzdGVkO1xyXG4gICAgICAgIH0sIHt9KTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIHJldHVybiB7IHZhbHVlOiBzdHJpbmdpZnlWYWx1ZSh2YWx1ZSkgfTtcclxuICAgIH1cclxufVxyXG4vKipcclxuICogQWRhcHQgTWVpbGlzZWFyY2ggZm9ybWF0dGVkIGZpZWxkcyB0byBhIGZvcm1hdCBjb21wbGlhbnQgdG8gaW5zdGFudHNlYXJjaC5qcy5cclxuICpcclxuICogQHBhcmFtICB7UmVjb3JkPHN0cmluZ30gZm9ybWF0dGVkSGl0XHJcbiAqIEBwYXJhbSAge1NlYXJjaENvbnRleHR9IHNlYXJjaENvbnRleHRcclxuICogQHJldHVybnMge1JlY29yZH1cclxuICovXHJcbmZ1bmN0aW9uIGFkYXB0Rm9ybWF0dGVkRmllbGRzKGhpdCkge1xyXG4gICAgaWYgKCFoaXQpXHJcbiAgICAgICAgcmV0dXJuIHt9O1xyXG4gICAgdmFyIF9mb3JtYXR0ZWRSZXN1bHQgPSB3cmFwVmFsdWUoaGl0KTtcclxuICAgIHZhciBoaWdobGlnaHRlZEhpdCA9IHtcclxuICAgICAgICAvLyBXZSBjb3VsZCBub3QgZGV0ZXJtaW5lIHdoYXQgdGhlIGRpZmZlcmVuY2VzIGFyZSBiZXR3ZWVuIHRob3NlIHR3byBmaWVsZHMuXHJcbiAgICAgICAgX2hpZ2hsaWdodFJlc3VsdDogX2Zvcm1hdHRlZFJlc3VsdCxcclxuICAgICAgICBfc25pcHBldFJlc3VsdDogX2Zvcm1hdHRlZFJlc3VsdFxyXG4gICAgfTtcclxuICAgIHJldHVybiBoaWdobGlnaHRlZEhpdDtcclxufVxuXG4vKipcclxuICogQHBhcmFtICB7YW55W119IGhpdHNcclxuICogQHJldHVybnMge0FycmF5PFJlY29yZDxzdHJpbmcsIGFueT4+fVxyXG4gKi9cclxuZnVuY3Rpb24gYWRhcHRHZW9SZXNwb25zZShoaXRzKSB7XHJcbiAgICB2YXIgX2E7XHJcbiAgICBmb3IgKHZhciBpID0gMDsgaSA8IGhpdHMubGVuZ3RoOyBpKyspIHtcclxuICAgICAgICB2YXIgb2JqZWN0SUQgPSBcIlwiLmNvbmNhdChpICsgTWF0aC5yYW5kb20oKSAqIDEwMDAwMDApO1xyXG4gICAgICAgIGlmIChoaXRzW2ldLl9nZW8pIHtcclxuICAgICAgICAgICAgaGl0c1tpXS5fZ2VvbG9jID0gaGl0c1tpXS5fZ2VvO1xyXG4gICAgICAgICAgICBoaXRzW2ldLm9iamVjdElEID0gb2JqZWN0SUQ7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmICgoX2EgPSBoaXRzW2ldLl9mb3JtYXR0ZWQpID09PSBudWxsIHx8IF9hID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYS5fZ2VvKSB7XHJcbiAgICAgICAgICAgIGhpdHNbaV0uX2Zvcm1hdHRlZC5fZ2VvbG9jID0gaGl0c1tpXS5fZm9ybWF0dGVkLl9nZW87XHJcbiAgICAgICAgICAgIGhpdHNbaV0uX2Zvcm1hdHRlZC5vYmplY3RJRCA9IG9iamVjdElEO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIHJldHVybiBoaXRzO1xyXG59XG5cbi8qKlxyXG4gKiBAcGFyYW0gIHtNZWlsaVNlYXJjaFJlc3BvbnNlPFJlY29yZDxzdHJpbmcsIGFueT4+fSBzZWFyY2hSZXNwb25zZVxyXG4gKiBAcGFyYW0gIHtTZWFyY2hDb250ZXh0fSBzZWFyY2hDb250ZXh0XHJcbiAqIEByZXR1cm5zIHtBcnJheTxSZWNvcmQ8c3RyaW5nLCBhbnk+Pn1cclxuICovXHJcbmZ1bmN0aW9uIGFkYXB0SGl0cyhzZWFyY2hSZXNwb25zZSwgc2VhcmNoQ29udGV4dCkge1xyXG4gICAgdmFyIHByaW1hcnlLZXkgPSBzZWFyY2hDb250ZXh0LnByaW1hcnlLZXk7XHJcbiAgICB2YXIgaGl0cyA9IHNlYXJjaFJlc3BvbnNlLmhpdHM7XHJcbiAgICB2YXIgX2EgPSBzZWFyY2hDb250ZXh0LnBhZ2luYXRpb24sIGZpbml0ZSA9IF9hLmZpbml0ZSwgaGl0c1BlclBhZ2UgPSBfYS5oaXRzUGVyUGFnZTtcclxuICAgIC8vIGlmIHRoZSBsZW5ndGggb2YgdGhlIGhpdHMgaXMgYmlnZ2VyIHRoYW4gdGhlIGhpdHNQZXJQYWdlXHJcbiAgICAvLyBJdCBtZWFucyB0aGF0IHRoZXJlIGlzIHN0aWxsIHBhZ2VzIHRvIGNvbWUgYXMgd2UgYXBwZW5kIGxpbWl0IGJ5IGhpdHNQZXJQYWdlICsgMVxyXG4gICAgLy8gSW4gd2hpY2ggY2FzZSB3ZSBzdGlsbCBuZWVkIHRvIHJlbW92ZSB0aGUgYWRkaXRpb25hbCBoaXQgcmV0dXJuZWQgYnkgTWVpbGlzZWFyY2hcclxuICAgIGlmICghZmluaXRlICYmIGhpdHMubGVuZ3RoID4gaGl0c1BlclBhZ2UpIHtcclxuICAgICAgICBoaXRzLnNwbGljZShoaXRzLmxlbmd0aCAtIDEsIDEpO1xyXG4gICAgfVxyXG4gICAgdmFyIGFkYXB0ZWRIaXRzID0gaGl0cy5tYXAoZnVuY3Rpb24gKGhpdCkge1xyXG4gICAgICAgIC8vIENyZWF0ZXMgSGl0IG9iamVjdCBjb21wbGlhbnQgd2l0aCBJbnN0YW50U2VhcmNoXHJcbiAgICAgICAgaWYgKE9iamVjdC5rZXlzKGhpdCkubGVuZ3RoID4gMCkge1xyXG4gICAgICAgICAgICB2YXIgZm9ybWF0dGVkSGl0ID0gaGl0Ll9mb3JtYXR0ZWQ7IGhpdC5fbWF0Y2hlc1Bvc2l0aW9uOyB2YXIgZG9jdW1lbnRGaWVsZHMgPSBfX3Jlc3QoaGl0LCBbXCJfZm9ybWF0dGVkXCIsIFwiX21hdGNoZXNQb3NpdGlvblwiXSk7XHJcbiAgICAgICAgICAgIHZhciBhZGFwdGVkSGl0ID0gT2JqZWN0LmFzc2lnbihkb2N1bWVudEZpZWxkcywgYWRhcHRGb3JtYXR0ZWRGaWVsZHMoZm9ybWF0dGVkSGl0KSk7XHJcbiAgICAgICAgICAgIGlmIChwcmltYXJ5S2V5KSB7XHJcbiAgICAgICAgICAgICAgICBhZGFwdGVkSGl0Lm9iamVjdElEID0gaGl0W3ByaW1hcnlLZXldO1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIHJldHVybiBhZGFwdGVkSGl0O1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gaGl0O1xyXG4gICAgfSk7XHJcbiAgICBhZGFwdGVkSGl0cyA9IGFkYXB0R2VvUmVzcG9uc2UoYWRhcHRlZEhpdHMpO1xyXG4gICAgcmV0dXJuIGFkYXB0ZWRIaXRzO1xyXG59XG5cbmZ1bmN0aW9uIGFkYXB0VG90YWxIaXRzKHNlYXJjaFJlc3BvbnNlKSB7XHJcbiAgICB2YXIgX2EgPSBzZWFyY2hSZXNwb25zZS5oaXRzUGVyUGFnZSwgaGl0c1BlclBhZ2UgPSBfYSA9PT0gdm9pZCAwID8gMCA6IF9hLCBfYiA9IHNlYXJjaFJlc3BvbnNlLnRvdGFsUGFnZXMsIHRvdGFsUGFnZXMgPSBfYiA9PT0gdm9pZCAwID8gMCA6IF9iLCBlc3RpbWF0ZWRUb3RhbEhpdHMgPSBzZWFyY2hSZXNwb25zZS5lc3RpbWF0ZWRUb3RhbEhpdHMsIHRvdGFsSGl0cyA9IHNlYXJjaFJlc3BvbnNlLnRvdGFsSGl0cztcclxuICAgIGlmIChlc3RpbWF0ZWRUb3RhbEhpdHMgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiBlc3RpbWF0ZWRUb3RhbEhpdHM7XHJcbiAgICB9XHJcbiAgICBlbHNlIGlmICh0b3RhbEhpdHMgIT0gbnVsbCkge1xyXG4gICAgICAgIHJldHVybiB0b3RhbEhpdHM7XHJcbiAgICB9XHJcbiAgICAvLyBTaG91bGQgbm90IGhhcHBlbiBidXQgc2FmZWd1YXJkaW5nIGp1c3QgaW4gY2FzZVxyXG4gICAgcmV0dXJuIGhpdHNQZXJQYWdlICogdG90YWxQYWdlcztcclxufVxuXG5mdW5jdGlvbiBhZGFwdE5iUGFnZXMoc2VhcmNoUmVzcG9uc2UsIGhpdHNQZXJQYWdlKSB7XHJcbiAgICBpZiAoc2VhcmNoUmVzcG9uc2UudG90YWxQYWdlcyAhPSBudWxsKSB7XHJcbiAgICAgICAgcmV0dXJuIHNlYXJjaFJlc3BvbnNlLnRvdGFsUGFnZXM7XHJcbiAgICB9XHJcbiAgICAvLyBBdm9pZCBkaXZpZGluZyBieSAwXHJcbiAgICBpZiAoaGl0c1BlclBhZ2UgPT09IDApIHtcclxuICAgICAgICByZXR1cm4gMDtcclxuICAgIH1cclxuICAgIHZhciBfYSA9IHNlYXJjaFJlc3BvbnNlLmxpbWl0LCBsaW1pdCA9IF9hID09PSB2b2lkIDAgPyAyMCA6IF9hLCBfYiA9IHNlYXJjaFJlc3BvbnNlLm9mZnNldCwgb2Zmc2V0ID0gX2IgPT09IHZvaWQgMCA/IDAgOiBfYiwgaGl0cyA9IHNlYXJjaFJlc3BvbnNlLmhpdHM7XHJcbiAgICB2YXIgYWRkaXRpb25hbFBhZ2UgPSBoaXRzLmxlbmd0aCA+PSBsaW1pdCA/IDEgOiAwO1xyXG4gICAgcmV0dXJuIG9mZnNldCAvIGhpdHNQZXJQYWdlICsgMSArIGFkZGl0aW9uYWxQYWdlO1xyXG59XHJcbmZ1bmN0aW9uIGFkYXB0UGFnaW5hdGlvblBhcmFtZXRlcnMoc2VhcmNoUmVzcG9uc2UsIHBhZ2luYXRpb25TdGF0ZSkge1xyXG4gICAgdmFyIGhpdHNQZXJQYWdlID0gcGFnaW5hdGlvblN0YXRlLmhpdHNQZXJQYWdlLCBwYWdlID0gcGFnaW5hdGlvblN0YXRlLnBhZ2U7XHJcbiAgICB2YXIgbmJQYWdlcyA9IGFkYXB0TmJQYWdlcyhzZWFyY2hSZXNwb25zZSwgaGl0c1BlclBhZ2UpO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBwYWdlOiBwYWdlLFxyXG4gICAgICAgIG5iUGFnZXM6IG5iUGFnZXMsXHJcbiAgICAgICAgaGl0c1BlclBhZ2U6IGhpdHNQZXJQYWdlXHJcbiAgICB9O1xyXG59XG5cbmZ1bmN0aW9uIGdldEZhY2V0TmFtZXMoZmFjZXRzKSB7XHJcbiAgICBpZiAoIWZhY2V0cylcclxuICAgICAgICByZXR1cm4gW107XHJcbiAgICBlbHNlIGlmICh0eXBlb2YgZmFjZXRzID09PSAnc3RyaW5nJylcclxuICAgICAgICByZXR1cm4gW2ZhY2V0c107XHJcbiAgICByZXR1cm4gZmFjZXRzO1xyXG59XHJcbi8vIEZpbGxzIHRoZSBtaXNzaW5nIGZhY2V0VmFsdWUgaW4gdGhlIGN1cnJlbnQgZmFjZXQgZGlzdHJpYnV0aW9uIGlmIGBrZWVwWmVyb0ZhY2V0YCBpcyB0cnVlXHJcbi8vIHVzaW5nIHRoZSBpbml0aWFsIGZhY2V0IGRpc3RyaWJ1dGlvbi4gRXg6XHJcbi8vXHJcbi8vIEluaXRpYWwgZGlzdHJpYnV0aW9uOiB7IGdlbnJlczogeyBob3Jyb3I6IDEwLCBjb21lZHk6IDQgfSB9XHJcbi8vIEN1cnJlbnQgZGlzdHJpYnV0aW9uOiB7IGdlbnJlczogeyBob3Jyb3I6IDMgfX1cclxuLy8gUmV0dXJuZWQgZGlzdHJpYnV0aW9uOiB7IGdlbnJlczogeyBob3Jyb3I6IDMsIGNvbWVkeTogMCB9fVxyXG5mdW5jdGlvbiBmaWxsTWlzc2luZ0ZhY2V0VmFsdWVzKGZhY2V0cywgaW5pdGlhbEZhY2V0RGlzdHJpYnV0aW9uLCBmYWNldERpc3RyaWJ1dGlvbikge1xyXG4gICAgdmFyIGZhY2V0TmFtZXMgPSBnZXRGYWNldE5hbWVzKGZhY2V0cyk7XHJcbiAgICB2YXIgZmlsbGVkRGlzdHJpYnV0aW9uID0ge307XHJcbiAgICBmb3IgKHZhciBfaSA9IDAsIGZhY2V0TmFtZXNfMSA9IGZhY2V0TmFtZXM7IF9pIDwgZmFjZXROYW1lc18xLmxlbmd0aDsgX2krKykge1xyXG4gICAgICAgIHZhciBmYWNldCA9IGZhY2V0TmFtZXNfMVtfaV07XHJcbiAgICAgICAgZm9yICh2YXIgZmFjZXRWYWx1ZSBpbiBpbml0aWFsRmFjZXREaXN0cmlidXRpb25bZmFjZXRdKSB7XHJcbiAgICAgICAgICAgIGlmICghZmlsbGVkRGlzdHJpYnV0aW9uW2ZhY2V0XSkge1xyXG4gICAgICAgICAgICAgICAgLy8gaW5pdGlhbGl6ZSBzdWIgb2JqZWN0XHJcbiAgICAgICAgICAgICAgICBmaWxsZWREaXN0cmlidXRpb25bZmFjZXRdID0gZmFjZXREaXN0cmlidXRpb25bZmFjZXRdIHx8IHt9O1xyXG4gICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIGlmICghZmlsbGVkRGlzdHJpYnV0aW9uW2ZhY2V0XVtmYWNldFZhbHVlXSkge1xyXG4gICAgICAgICAgICAgICAgZmlsbGVkRGlzdHJpYnV0aW9uW2ZhY2V0XVtmYWNldFZhbHVlXSA9IDA7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgICAgICBmaWxsZWREaXN0cmlidXRpb25bZmFjZXRdW2ZhY2V0VmFsdWVdID1cclxuICAgICAgICAgICAgICAgICAgICBmYWNldERpc3RyaWJ1dGlvbltmYWNldF1bZmFjZXRWYWx1ZV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICByZXR1cm4gZmlsbGVkRGlzdHJpYnV0aW9uO1xyXG59XHJcbmZ1bmN0aW9uIGFkYXB0RmFjZXREaXN0cmlidXRpb24oa2VlcFplcm9GYWNldHMsIGZhY2V0cywgaW5pdGlhbEZhY2V0RGlzdHJpYnV0aW9uLCBmYWNldERpc3RyaWJ1dGlvbikge1xyXG4gICAgaWYgKGtlZXBaZXJvRmFjZXRzKSB7XHJcbiAgICAgICAgZmFjZXREaXN0cmlidXRpb24gPSBmYWNldERpc3RyaWJ1dGlvbiB8fCB7fTtcclxuICAgICAgICByZXR1cm4gZmlsbE1pc3NpbmdGYWNldFZhbHVlcyhmYWNldHMsIGluaXRpYWxGYWNldERpc3RyaWJ1dGlvbiwgZmFjZXREaXN0cmlidXRpb24pO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGZhY2V0RGlzdHJpYnV0aW9uO1xyXG59XG5cbi8qKlxyXG4gKiBBZGFwdCBzZWFyY2ggcmVzcG9uc2UgZnJvbSBNZWlsaXNlYXJjaFxyXG4gKiB0byBzZWFyY2ggcmVzcG9uc2UgY29tcGxpYW50IHdpdGggaW5zdGFudHNlYXJjaC5qc1xyXG4gKlxyXG4gKiBAcGFyYW0gIHtNZWlsaVNlYXJjaFJlc3BvbnNlPFJlY29yZDxzdHJpbmc+Pn0gc2VhcmNoUmVzcG9uc2VcclxuICogQHBhcmFtICB7U2VhcmNoQ29udGV4dH0gc2VhcmNoQ29udGV4dFxyXG4gKiBAcmV0dXJucyB7eyByZXN1bHRzOiBBcnJheTxBbGdvbGlhU2VhcmNoUmVzcG9uc2U8VD4+IH19XHJcbiAqL1xyXG5mdW5jdGlvbiBhZGFwdFNlYXJjaFJlc3BvbnNlKHNlYXJjaFJlc3BvbnNlLCBzZWFyY2hDb250ZXh0LCBpbml0aWFsRmFjZXREaXN0cmlidXRpb24pIHtcclxuICAgIHZhciBzZWFyY2hSZXNwb25zZU9wdGlvbmFscyA9IHt9O1xyXG4gICAgdmFyIHByb2Nlc3NpbmdUaW1lTXMgPSBzZWFyY2hSZXNwb25zZS5wcm9jZXNzaW5nVGltZU1zLCBxdWVyeSA9IHNlYXJjaFJlc3BvbnNlLnF1ZXJ5LCByZXNwb25zZUZhY2V0RGlzdHJpYnV0aW9uID0gc2VhcmNoUmVzcG9uc2UuZmFjZXREaXN0cmlidXRpb247XHJcbiAgICB2YXIga2VlcFplcm9GYWNldHMgPSBzZWFyY2hDb250ZXh0LmtlZXBaZXJvRmFjZXRzLCBmYWNldHMgPSBzZWFyY2hDb250ZXh0LmZhY2V0cztcclxuICAgIHZhciBfYSA9IGFkYXB0UGFnaW5hdGlvblBhcmFtZXRlcnMoc2VhcmNoUmVzcG9uc2UsIHNlYXJjaENvbnRleHQucGFnaW5hdGlvbiksIGhpdHNQZXJQYWdlID0gX2EuaGl0c1BlclBhZ2UsIHBhZ2UgPSBfYS5wYWdlLCBuYlBhZ2VzID0gX2EubmJQYWdlcztcclxuICAgIHZhciBoaXRzID0gYWRhcHRIaXRzKHNlYXJjaFJlc3BvbnNlLCBzZWFyY2hDb250ZXh0KTtcclxuICAgIHZhciBuYkhpdHMgPSBhZGFwdFRvdGFsSGl0cyhzZWFyY2hSZXNwb25zZSk7XHJcbiAgICB2YXIgZmFjZXREaXN0cmlidXRpb24gPSBhZGFwdEZhY2V0RGlzdHJpYnV0aW9uKGtlZXBaZXJvRmFjZXRzLCBmYWNldHMsIGluaXRpYWxGYWNldERpc3RyaWJ1dGlvbiwgcmVzcG9uc2VGYWNldERpc3RyaWJ1dGlvbik7XHJcbiAgICAvLyBDcmVhdGUgcmVzcG9uc2Ugb2JqZWN0IGNvbXBsaWFudCB3aXRoIEluc3RhbnRTZWFyY2hcclxuICAgIHZhciBhZGFwdGVkU2VhcmNoUmVzcG9uc2UgPSBfX2Fzc2lnbih7IGluZGV4OiBzZWFyY2hDb250ZXh0LmluZGV4VWlkLCBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UsIHBhZ2U6IHBhZ2UsIGZhY2V0czogZmFjZXREaXN0cmlidXRpb24sIG5iUGFnZXM6IG5iUGFnZXMsIG5iSGl0czogbmJIaXRzLCBwcm9jZXNzaW5nVGltZU1TOiBwcm9jZXNzaW5nVGltZU1zLCBxdWVyeTogcXVlcnksIGhpdHM6IGhpdHMsIHBhcmFtczogJycsIGV4aGF1c3RpdmVOYkhpdHM6IGZhbHNlIH0sIHNlYXJjaFJlc3BvbnNlT3B0aW9uYWxzKTtcclxuICAgIHJldHVybiBhZGFwdGVkU2VhcmNoUmVzcG9uc2U7XHJcbn1cblxuLyoqXHJcbiAqIENyZWF0ZSB0aGUgY3VycmVudCBzdGF0ZSBvZiB0aGUgcGFnaW5hdGlvblxyXG4gKlxyXG4gKiBAcGFyYW0gIHtib29sZWFufSBbZmluaXRlXVxyXG4gKiBAcGFyYW0gIHtudW1iZXJ9IFtoaXRzUGVyUGFnZV1cclxuICogQHBhcmFtICB7bnVtYmVyfSBbcGFnZV1cclxuICogQHJldHVybnMge1NlYXJjaENvbnRleHR9XHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVQYWdpbmF0aW9uU3RhdGUoZmluaXRlLCBoaXRzUGVyUGFnZSwgcGFnZSkge1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBoaXRzUGVyUGFnZTogaGl0c1BlclBhZ2UgPT09IHVuZGVmaW5lZCA/IDIwIDogaGl0c1BlclBhZ2UsXHJcbiAgICAgICAgcGFnZTogcGFnZSB8fCAwLFxyXG4gICAgICAgIGZpbml0ZTogISFmaW5pdGVcclxuICAgIH07XHJcbn1cblxuLyoqXHJcbiAqIEBwYXJhbSAge0FsZ29saWFNdWx0aXBsZVF1ZXJpZXNRdWVyeX0gc2VhcmNoUmVxdWVzdFxyXG4gKiBAcGFyYW0gIHtDb250ZXh0fSBvcHRpb25zXHJcbiAqIEByZXR1cm5zIHtTZWFyY2hDb250ZXh0fVxyXG4gKi9cclxuZnVuY3Rpb24gY3JlYXRlU2VhcmNoQ29udGV4dChzZWFyY2hSZXF1ZXN0LCBvcHRpb25zKSB7XHJcbiAgICAvLyBTcGxpdCBpbmRleCBuYW1lIGFuZCBwb3NzaWJsZSBzb3J0aW5nIHJ1bGVzXHJcbiAgICB2YXIgX2EgPSBzZWFyY2hSZXF1ZXN0LmluZGV4TmFtZS5zcGxpdCgnOicpLCBpbmRleFVpZCA9IF9hWzBdLCBzb3J0QnlBcnJheSA9IF9hLnNsaWNlKDEpO1xyXG4gICAgdmFyIGluc3RhbnRTZWFyY2hQYXJhbXMgPSBzZWFyY2hSZXF1ZXN0LnBhcmFtcztcclxuICAgIHZhciBwYWdpbmF0aW9uU3RhdGUgPSBjcmVhdGVQYWdpbmF0aW9uU3RhdGUob3B0aW9ucy5maW5pdGVQYWdpbmF0aW9uLCBpbnN0YW50U2VhcmNoUGFyYW1zID09PSBudWxsIHx8IGluc3RhbnRTZWFyY2hQYXJhbXMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGluc3RhbnRTZWFyY2hQYXJhbXMuaGl0c1BlclBhZ2UsIGluc3RhbnRTZWFyY2hQYXJhbXMgPT09IG51bGwgfHwgaW5zdGFudFNlYXJjaFBhcmFtcyA9PT0gdm9pZCAwID8gdm9pZCAwIDogaW5zdGFudFNlYXJjaFBhcmFtcy5wYWdlKTtcclxuICAgIHZhciBzZWFyY2hDb250ZXh0ID0gX19hc3NpZ24oX19hc3NpZ24oX19hc3NpZ24oe30sIG9wdGlvbnMpLCBpbnN0YW50U2VhcmNoUGFyYW1zKSwgeyBzb3J0OiBzb3J0QnlBcnJheS5qb2luKCc6JykgfHwgJycsIGluZGV4VWlkOiBpbmRleFVpZCwgcGFnaW5hdGlvbjogcGFnaW5hdGlvblN0YXRlLCBwbGFjZWhvbGRlclNlYXJjaDogb3B0aW9ucy5wbGFjZWhvbGRlclNlYXJjaCAhPT0gZmFsc2UsIGtlZXBaZXJvRmFjZXRzOiAhIW9wdGlvbnMua2VlcFplcm9GYWNldHMgfSk7XHJcbiAgICByZXR1cm4gc2VhcmNoQ29udGV4dDtcclxufVxuXG4vKipcclxuICogQHBhcmFtICB7UmVjb3JkPHN0cmluZ30gY2FjaGVcclxuICogQHJldHVybnMge1NlYXJjaENhY2hlfVxyXG4gKi9cclxuZnVuY3Rpb24gU2VhcmNoQ2FjaGUoY2FjaGUpIHtcclxuICAgIGlmIChjYWNoZSA9PT0gdm9pZCAwKSB7IGNhY2hlID0ge307IH1cclxuICAgIHZhciBzZWFyY2hDYWNoZSA9IGNhY2hlO1xyXG4gICAgcmV0dXJuIHtcclxuICAgICAgICBnZXRFbnRyeTogZnVuY3Rpb24gKGtleSkge1xyXG4gICAgICAgICAgICBpZiAoc2VhcmNoQ2FjaGVba2V5XSkge1xyXG4gICAgICAgICAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gSlNPTi5wYXJzZShzZWFyY2hDYWNoZVtrZXldKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgIGNhdGNoIChfKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIHNlYXJjaENhY2hlW2tleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgcmV0dXJuIHVuZGVmaW5lZDtcclxuICAgICAgICB9LFxyXG4gICAgICAgIGZvcm1hdEtleTogZnVuY3Rpb24gKGNvbXBvbmVudHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIHN0cmluZ2lmeUFycmF5KGNvbXBvbmVudHMpO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2V0RW50cnk6IGZ1bmN0aW9uIChrZXksIHNlYXJjaFJlc3BvbnNlKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaENhY2hlW2tleV0gPSBKU09OLnN0cmluZ2lmeShzZWFyY2hSZXNwb25zZSk7XHJcbiAgICAgICAgfSxcclxuICAgICAgICBjbGVhckNhY2hlOiBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHNlYXJjaENhY2hlID0ge307XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxuXG5mdW5jdGlvbiBnZXRJbmRleEZhY2V0RGlzdHJpYnV0aW9uKHNlYXJjaFJlc29sdmVyLCBzZWFyY2hDb250ZXh0KSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIGRlZmF1bHRTZWFyY2hDb250ZXh0LCBtZWlsaXNlYXJjaFBhcmFtcywgc2VhcmNoUmVzcG9uc2U7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgZGVmYXVsdFNlYXJjaENvbnRleHQgPSBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgc2VhcmNoQ29udGV4dCksIHsgXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIC8vIHBsYWNlaG9sZGVyc2VhcmNoIHRydWUgdG8gZW5zdXJlIGEgcmVxdWVzdCBpcyBtYWRlXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBsYWNlaG9sZGVyU2VhcmNoOiB0cnVlLCBcclxuICAgICAgICAgICAgICAgICAgICAgICAgLy8gcXVlcnkgc2V0IHRvIGVtcHR5IHRvIGVuc3VyZSByZXRyaWV2aW5nIHRoZSBkZWZhdWx0IGZhY2V0ZGlzdHJpYnV0aW9uXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5OiAnJyB9KTtcclxuICAgICAgICAgICAgICAgICAgICBtZWlsaXNlYXJjaFBhcmFtcyA9IE1laWxpUGFyYW1zQ3JlYXRvcihkZWZhdWx0U2VhcmNoQ29udGV4dCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkRmFjZXRzKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgbWVpbGlzZWFyY2hQYXJhbXMuYWRkUGFnaW5hdGlvbigpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHNlYXJjaFJlc29sdmVyLnNlYXJjaFJlc3BvbnNlKGRlZmF1bHRTZWFyY2hDb250ZXh0LCBtZWlsaXNlYXJjaFBhcmFtcy5nZXRQYXJhbXMoKSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlc3BvbnNlID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBzZWFyY2hSZXNwb25zZS5mYWNldERpc3RyaWJ1dGlvbiB8fCB7fV07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XHJcbmZ1bmN0aW9uIGluaXRGYWNldERpc3RyaWJ1dGlvbihzZWFyY2hSZXNvbHZlciwgc2VhcmNoQ29udGV4dCwgaW5pdGlhbEZhY2V0RGlzdHJpYnV0aW9uKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYjtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISFpbml0aWFsRmFjZXREaXN0cmlidXRpb25bc2VhcmNoQ29udGV4dC5pbmRleFVpZF0pIHJldHVybiBbMyAvKmJyZWFrKi8sIDJdO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hID0gaW5pdGlhbEZhY2V0RGlzdHJpYnV0aW9uO1xyXG4gICAgICAgICAgICAgICAgICAgIF9iID0gc2VhcmNoQ29udGV4dC5pbmRleFVpZDtcclxuICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBnZXRJbmRleEZhY2V0RGlzdHJpYnV0aW9uKHNlYXJjaFJlc29sdmVyLCBzZWFyY2hDb250ZXh0KV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgX2FbX2JdID1cclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Muc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMjtcclxuICAgICAgICAgICAgICAgIGNhc2UgMjogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGluaXRpYWxGYWNldERpc3RyaWJ1dGlvbl07XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICB9KTtcclxuICAgIH0pO1xyXG59XG5cbnZhciBQQUNLQUdFX1ZFUlNJT04gPSAnMC4xMS4wJztcblxudmFyIGNvbnN0cnVjdENsaWVudEFnZW50cyA9IGZ1bmN0aW9uIChjbGllbnRBZ2VudHMpIHtcclxuICAgIGlmIChjbGllbnRBZ2VudHMgPT09IHZvaWQgMCkgeyBjbGllbnRBZ2VudHMgPSBbXTsgfVxyXG4gICAgdmFyIGluc3RhbnRNZWlsaXNlYXJjaEFnZW50ID0gXCJNZWlsaXNlYXJjaCBpbnN0YW50LW1laWxpc2VhcmNoICh2XCIuY29uY2F0KFBBQ0tBR0VfVkVSU0lPTiwgXCIpXCIpO1xyXG4gICAgcmV0dXJuIGNsaWVudEFnZW50cy5jb25jYXQoaW5zdGFudE1laWxpc2VhcmNoQWdlbnQpO1xyXG59O1xuXG4vKipcclxuICogYXBpS2V5IGNhbGxiYWNrIGRlZmluaXRpb25cclxuICogQGNhbGxiYWNrIGFwaUtleUNhbGxiYWNrXHJcbiAqIEByZXR1cm5zIHtzdHJpbmd9IC0gVGhlIGFwaUtleSB0byB1c2VcclxuICovXHJcbi8qKlxyXG4gKiBJbnN0YW50aWF0ZSBTZWFyY2hDbGllbnQgcmVxdWlyZWQgYnkgaW5zdGFudHNlYXJjaC5qcy5cclxuICogQHBhcmFtICB7c3RyaW5nfSBob3N0VXJsXHJcbiAqIEBwYXJhbSAge3N0cmluZyB8IGFwaUtleUNhbGxiYWNrfSBhcGlLZXlcclxuICogQHBhcmFtICB7SW5zdGFudE1laWxpU2VhcmNoT3B0aW9ucz17fX0gbWVpbGlTZWFyY2hPcHRpb25zXHJcbiAqIEByZXR1cm5zIHtJbnN0YW50TWVpbGlTZWFyY2hJbnN0YW5jZX1cclxuICovXHJcbmZ1bmN0aW9uIGluc3RhbnRNZWlsaVNlYXJjaChob3N0VXJsLCBhcGlLZXksIGluc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnMpIHtcclxuICAgIGlmIChhcGlLZXkgPT09IHZvaWQgMCkgeyBhcGlLZXkgPSAnJzsgfVxyXG4gICAgaWYgKGluc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnMgPT09IHZvaWQgMCkgeyBpbnN0YW50TWVpbGlTZWFyY2hPcHRpb25zID0ge307IH1cclxuICAgIC8vIFZhbGlkYXRlIHBhcmFtZXRlcnNcclxuICAgIHZhbGlkYXRlSW5zdGFudE1laWxpU2VhcmNoUGFyYW1zKGhvc3RVcmwsIGFwaUtleSk7XHJcbiAgICAvLyBSZXNvbHZlIHBvc3NpYmxlIGZ1bmN0aW9uIHRvIGdldCBhcGlLZXlcclxuICAgIGFwaUtleSA9IGdldEFwaUtleShhcGlLZXkpO1xyXG4gICAgdmFyIGNsaWVudEFnZW50cyA9IGNvbnN0cnVjdENsaWVudEFnZW50cyhpbnN0YW50TWVpbGlTZWFyY2hPcHRpb25zLmNsaWVudEFnZW50cyk7XHJcbiAgICB2YXIgbWVpbGlzZWFyY2hDbGllbnQgPSBuZXcgTWVpbGlTZWFyY2goe1xyXG4gICAgICAgIGhvc3Q6IGhvc3RVcmwsXHJcbiAgICAgICAgYXBpS2V5OiBhcGlLZXksXHJcbiAgICAgICAgY2xpZW50QWdlbnRzOiBjbGllbnRBZ2VudHNcclxuICAgIH0pO1xyXG4gICAgdmFyIHNlYXJjaENhY2hlID0gU2VhcmNoQ2FjaGUoKTtcclxuICAgIC8vIGNyZWF0ZSBzZWFyY2ggcmVzb2x2ZXIgd2l0aCBpbmNsdWRlZCBjYWNoZVxyXG4gICAgdmFyIHNlYXJjaFJlc29sdmVyID0gU2VhcmNoUmVzb2x2ZXIobWVpbGlzZWFyY2hDbGllbnQsIHNlYXJjaENhY2hlKTtcclxuICAgIHZhciBpbml0aWFsRmFjZXREaXN0cmlidXRpb24gPSB7fTtcclxuICAgIHJldHVybiB7XHJcbiAgICAgICAgY2xlYXJDYWNoZTogZnVuY3Rpb24gKCkgeyByZXR1cm4gc2VhcmNoQ2FjaGUuY2xlYXJDYWNoZSgpOyB9LFxyXG4gICAgICAgIC8qKlxyXG4gICAgICAgICAqIEBwYXJhbSAge3JlYWRvbmx5QWxnb2xpYU11bHRpcGxlUXVlcmllc1F1ZXJ5W119IGluc3RhbnRTZWFyY2hSZXF1ZXN0c1xyXG4gICAgICAgICAqIEByZXR1cm5zIHtBcnJheX1cclxuICAgICAgICAgKi9cclxuICAgICAgICBzZWFyY2g6IGZ1bmN0aW9uIChpbnN0YW50U2VhcmNoUmVxdWVzdHMpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgdmFyIHNlYXJjaFJlc3BvbnNlcywgcmVxdWVzdHMsIF9pLCByZXF1ZXN0c18xLCBzZWFyY2hSZXF1ZXN0LCBzZWFyY2hDb250ZXh0LCBhZGFwdGVkU2VhcmNoUmVxdWVzdCwgc2VhcmNoUmVzcG9uc2UsIGFkYXB0ZWRTZWFyY2hSZXNwb25zZSwgZV8xO1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2EudHJ5cy5wdXNoKFswLCA2LCAsIDddKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlc3BvbnNlcyA9IHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXN1bHRzOiBbXVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlcXVlc3RzID0gaW5zdGFudFNlYXJjaFJlcXVlc3RzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2kgPSAwLCByZXF1ZXN0c18xID0gcmVxdWVzdHM7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBfYS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKF9pIDwgcmVxdWVzdHNfMS5sZW5ndGgpKSByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlcXVlc3QgPSByZXF1ZXN0c18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaENvbnRleHQgPSBjcmVhdGVTZWFyY2hDb250ZXh0KHNlYXJjaFJlcXVlc3QsIGluc3RhbnRNZWlsaVNlYXJjaE9wdGlvbnMpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYWRhcHRlZFNlYXJjaFJlcXVlc3QgPSBhZGFwdFNlYXJjaFBhcmFtcyhzZWFyY2hDb250ZXh0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIGluaXRGYWNldERpc3RyaWJ1dGlvbihzZWFyY2hSZXNvbHZlciwgc2VhcmNoQ29udGV4dCwgaW5pdGlhbEZhY2V0RGlzdHJpYnV0aW9uKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC8vIFNlYXJjaCByZXNwb25zZSBmcm9tIE1laWxpc2VhcmNoXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbml0aWFsRmFjZXREaXN0cmlidXRpb24gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBzZWFyY2hSZXNvbHZlci5zZWFyY2hSZXNwb25zZShzZWFyY2hDb250ZXh0LCBhZGFwdGVkU2VhcmNoUmVxdWVzdClcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAvLyBBZGFwdCB0aGUgTWVpbGlzZWFyY2ggcmVzcG9uc2UgdG8gYSBjb21wbGlhbnQgaW5zdGFudHNlYXJjaC5qcyByZXNwb25zZVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgc2VhcmNoUmVzcG9uc2UgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBhZGFwdGVkU2VhcmNoUmVzcG9uc2UgPSBhZGFwdFNlYXJjaFJlc3BvbnNlKHNlYXJjaFJlc3BvbnNlLCBzZWFyY2hDb250ZXh0LCBpbml0aWFsRmFjZXREaXN0cmlidXRpb25bc2VhcmNoUmVxdWVzdC5pbmRleE5hbWVdKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHNlYXJjaFJlc3BvbnNlcy5yZXN1bHRzLnB1c2goYWRhcHRlZFNlYXJjaFJlc3BvbnNlKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gNDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA0OlxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovLCBzZWFyY2hSZXNwb25zZXNdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBjYXNlIDY6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBjb25zb2xlLmVycm9yKGVfMSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgRXJyb3IoZV8xKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSA3OiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0sXHJcbiAgICAgICAgc2VhcmNoRm9yRmFjZXRWYWx1ZXM6IGZ1bmN0aW9uIChfKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgbmV3IFByb21pc2UoZnVuY3Rpb24gKHJlc29sdmUsIHJlamVjdCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdChuZXcgRXJyb3IoJ1NlYXJjaEZvckZhY2V0VmFsdWVzIGlzIG5vdCBjb21wYXRpYmxlIHdpdGggTWVpbGlzZWFyY2gnKSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZShbXSk7IC8vIGFkZGVkIGhlcmUgdG8gYXZvaWQgY29tcGlsYXRpb24gZXJyb3JcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICB9KTtcclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfVxyXG4gICAgfTtcclxufVxyXG4vKipcclxuICogUmVzb2x2ZXMgYXBpS2V5IGlmIGl0IGlzIGEgZnVuY3Rpb25cclxuICogQHBhcmFtICB7c3RyaW5nIHwgYXBpS2V5Q2FsbGJhY2t9IGFwaUtleVxyXG4gKiBAcmV0dXJucyB7c3RyaW5nfSBhcGkga2V5IHZhbHVlXHJcbiAqL1xyXG5mdW5jdGlvbiBnZXRBcGlLZXkoYXBpS2V5KSB7XHJcbiAgICAvLyBJZiBhcGlLZXkgaXMgZnVuY3Rpb24sIGNhbGwgaXQgdG8gZ2V0IHRoZSBhcGlLZXlcclxuICAgIGlmICh0eXBlb2YgYXBpS2V5ID09PSAnZnVuY3Rpb24nKSB7XHJcbiAgICAgICAgdmFyIGFwaUtleUZuVmFsdWUgPSBhcGlLZXkoKTtcclxuICAgICAgICBpZiAodHlwZW9mIGFwaUtleUZuVmFsdWUgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoJ1Byb3ZpZGVkIGFwaUtleSBmdW5jdGlvbiAoMm5kIHBhcmFtZXRlcikgZGlkIG5vdCByZXR1cm4gYSBzdHJpbmcsIGV4cGVjdGVkIHN0cmluZycpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gYXBpS2V5Rm5WYWx1ZTtcclxuICAgIH1cclxuICAgIHJldHVybiBhcGlLZXk7XHJcbn1cblxudmFyIE1hdGNoaW5nU3RyYXRlZ2llcztcclxuKGZ1bmN0aW9uIChNYXRjaGluZ1N0cmF0ZWdpZXMpIHtcclxuICAgIE1hdGNoaW5nU3RyYXRlZ2llc1tcIkFMTFwiXSA9IFwiYWxsXCI7XHJcbiAgICBNYXRjaGluZ1N0cmF0ZWdpZXNbXCJMQVNUXCJdID0gXCJsYXN0XCI7XHJcbn0pKE1hdGNoaW5nU3RyYXRlZ2llcyB8fCAoTWF0Y2hpbmdTdHJhdGVnaWVzID0ge30pKTtcblxuZXhwb3J0IHsgTWF0Y2hpbmdTdHJhdGVnaWVzLCBpbnN0YW50TWVpbGlTZWFyY2ggfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@meilisearch/instant-meilisearch/dist/instant-meilisearch.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@meilisearch/instant-meilisearch/node_modules/meilisearch/dist/bundles/meilisearch.esm.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@meilisearch/instant-meilisearch/node_modules/meilisearch/dist/bundles/meilisearch.esm.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   EnqueuedTask: () => (/* binding */ EnqueuedTask),\n/* harmony export */   Index: () => (/* binding */ Index),\n/* harmony export */   MatchingStrategies: () => (/* binding */ MatchingStrategies),\n/* harmony export */   MeiliSearch: () => (/* binding */ MeiliSearch),\n/* harmony export */   MeiliSearchApiError: () => (/* binding */ MeiliSearchApiError),\n/* harmony export */   MeiliSearchCommunicationError: () => (/* binding */ MeiliSearchCommunicationError),\n/* harmony export */   MeiliSearchError: () => (/* binding */ MeiliSearchError),\n/* harmony export */   MeiliSearchTimeOutError: () => (/* binding */ MeiliSearchTimeOutError),\n/* harmony export */   Task: () => (/* binding */ Task),\n/* harmony export */   TaskClient: () => (/* binding */ TaskClient),\n/* harmony export */   \"default\": () => (/* binding */ MeiliSearch),\n/* harmony export */   httpErrorHandler: () => (/* binding */ httpErrorHandler),\n/* harmony export */   httpResponseErrorHandler: () => (/* binding */ httpResponseErrorHandler)\n/* harmony export */ });\n/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! cross-fetch/polyfill */ \"(ssr)/./node_modules/cross-fetch/dist/node-polyfill.js\");\n/* harmony import */ var cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(cross_fetch_polyfill__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! crypto */ \"crypto\");\n/* harmony import */ var crypto__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(crypto__WEBPACK_IMPORTED_MODULE_1__);\n\n\n\n// Type definitions for meilisearch\r\n// Project: https://github.com/meilisearch/meilisearch-js\r\n// Definitions by: qdequele <quentin@meilisearch.com> <https://github.com/meilisearch>\r\n// Definitions: https://github.com/meilisearch/meilisearch-js\r\n// TypeScript Version: ^3.8.3\r\n/*\r\n * SEARCH PARAMETERS\r\n */\r\nvar MatchingStrategies = {\r\n    ALL: 'all',\r\n    LAST: 'last'\r\n};\n\n/******************************************************************************\r\nCopyright (c) Microsoft Corporation.\r\n\r\nPermission to use, copy, modify, and/or distribute this software for any\r\npurpose with or without fee is hereby granted.\r\n\r\nTHE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES WITH\r\nREGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF MERCHANTABILITY\r\nAND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR ANY SPECIAL, DIRECT,\r\nINDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES WHATSOEVER RESULTING FROM\r\nLOSS OF USE, DATA OR PROFITS, WHETHER IN AN ACTION OF CONTRACT, NEGLIGENCE OR\r\nOTHER TORTIOUS ACTION, ARISING OUT OF OR IN CONNECTION WITH THE USE OR\r\nPERFORMANCE OF THIS SOFTWARE.\r\n***************************************************************************** */\r\n/* global Reflect, Promise */\r\n\r\nvar extendStatics = function(d, b) {\r\n    extendStatics = Object.setPrototypeOf ||\r\n        ({ __proto__: [] } instanceof Array && function (d, b) { d.__proto__ = b; }) ||\r\n        function (d, b) { for (var p in b) if (Object.prototype.hasOwnProperty.call(b, p)) d[p] = b[p]; };\r\n    return extendStatics(d, b);\r\n};\r\n\r\nfunction __extends(d, b) {\r\n    if (typeof b !== \"function\" && b !== null)\r\n        throw new TypeError(\"Class extends value \" + String(b) + \" is not a constructor or null\");\r\n    extendStatics(d, b);\r\n    function __() { this.constructor = d; }\r\n    d.prototype = b === null ? Object.create(b) : (__.prototype = b.prototype, new __());\r\n}\r\n\r\nvar __assign = function() {\r\n    __assign = Object.assign || function __assign(t) {\r\n        for (var s, i = 1, n = arguments.length; i < n; i++) {\r\n            s = arguments[i];\r\n            for (var p in s) if (Object.prototype.hasOwnProperty.call(s, p)) t[p] = s[p];\r\n        }\r\n        return t;\r\n    };\r\n    return __assign.apply(this, arguments);\r\n};\r\n\r\nfunction __awaiter(thisArg, _arguments, P, generator) {\r\n    function adopt(value) { return value instanceof P ? value : new P(function (resolve) { resolve(value); }); }\r\n    return new (P || (P = Promise))(function (resolve, reject) {\r\n        function fulfilled(value) { try { step(generator.next(value)); } catch (e) { reject(e); } }\r\n        function rejected(value) { try { step(generator[\"throw\"](value)); } catch (e) { reject(e); } }\r\n        function step(result) { result.done ? resolve(result.value) : adopt(result.value).then(fulfilled, rejected); }\r\n        step((generator = generator.apply(thisArg, _arguments || [])).next());\r\n    });\r\n}\r\n\r\nfunction __generator(thisArg, body) {\r\n    var _ = { label: 0, sent: function() { if (t[0] & 1) throw t[1]; return t[1]; }, trys: [], ops: [] }, f, y, t, g;\r\n    return g = { next: verb(0), \"throw\": verb(1), \"return\": verb(2) }, typeof Symbol === \"function\" && (g[Symbol.iterator] = function() { return this; }), g;\r\n    function verb(n) { return function (v) { return step([n, v]); }; }\r\n    function step(op) {\r\n        if (f) throw new TypeError(\"Generator is already executing.\");\r\n        while (_) try {\r\n            if (f = 1, y && (t = op[0] & 2 ? y[\"return\"] : op[0] ? y[\"throw\"] || ((t = y[\"return\"]) && t.call(y), 0) : y.next) && !(t = t.call(y, op[1])).done) return t;\r\n            if (y = 0, t) op = [op[0] & 2, t.value];\r\n            switch (op[0]) {\r\n                case 0: case 1: t = op; break;\r\n                case 4: _.label++; return { value: op[1], done: false };\r\n                case 5: _.label++; y = op[1]; op = [0]; continue;\r\n                case 7: op = _.ops.pop(); _.trys.pop(); continue;\r\n                default:\r\n                    if (!(t = _.trys, t = t.length > 0 && t[t.length - 1]) && (op[0] === 6 || op[0] === 2)) { _ = 0; continue; }\r\n                    if (op[0] === 3 && (!t || (op[1] > t[0] && op[1] < t[3]))) { _.label = op[1]; break; }\r\n                    if (op[0] === 6 && _.label < t[1]) { _.label = t[1]; t = op; break; }\r\n                    if (t && _.label < t[2]) { _.label = t[2]; _.ops.push(op); break; }\r\n                    if (t[2]) _.ops.pop();\r\n                    _.trys.pop(); continue;\r\n            }\r\n            op = body.call(thisArg, _);\r\n        } catch (e) { op = [6, e]; y = 0; } finally { f = t = 0; }\r\n        if (op[0] & 5) throw op[1]; return { value: op[0] ? op[1] : void 0, done: true };\r\n    }\r\n}\n\nvar MeiliSearchCommunicationError = /** @class */ (function (_super) {\r\n    __extends(MeiliSearchCommunicationError, _super);\r\n    function MeiliSearchCommunicationError(message, body, url, stack) {\r\n        var _this = this;\r\n        var _a, _b, _c;\r\n        _this = _super.call(this, message) || this;\r\n        // Make errors comparison possible. ex: error instanceof MeiliSearchCommunicationError.\r\n        Object.setPrototypeOf(_this, MeiliSearchCommunicationError.prototype);\r\n        _this.name = 'MeiliSearchCommunicationError';\r\n        if (body instanceof Response) {\r\n            _this.message = body.statusText;\r\n            _this.statusCode = body.status;\r\n        }\r\n        if (body instanceof Error) {\r\n            _this.errno = body.errno;\r\n            _this.code = body.code;\r\n        }\r\n        if (stack) {\r\n            _this.stack = stack;\r\n            _this.stack = (_a = _this.stack) === null || _a === void 0 ? void 0 : _a.replace(/(TypeError|FetchError)/, _this.name);\r\n            _this.stack = (_b = _this.stack) === null || _b === void 0 ? void 0 : _b.replace('Failed to fetch', \"request to \".concat(url, \" failed, reason: connect ECONNREFUSED\"));\r\n            _this.stack = (_c = _this.stack) === null || _c === void 0 ? void 0 : _c.replace('Not Found', \"Not Found: \".concat(url));\r\n        }\r\n        else {\r\n            if (Error.captureStackTrace) {\r\n                Error.captureStackTrace(_this, MeiliSearchCommunicationError);\r\n            }\r\n        }\r\n        return _this;\r\n    }\r\n    return MeiliSearchCommunicationError;\r\n}(Error));\n\nvar MeiliSearchApiError = /** @class */ (function (_super) {\r\n    __extends(class_1, _super);\r\n    function class_1(error, status) {\r\n        var _this = _super.call(this, error.message) || this;\r\n        // Make errors comparison possible. ex: error instanceof MeiliSearchApiError.\r\n        Object.setPrototypeOf(_this, MeiliSearchApiError.prototype);\r\n        _this.name = 'MeiliSearchApiError';\r\n        _this.code = error.code;\r\n        _this.type = error.type;\r\n        _this.link = error.link;\r\n        _this.message = error.message;\r\n        _this.httpStatus = status;\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(_this, MeiliSearchApiError);\r\n        }\r\n        return _this;\r\n    }\r\n    return class_1;\r\n}(Error));\n\nfunction httpResponseErrorHandler(response) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        var responseBody;\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0:\r\n                    if (!!response.ok) return [3 /*break*/, 5];\r\n                    responseBody = void 0;\r\n                    _a.label = 1;\r\n                case 1:\r\n                    _a.trys.push([1, 3, , 4]);\r\n                    return [4 /*yield*/, response.json()];\r\n                case 2:\r\n                    // If it is not possible to parse the return body it means there is none\r\n                    // In which case it is a communication error with the Meilisearch instance\r\n                    responseBody = _a.sent();\r\n                    return [3 /*break*/, 4];\r\n                case 3:\r\n                    _a.sent();\r\n                    // Not sure on how to test this part of the code.\r\n                    throw new MeiliSearchCommunicationError(response.statusText, response, response.url);\r\n                case 4: \r\n                // If the body is parsable, then it means Meilisearch returned a body with\r\n                // information on the error.\r\n                throw new MeiliSearchApiError(responseBody, response.status);\r\n                case 5: return [2 /*return*/, response];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction httpErrorHandler(response, stack, url) {\r\n    if (response.name !== 'MeiliSearchApiError') {\r\n        throw new MeiliSearchCommunicationError(response.message, response, url, stack);\r\n    }\r\n    throw response;\r\n}\n\nvar MeiliSearchError = /** @class */ (function (_super) {\r\n    __extends(MeiliSearchError, _super);\r\n    function MeiliSearchError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        // Make errors comparison possible. ex: error instanceof MeiliSearchError.\r\n        Object.setPrototypeOf(_this, MeiliSearchError.prototype);\r\n        _this.name = 'MeiliSearchError';\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(_this, MeiliSearchError);\r\n        }\r\n        return _this;\r\n    }\r\n    return MeiliSearchError;\r\n}(Error));\n\nvar MeiliSearchTimeOutError = /** @class */ (function (_super) {\r\n    __extends(MeiliSearchTimeOutError, _super);\r\n    function MeiliSearchTimeOutError(message) {\r\n        var _this = _super.call(this, message) || this;\r\n        // Make errors comparison possible. ex: error instanceof MeiliSearchTimeOutError.\r\n        Object.setPrototypeOf(_this, MeiliSearchTimeOutError.prototype);\r\n        _this.name = 'MeiliSearchTimeOutError';\r\n        if (Error.captureStackTrace) {\r\n            Error.captureStackTrace(_this, MeiliSearchTimeOutError);\r\n        }\r\n        return _this;\r\n    }\r\n    return MeiliSearchTimeOutError;\r\n}(Error));\n\n/** Removes undefined entries from object */\r\nfunction removeUndefinedFromObject(obj) {\r\n    return Object.entries(obj).reduce(function (acc, curEntry) {\r\n        var key = curEntry[0], val = curEntry[1];\r\n        if (val !== undefined)\r\n            acc[key] = val;\r\n        return acc;\r\n    }, {});\r\n}\r\nfunction sleep(ms) {\r\n    return __awaiter(this, void 0, void 0, function () {\r\n        return __generator(this, function (_a) {\r\n            switch (_a.label) {\r\n                case 0: return [4 /*yield*/, new Promise(function (resolve) { return setTimeout(resolve, ms); })];\r\n                case 1: return [2 /*return*/, _a.sent()];\r\n            }\r\n        });\r\n    });\r\n}\r\nfunction addProtocolIfNotPresent(host) {\r\n    if (!(host.startsWith('https://') || host.startsWith('http://'))) {\r\n        return \"http://\".concat(host);\r\n    }\r\n    return host;\r\n}\r\nfunction addTrailingSlash(url) {\r\n    if (!url.endsWith('/')) {\r\n        url += '/';\r\n    }\r\n    return url;\r\n}\r\nfunction validateUuid4(uuid) {\r\n    var regexExp = /^[0-9a-fA-F]{8}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{4}\\b-[0-9a-fA-F]{12}$/gi;\r\n    return regexExp.test(uuid);\r\n}\n\nvar PACKAGE_VERSION = '0.31.1';\n\nfunction toQueryParams(parameters) {\r\n    var params = Object.keys(parameters);\r\n    var queryParams = params.reduce(function (acc, key) {\r\n        var _a, _b, _c;\r\n        var value = parameters[key];\r\n        if (value === undefined) {\r\n            return acc;\r\n        }\r\n        else if (Array.isArray(value)) {\r\n            return __assign(__assign({}, acc), (_a = {}, _a[key] = value.join(','), _a));\r\n        }\r\n        else if (value instanceof Date) {\r\n            return __assign(__assign({}, acc), (_b = {}, _b[key] = value.toISOString(), _b));\r\n        }\r\n        return __assign(__assign({}, acc), (_c = {}, _c[key] = value, _c));\r\n    }, {});\r\n    return queryParams;\r\n}\r\nfunction constructHostURL(host) {\r\n    try {\r\n        host = addProtocolIfNotPresent(host);\r\n        host = addTrailingSlash(host);\r\n        return host;\r\n    }\r\n    catch (e) {\r\n        throw new MeiliSearchError('The provided host is not valid.');\r\n    }\r\n}\r\nfunction createHeaders(config) {\r\n    var agentHeader = 'X-Meilisearch-Client';\r\n    var packageAgent = \"Meilisearch JavaScript (v\".concat(PACKAGE_VERSION, \")\");\r\n    var contentType = 'Content-Type';\r\n    config.headers = config.headers || {};\r\n    var headers = Object.assign({}, config.headers); // Create a hard copy and not a reference to config.headers\r\n    if (config.apiKey) {\r\n        headers['Authorization'] = \"Bearer \".concat(config.apiKey);\r\n    }\r\n    if (!config.headers[contentType]) {\r\n        headers['Content-Type'] = 'application/json';\r\n    }\r\n    // Creates the custom user agent with information on the package used.\r\n    if (config.clientAgents && Array.isArray(config.clientAgents)) {\r\n        var clients = config.clientAgents.concat(packageAgent);\r\n        headers[agentHeader] = clients.join(' ; ');\r\n    }\r\n    else if (config.clientAgents && !Array.isArray(config.clientAgents)) {\r\n        // If the header is defined but not an array\r\n        throw new MeiliSearchError(\"Meilisearch: The header \\\"\".concat(agentHeader, \"\\\" should be an array of string(s).\\n\"));\r\n    }\r\n    else {\r\n        headers[agentHeader] = packageAgent;\r\n    }\r\n    return headers;\r\n}\r\nvar HttpRequests = /** @class */ (function () {\r\n    function HttpRequests(config) {\r\n        this.headers = createHeaders(config);\r\n        try {\r\n            var host = constructHostURL(config.host);\r\n            this.url = new URL(host);\r\n        }\r\n        catch (e) {\r\n            throw new MeiliSearchError('The provided host is not valid.');\r\n        }\r\n    }\r\n    HttpRequests.prototype.request = function (_a) {\r\n        var method = _a.method, url = _a.url, params = _a.params, body = _a.body, config = _a.config;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var constructURL, queryParams_1, response, parsedBody, e_1, stack;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        constructURL = new URL(url, this.url);\r\n                        if (params) {\r\n                            queryParams_1 = new URLSearchParams();\r\n                            Object.keys(params)\r\n                                .filter(function (x) { return params[x] !== null; })\r\n                                .map(function (x) { return queryParams_1.set(x, params[x]); });\r\n                            constructURL.search = queryParams_1.toString();\r\n                        }\r\n                        _b.label = 1;\r\n                    case 1:\r\n                        _b.trys.push([1, 4, , 5]);\r\n                        return [4 /*yield*/, fetch(constructURL.toString(), __assign(__assign({}, config), { method: method, body: JSON.stringify(body), headers: this.headers })).then(function (res) { return httpResponseErrorHandler(res); })];\r\n                    case 2:\r\n                        response = _b.sent();\r\n                        return [4 /*yield*/, response.json()[\"catch\"](function () { return undefined; })];\r\n                    case 3:\r\n                        parsedBody = _b.sent();\r\n                        return [2 /*return*/, parsedBody];\r\n                    case 4:\r\n                        e_1 = _b.sent();\r\n                        stack = e_1.stack;\r\n                        httpErrorHandler(e_1, stack, constructURL.toString());\r\n                        return [3 /*break*/, 5];\r\n                    case 5: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype.get = function (url, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'GET',\r\n                            url: url,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype.post = function (url, data, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'POST',\r\n                            url: url,\r\n                            body: data,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype.put = function (url, data, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'PUT',\r\n                            url: url,\r\n                            body: data,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype.patch = function (url, data, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'PATCH',\r\n                            url: url,\r\n                            body: data,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    HttpRequests.prototype[\"delete\"] = function (url, data, params, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.request({\r\n                            method: 'DELETE',\r\n                            url: url,\r\n                            body: data,\r\n                            params: params,\r\n                            config: config\r\n                        })];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return HttpRequests;\r\n}());\n\nvar EnqueuedTask = /** @class */ (function () {\r\n    function EnqueuedTask(task) {\r\n        this.taskUid = task.taskUid;\r\n        this.indexUid = task.indexUid;\r\n        this.status = task.status;\r\n        this.type = task.type;\r\n        this.enqueuedAt = new Date(task.enqueuedAt);\r\n    }\r\n    return EnqueuedTask;\r\n}());\n\nvar Task = /** @class */ (function () {\r\n    function Task(task) {\r\n        this.indexUid = task.indexUid;\r\n        this.status = task.status;\r\n        this.type = task.type;\r\n        this.uid = task.uid;\r\n        this.details = task.details;\r\n        this.canceledBy = task.canceledBy;\r\n        this.error = task.error;\r\n        this.duration = task.duration;\r\n        this.startedAt = new Date(task.startedAt);\r\n        this.enqueuedAt = new Date(task.enqueuedAt);\r\n        this.finishedAt = new Date(task.finishedAt);\r\n    }\r\n    return Task;\r\n}());\r\nvar TaskClient = /** @class */ (function () {\r\n    function TaskClient(config) {\r\n        this.httpRequest = new HttpRequests(config);\r\n    }\r\n    /**\r\n     * Get one task\r\n     *\r\n     * @param uid - Unique identifier of the task\r\n     * @returns\r\n     */\r\n    TaskClient.prototype.getTask = function (uid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, taskItem;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"tasks/\".concat(uid);\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1:\r\n                        taskItem = _a.sent();\r\n                        return [2 /*return*/, new Task(taskItem)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get tasks\r\n     *\r\n     * @param parameters - Parameters to browse the tasks\r\n     * @returns Promise containing all tasks\r\n     */\r\n    TaskClient.prototype.getTasks = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, tasks;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"tasks\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url, toQueryParams(parameters))];\r\n                    case 1:\r\n                        tasks = _a.sent();\r\n                        return [2 /*return*/, __assign(__assign({}, tasks), { results: tasks.results.map(function (task) { return new Task(task); }) })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for a task to be processed.\r\n     *\r\n     * @param taskUid - Task identifier\r\n     * @param options - Additional configuration options\r\n     * @returns Promise returning a task after it has been processed\r\n     */\r\n    TaskClient.prototype.waitForTask = function (taskUid, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var startingTime, response;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        startingTime = Date.now();\r\n                        _e.label = 1;\r\n                    case 1:\r\n                        if (!(Date.now() - startingTime < timeOutMs)) return [3 /*break*/, 4];\r\n                        return [4 /*yield*/, this.getTask(taskUid)];\r\n                    case 2:\r\n                        response = _e.sent();\r\n                        if (![\"enqueued\" /* TaskStatus.TASK_ENQUEUED */, \"processing\" /* TaskStatus.TASK_PROCESSING */].includes(response.status))\r\n                            return [2 /*return*/, response];\r\n                        return [4 /*yield*/, sleep(intervalMs)];\r\n                    case 3:\r\n                        _e.sent();\r\n                        return [3 /*break*/, 1];\r\n                    case 4: throw new MeiliSearchTimeOutError(\"timeout of \".concat(timeOutMs, \"ms has exceeded on process \").concat(taskUid, \" when waiting a task to be resolved.\"));\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Waits for multiple tasks to be processed\r\n     *\r\n     * @param taskUids - Tasks identifier list\r\n     * @param options - Wait options\r\n     * @returns Promise returning a list of tasks after they have been processed\r\n     */\r\n    TaskClient.prototype.waitForTasks = function (taskUids, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var tasks, _i, taskUids_1, taskUid, task;\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0:\r\n                        tasks = [];\r\n                        _i = 0, taskUids_1 = taskUids;\r\n                        _e.label = 1;\r\n                    case 1:\r\n                        if (!(_i < taskUids_1.length)) return [3 /*break*/, 4];\r\n                        taskUid = taskUids_1[_i];\r\n                        return [4 /*yield*/, this.waitForTask(taskUid, {\r\n                                timeOutMs: timeOutMs,\r\n                                intervalMs: intervalMs\r\n                            })];\r\n                    case 2:\r\n                        task = _e.sent();\r\n                        tasks.push(task);\r\n                        _e.label = 3;\r\n                    case 3:\r\n                        _i++;\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [2 /*return*/, tasks];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Cancel a list of enqueued or processing tasks.\r\n     *\r\n     * @param parameters - Parameters to filter the tasks.\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    TaskClient.prototype.cancelTasks = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"tasks/cancel\";\r\n                        return [4 /*yield*/, this.httpRequest.post(url, {}, toQueryParams(parameters))];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete a list tasks.\r\n     *\r\n     * @param parameters - Parameters to filter the tasks.\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    TaskClient.prototype.deleteTasks = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"tasks\";\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url, {}, toQueryParams(parameters))];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return TaskClient;\r\n}());\n\n/*\r\n * Bundle: MeiliSearch / Indexes\r\n * Project: MeiliSearch - Javascript API\r\n * Author: Quentin de Quelen <quentin@meilisearch.com>\r\n * Copyright: 2019, MeiliSearch\r\n */\r\nvar Index = /** @class */ (function () {\r\n    /**\r\n     * @param config - Request configuration options\r\n     * @param uid - UID of the index\r\n     * @param primaryKey - Primary Key of the index\r\n     */\r\n    function Index(config, uid, primaryKey) {\r\n        this.uid = uid;\r\n        this.primaryKey = primaryKey;\r\n        this.httpRequest = new HttpRequests(config);\r\n        this.tasks = new TaskClient(config);\r\n    }\r\n    ///\r\n    /// SEARCH\r\n    ///\r\n    /**\r\n     * Search for documents into an index\r\n     *\r\n     * @param query - Query string\r\n     * @param options - Search options\r\n     * @param config - Additional request configuration options\r\n     * @returns Promise containing the search response\r\n     */\r\n    Index.prototype.search = function (query, options, config) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/search\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, removeUndefinedFromObject(__assign({ q: query }, options)), undefined, config)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Search for documents into an index using the GET method\r\n     *\r\n     * @param query - Query string\r\n     * @param options - Search options\r\n     * @param config - Additional request configuration options\r\n     * @returns Promise containing the search response\r\n     */\r\n    Index.prototype.searchGet = function (query, options, config) {\r\n        var _a, _b, _c, _d, _e;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, parseFilter, getParams;\r\n            return __generator(this, function (_f) {\r\n                switch (_f.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/search\");\r\n                        parseFilter = function (filter) {\r\n                            if (typeof filter === 'string')\r\n                                return filter;\r\n                            else if (Array.isArray(filter))\r\n                                throw new MeiliSearchError('The filter query parameter should be in string format when using searchGet');\r\n                            else\r\n                                return undefined;\r\n                        };\r\n                        getParams = __assign(__assign({ q: query }, options), { filter: parseFilter(options === null || options === void 0 ? void 0 : options.filter), sort: (_a = options === null || options === void 0 ? void 0 : options.sort) === null || _a === void 0 ? void 0 : _a.join(','), facets: (_b = options === null || options === void 0 ? void 0 : options.facets) === null || _b === void 0 ? void 0 : _b.join(','), attributesToRetrieve: (_c = options === null || options === void 0 ? void 0 : options.attributesToRetrieve) === null || _c === void 0 ? void 0 : _c.join(','), attributesToCrop: (_d = options === null || options === void 0 ? void 0 : options.attributesToCrop) === null || _d === void 0 ? void 0 : _d.join(','), attributesToHighlight: (_e = options === null || options === void 0 ? void 0 : options.attributesToHighlight) === null || _e === void 0 ? void 0 : _e.join(',') });\r\n                        return [4 /*yield*/, this.httpRequest.get(url, removeUndefinedFromObject(getParams), config)];\r\n                    case 1: return [2 /*return*/, _f.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// INDEX\r\n    ///\r\n    /**\r\n     * Get index information.\r\n     *\r\n     * @returns Promise containing index information\r\n     */\r\n    Index.prototype.getRawInfo = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, res;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid);\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1:\r\n                        res = _a.sent();\r\n                        this.primaryKey = res.primaryKey;\r\n                        this.updatedAt = new Date(res.updatedAt);\r\n                        this.createdAt = new Date(res.createdAt);\r\n                        return [2 /*return*/, res];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Fetch and update Index information.\r\n     *\r\n     * @returns Promise to the current Index object with updated information\r\n     */\r\n    Index.prototype.fetchInfo = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.getRawInfo()];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, this];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get Primary Key.\r\n     *\r\n     * @returns Promise containing the Primary Key of the index\r\n     */\r\n    Index.prototype.fetchPrimaryKey = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var _a;\r\n            return __generator(this, function (_b) {\r\n                switch (_b.label) {\r\n                    case 0:\r\n                        _a = this;\r\n                        return [4 /*yield*/, this.getRawInfo()];\r\n                    case 1:\r\n                        _a.primaryKey = (_b.sent()).primaryKey;\r\n                        return [2 /*return*/, this.primaryKey];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Create an index.\r\n     *\r\n     * @param uid - Unique identifier of the Index\r\n     * @param options - Index options\r\n     * @param config - Request configuration options\r\n     * @returns Newly created Index object\r\n     */\r\n    Index.create = function (uid, options, config) {\r\n        if (options === void 0) { options = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, req, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes\";\r\n                        req = new HttpRequests(config);\r\n                        return [4 /*yield*/, req.post(url, __assign(__assign({}, options), { uid: uid }))];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update an index.\r\n     *\r\n     * @param data - Data to update\r\n     * @returns Promise to the current Index object with updated information\r\n     */\r\n    Index.prototype.update = function (data) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid);\r\n                        return [4 /*yield*/, this.httpRequest.patch(url, data)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete an index.\r\n     *\r\n     * @returns Promise which resolves when index is deleted successfully\r\n     */\r\n    Index.prototype[\"delete\"] = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid);\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// TASKS\r\n    ///\r\n    /**\r\n     * Get the list of all the tasks of the index.\r\n     *\r\n     * @param parameters - Parameters to browse the tasks\r\n     * @returns Promise containing all tasks\r\n     */\r\n    Index.prototype.getTasks = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.getTasks(__assign(__assign({}, parameters), { indexUids: [this.uid] }))];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get one task of the index.\r\n     *\r\n     * @param taskUid - Task identifier\r\n     * @returns Promise containing a task\r\n     */\r\n    Index.prototype.getTask = function (taskUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.getTask(taskUid)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for multiple tasks to be processed.\r\n     *\r\n     * @param taskUids - Tasks identifier\r\n     * @param waitOptions - Options on timeout and interval\r\n     * @returns Promise containing an array of tasks\r\n     */\r\n    Index.prototype.waitForTasks = function (taskUids, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.waitForTasks(taskUids, {\r\n                            timeOutMs: timeOutMs,\r\n                            intervalMs: intervalMs\r\n                        })];\r\n                    case 1: return [2 /*return*/, _e.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for a task to be processed.\r\n     *\r\n     * @param taskUid - Task identifier\r\n     * @param waitOptions - Options on timeout and interval\r\n     * @returns Promise containing an array of tasks\r\n     */\r\n    Index.prototype.waitForTask = function (taskUid, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.waitForTask(taskUid, {\r\n                            timeOutMs: timeOutMs,\r\n                            intervalMs: intervalMs\r\n                        })];\r\n                    case 1: return [2 /*return*/, _e.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// STATS\r\n    ///\r\n    /**\r\n     * Get stats of an index\r\n     *\r\n     * @returns Promise containing object with stats of the index\r\n     */\r\n    Index.prototype.getStats = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/stats\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// DOCUMENTS\r\n    ///\r\n    /**\r\n     * Get documents of an index\r\n     *\r\n     * @param parameters - Parameters to browse the documents\r\n     * @returns Promise containing Document responses\r\n     */\r\n    Index.prototype.getDocuments = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, fields;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\r\n                        fields = (function () {\r\n                            var _a;\r\n                            if (Array.isArray(parameters === null || parameters === void 0 ? void 0 : parameters.fields)) {\r\n                                return (_a = parameters === null || parameters === void 0 ? void 0 : parameters.fields) === null || _a === void 0 ? void 0 : _a.join(',');\r\n                            }\r\n                            return undefined;\r\n                        })();\r\n                        return [4 /*yield*/, this.httpRequest.get(url, removeUndefinedFromObject(__assign(__assign({}, parameters), { fields: fields })))];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get one document\r\n     *\r\n     * @param documentId - Document ID\r\n     * @param parameters - Parameters applied on a document\r\n     * @returns Promise containing Document response\r\n     */\r\n    Index.prototype.getDocument = function (documentId, parameters) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, fields;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents/\").concat(documentId);\r\n                        fields = (function () {\r\n                            var _a;\r\n                            if (Array.isArray(parameters === null || parameters === void 0 ? void 0 : parameters.fields)) {\r\n                                return (_a = parameters === null || parameters === void 0 ? void 0 : parameters.fields) === null || _a === void 0 ? void 0 : _a.join(',');\r\n                            }\r\n                            return undefined;\r\n                        })();\r\n                        return [4 /*yield*/, this.httpRequest.get(url, removeUndefinedFromObject(__assign(__assign({}, parameters), { fields: fields })))];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add or replace multiples documents to an index\r\n     *\r\n     * @param documents - Array of Document objects to add/replace\r\n     * @param options - Options on document addition\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.addDocuments = function (documents, options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, documents, options)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add or replace multiples documents to an index in batches\r\n     *\r\n     * @param documents - Array of Document objects to add/replace\r\n     * @param batchSize - Size of the batch\r\n     * @param options - Options on document addition\r\n     * @returns Promise containing array of enqueued task objects for each batch\r\n     */\r\n    Index.prototype.addDocumentsInBatches = function (documents, batchSize, options) {\r\n        if (batchSize === void 0) { batchSize = 1000; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var updates, i, _a, _b;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        updates = [];\r\n                        i = 0;\r\n                        _c.label = 1;\r\n                    case 1:\r\n                        if (!(i < documents.length)) return [3 /*break*/, 4];\r\n                        _b = (_a = updates).push;\r\n                        return [4 /*yield*/, this.addDocuments(documents.slice(i, i + batchSize), options)];\r\n                    case 2:\r\n                        _b.apply(_a, [_c.sent()]);\r\n                        _c.label = 3;\r\n                    case 3:\r\n                        i += batchSize;\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [2 /*return*/, updates];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add or update multiples documents to an index\r\n     *\r\n     * @param documents - Array of Document objects to add/update\r\n     * @param options - Options on document update\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateDocuments = function (documents, options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, documents, options)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Add or update multiples documents to an index in batches\r\n     *\r\n     * @param documents - Array of Document objects to add/update\r\n     * @param batchSize - Size of the batch\r\n     * @param options - Options on document update\r\n     * @returns Promise containing array of enqueued task objects for each batch\r\n     */\r\n    Index.prototype.updateDocumentsInBatches = function (documents, batchSize, options) {\r\n        if (batchSize === void 0) { batchSize = 1000; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var updates, i, _a, _b;\r\n            return __generator(this, function (_c) {\r\n                switch (_c.label) {\r\n                    case 0:\r\n                        updates = [];\r\n                        i = 0;\r\n                        _c.label = 1;\r\n                    case 1:\r\n                        if (!(i < documents.length)) return [3 /*break*/, 4];\r\n                        _b = (_a = updates).push;\r\n                        return [4 /*yield*/, this.updateDocuments(documents.slice(i, i + batchSize), options)];\r\n                    case 2:\r\n                        _b.apply(_a, [_c.sent()]);\r\n                        _c.label = 3;\r\n                    case 3:\r\n                        i += batchSize;\r\n                        return [3 /*break*/, 1];\r\n                    case 4: return [2 /*return*/, updates];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete one document\r\n     *\r\n     * @param documentId - Id of Document to delete\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.deleteDocument = function (documentId) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents/\").concat(documentId);\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete multiples documents of an index\r\n     *\r\n     * @param documentsIds - Array of Document Ids to delete\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.deleteDocuments = function (documentsIds) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents/delete-batch\");\r\n                        return [4 /*yield*/, this.httpRequest.post(url, documentsIds)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete all documents of an index\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.deleteAllDocuments = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/documents\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// SETTINGS\r\n    ///\r\n    /**\r\n     * Retrieve all settings\r\n     *\r\n     * @returns Promise containing Settings object\r\n     */\r\n    Index.prototype.getSettings = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update all settings Any parameters not provided will be left unchanged.\r\n     *\r\n     * @param settings - Object containing parameters with their updated values\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateSettings = function (settings) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\r\n                        return [4 /*yield*/, this.httpRequest.patch(url, settings)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueued = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset settings.\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetSettings = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// PAGINATION SETTINGS\r\n    ///\r\n    /**\r\n     * Get the pagination settings.\r\n     *\r\n     * @returns Promise containing object of pagination settings\r\n     */\r\n    Index.prototype.getPagination = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/pagination\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the pagination settings.\r\n     *\r\n     * @param pagination - Pagination object\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updatePagination = function (pagination) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/pagination\");\r\n                        return [4 /*yield*/, this.httpRequest.patch(url, pagination)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the pagination settings.\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetPagination = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/pagination\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// SYNONYMS\r\n    ///\r\n    /**\r\n     * Get the list of all synonyms\r\n     *\r\n     * @returns Promise containing object of synonym mappings\r\n     */\r\n    Index.prototype.getSynonyms = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the list of synonyms. Overwrite the old list.\r\n     *\r\n     * @param synonyms - Mapping of synonyms with their associated words\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateSynonyms = function (synonyms) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, synonyms)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the synonym list to be empty again\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetSynonyms = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/synonyms\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// STOP WORDS\r\n    ///\r\n    /**\r\n     * Get the list of all stop-words\r\n     *\r\n     * @returns Promise containing array of stop-words\r\n     */\r\n    Index.prototype.getStopWords = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the list of stop-words. Overwrite the old list.\r\n     *\r\n     * @param stopWords - Array of strings that contains the stop-words.\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateStopWords = function (stopWords) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, stopWords)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the stop-words list to be empty again\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetStopWords = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/stop-words\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// RANKING RULES\r\n    ///\r\n    /**\r\n     * Get the list of all ranking-rules\r\n     *\r\n     * @returns Promise containing array of ranking-rules\r\n     */\r\n    Index.prototype.getRankingRules = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the list of ranking-rules. Overwrite the old list.\r\n     *\r\n     * @param rankingRules - Array that contain ranking rules sorted by order of\r\n     *   importance.\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateRankingRules = function (rankingRules) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, rankingRules)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the ranking rules list to its default value\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetRankingRules = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/ranking-rules\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// DISTINCT ATTRIBUTE\r\n    ///\r\n    /**\r\n     * Get the distinct-attribute\r\n     *\r\n     * @returns Promise containing the distinct-attribute of the index\r\n     */\r\n    Index.prototype.getDistinctAttribute = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the distinct-attribute.\r\n     *\r\n     * @param distinctAttribute - Field name of the distinct-attribute\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateDistinctAttribute = function (distinctAttribute) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, distinctAttribute)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the distinct-attribute.\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetDistinctAttribute = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/distinct-attribute\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// FILTERABLE ATTRIBUTES\r\n    ///\r\n    /**\r\n     * Get the filterable-attributes\r\n     *\r\n     * @returns Promise containing an array of filterable-attributes\r\n     */\r\n    Index.prototype.getFilterableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the filterable-attributes.\r\n     *\r\n     * @param filterableAttributes - Array of strings containing the attributes\r\n     *   that can be used as filters at query time\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateFilterableAttributes = function (filterableAttributes) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, filterableAttributes)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the filterable-attributes.\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetFilterableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/filterable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// SORTABLE ATTRIBUTES\r\n    ///\r\n    /**\r\n     * Get the sortable-attributes\r\n     *\r\n     * @returns Promise containing array of sortable-attributes\r\n     */\r\n    Index.prototype.getSortableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the sortable-attributes.\r\n     *\r\n     * @param sortableAttributes - Array of strings containing the attributes that\r\n     *   can be used to sort search results at query time\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateSortableAttributes = function (sortableAttributes) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, sortableAttributes)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the sortable-attributes.\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetSortableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/sortable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// SEARCHABLE ATTRIBUTE\r\n    ///\r\n    /**\r\n     * Get the searchable-attributes\r\n     *\r\n     * @returns Promise containing array of searchable-attributes\r\n     */\r\n    Index.prototype.getSearchableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the searchable-attributes.\r\n     *\r\n     * @param searchableAttributes - Array of strings that contains searchable\r\n     *   attributes sorted by order of importance(most to least important)\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateSearchableAttributes = function (searchableAttributes) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, searchableAttributes)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the searchable-attributes.\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetSearchableAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/searchable-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// DISPLAYED ATTRIBUTE\r\n    ///\r\n    /**\r\n     * Get the displayed-attributes\r\n     *\r\n     * @returns Promise containing array of displayed-attributes\r\n     */\r\n    Index.prototype.getDisplayedAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the displayed-attributes.\r\n     *\r\n     * @param displayedAttributes - Array of strings that contains attributes of\r\n     *   an index to display\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateDisplayedAttributes = function (displayedAttributes) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest.put(url, displayedAttributes)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the displayed-attributes.\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetDisplayedAttributes = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/displayed-attributes\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// TYPO TOLERANCE\r\n    ///\r\n    /**\r\n     * Get the typo tolerance settings.\r\n     *\r\n     * @returns Promise containing the typo tolerance settings.\r\n     */\r\n    Index.prototype.getTypoTolerance = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the typo tolerance settings.\r\n     *\r\n     * @param typoTolerance - Object containing the custom typo tolerance\r\n     *   settings.\r\n     * @returns Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.updateTypoTolerance = function (typoTolerance) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\r\n                        return [4 /*yield*/, this.httpRequest.patch(url, typoTolerance)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the typo tolerance settings.\r\n     *\r\n     * @returns Promise containing object of the enqueued update\r\n     */\r\n    Index.prototype.resetTypoTolerance = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/typo-tolerance\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        task.enqueuedAt = new Date(task.enqueuedAt);\r\n                        return [2 /*return*/, task];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// FACETING\r\n    ///\r\n    /**\r\n     * Get the faceting settings.\r\n     *\r\n     * @returns Promise containing object of faceting index settings\r\n     */\r\n    Index.prototype.getFaceting = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/faceting\");\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update the faceting settings.\r\n     *\r\n     * @param faceting - Faceting index settings object\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.updateFaceting = function (faceting) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/faceting\");\r\n                        return [4 /*yield*/, this.httpRequest.patch(url, faceting)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Reset the faceting settings.\r\n     *\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Index.prototype.resetFaceting = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes/\".concat(this.uid, \"/settings/faceting\");\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    return Index;\r\n}());\n\n/*\r\n * Bundle: MeiliSearch\r\n * Project: MeiliSearch - Javascript API\r\n * Author: Quentin de Quelen <quentin@meilisearch.com>\r\n * Copyright: 2019, MeiliSearch\r\n */\r\nvar Client = /** @class */ (function () {\r\n    /**\r\n     * Creates new MeiliSearch instance\r\n     *\r\n     * @param config - Configuration object\r\n     */\r\n    function Client(config) {\r\n        this.config = config;\r\n        this.httpRequest = new HttpRequests(config);\r\n        this.tasks = new TaskClient(config);\r\n    }\r\n    /**\r\n     * Return an Index instance\r\n     *\r\n     * @param indexUid - The index UID\r\n     * @returns Instance of Index\r\n     */\r\n    Client.prototype.index = function (indexUid) {\r\n        return new Index(this.config, indexUid);\r\n    };\r\n    /**\r\n     * Gather information about an index by calling MeiliSearch and return an\r\n     * Index instance with the gathered information\r\n     *\r\n     * @param indexUid - The index UID\r\n     * @returns Promise returning Index instance\r\n     */\r\n    Client.prototype.getIndex = function (indexUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, new Index(this.config, indexUid).fetchInfo()];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Gather information about an index by calling MeiliSearch and return the raw\r\n     * JSON response\r\n     *\r\n     * @param indexUid - The index UID\r\n     * @returns Promise returning index information\r\n     */\r\n    Client.prototype.getRawIndex = function (indexUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                return [2 /*return*/, new Index(this.config, indexUid).getRawInfo()];\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get all the indexes as Index instances.\r\n     *\r\n     * @param parameters - Parameters to browse the indexes\r\n     * @returns Promise returning array of raw index information\r\n     */\r\n    Client.prototype.getIndexes = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var rawIndexes, indexes;\r\n            var _this = this;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.getRawIndexes(parameters)];\r\n                    case 1:\r\n                        rawIndexes = _a.sent();\r\n                        indexes = rawIndexes.results.map(function (index) { return new Index(_this.config, index.uid, index.primaryKey); });\r\n                        return [2 /*return*/, __assign(__assign({}, rawIndexes), { results: indexes })];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get all the indexes in their raw value (no Index instances).\r\n     *\r\n     * @param parameters - Parameters to browse the indexes\r\n     * @returns Promise returning array of raw index information\r\n     */\r\n    Client.prototype.getRawIndexes = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"indexes\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url, parameters)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Create a new index\r\n     *\r\n     * @param uid - The index UID\r\n     * @param options - Index options\r\n     * @returns Promise returning Index instance\r\n     */\r\n    Client.prototype.createIndex = function (uid, options) {\r\n        if (options === void 0) { options = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, Index.create(uid, options, this.config)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update an index\r\n     *\r\n     * @param uid - The index UID\r\n     * @param options - Index options to update\r\n     * @returns Promise returning Index instance after updating\r\n     */\r\n    Client.prototype.updateIndex = function (uid, options) {\r\n        if (options === void 0) { options = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, new Index(this.config, uid).update(options)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete an index\r\n     *\r\n     * @param uid - The index UID\r\n     * @returns Promise which resolves when index is deleted successfully\r\n     */\r\n    Client.prototype.deleteIndex = function (uid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, new Index(this.config, uid)[\"delete\"]()];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Deletes an index if it already exists.\r\n     *\r\n     * @param uid - The index UID\r\n     * @returns Promise which resolves to true when index exists and is deleted\r\n     *   successfully, otherwise false if it does not exist\r\n     */\r\n    Client.prototype.deleteIndexIfExists = function (uid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var e_1;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        return [4 /*yield*/, this.deleteIndex(uid)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, true];\r\n                    case 2:\r\n                        e_1 = _a.sent();\r\n                        if (e_1.code === \"index_not_found\" /* ErrorStatusCode.INDEX_NOT_FOUND */) {\r\n                            return [2 /*return*/, false];\r\n                        }\r\n                        throw e_1;\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Swaps a list of index tuples.\r\n     *\r\n     * @param params - List of indexes tuples to swap.\r\n     * @returns Promise returning object of the enqueued task\r\n     */\r\n    Client.prototype.swapIndexes = function (params) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = '/swap-indexes';\r\n                        return [4 /*yield*/, this.httpRequest.post(url, params)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// TASKS\r\n    ///\r\n    /**\r\n     * Get the list of all client tasks\r\n     *\r\n     * @param parameters - Parameters to browse the tasks\r\n     * @returns Promise returning all tasks\r\n     */\r\n    Client.prototype.getTasks = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.getTasks(parameters)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get one task on the client scope\r\n     *\r\n     * @param taskUid - Task identifier\r\n     * @returns Promise returning a task\r\n     */\r\n    Client.prototype.getTask = function (taskUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.getTask(taskUid)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for multiple tasks to be finished.\r\n     *\r\n     * @param taskUids - Tasks identifier\r\n     * @param waitOptions - Options on timeout and interval\r\n     * @returns Promise returning an array of tasks\r\n     */\r\n    Client.prototype.waitForTasks = function (taskUids, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.waitForTasks(taskUids, {\r\n                            timeOutMs: timeOutMs,\r\n                            intervalMs: intervalMs\r\n                        })];\r\n                    case 1: return [2 /*return*/, _e.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Wait for a task to be finished.\r\n     *\r\n     * @param taskUid - Task identifier\r\n     * @param waitOptions - Options on timeout and interval\r\n     * @returns Promise returning an array of tasks\r\n     */\r\n    Client.prototype.waitForTask = function (taskUid, _a) {\r\n        var _b = _a === void 0 ? {} : _a, _c = _b.timeOutMs, timeOutMs = _c === void 0 ? 5000 : _c, _d = _b.intervalMs, intervalMs = _d === void 0 ? 50 : _d;\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_e) {\r\n                switch (_e.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.waitForTask(taskUid, {\r\n                            timeOutMs: timeOutMs,\r\n                            intervalMs: intervalMs\r\n                        })];\r\n                    case 1: return [2 /*return*/, _e.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Cancel a list of enqueued or processing tasks.\r\n     *\r\n     * @param parameters - Parameters to filter the tasks.\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Client.prototype.cancelTasks = function (parameters) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.cancelTasks(parameters)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete a list of tasks.\r\n     *\r\n     * @param parameters - Parameters to filter the tasks.\r\n     * @returns Promise containing an EnqueuedTask\r\n     */\r\n    Client.prototype.deleteTasks = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0: return [4 /*yield*/, this.tasks.deleteTasks(parameters)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// KEYS\r\n    ///\r\n    /**\r\n     * Get all API keys\r\n     *\r\n     * @param parameters - Parameters to browse the indexes\r\n     * @returns Promise returning an object with keys\r\n     */\r\n    Client.prototype.getKeys = function (parameters) {\r\n        if (parameters === void 0) { parameters = {}; }\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, keys;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url, parameters)];\r\n                    case 1:\r\n                        keys = _a.sent();\r\n                        keys.results = keys.results.map(function (key) { return (__assign(__assign({}, key), { createdAt: new Date(key.createdAt), updateAt: new Date(key.updateAt) })); });\r\n                        return [2 /*return*/, keys];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Get one API key\r\n     *\r\n     * @param keyOrUid - Key or uid of the API key\r\n     * @returns Promise returning a key\r\n     */\r\n    Client.prototype.getKey = function (keyOrUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys/\".concat(keyOrUid);\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Create one API key\r\n     *\r\n     * @param options - Key options\r\n     * @returns Promise returning a key\r\n     */\r\n    Client.prototype.createKey = function (options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys\";\r\n                        return [4 /*yield*/, this.httpRequest.post(url, options)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Update one API key\r\n     *\r\n     * @param keyOrUid - Key\r\n     * @param options - Key options\r\n     * @returns Promise returning a key\r\n     */\r\n    Client.prototype.updateKey = function (keyOrUid, options) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys/\".concat(keyOrUid);\r\n                        return [4 /*yield*/, this.httpRequest.patch(url, options)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Delete one API key\r\n     *\r\n     * @param keyOrUid - Key\r\n     * @returns\r\n     */\r\n    Client.prototype.deleteKey = function (keyOrUid) {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"keys/\".concat(keyOrUid);\r\n                        return [4 /*yield*/, this.httpRequest[\"delete\"](url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// HEALTH\r\n    ///\r\n    /**\r\n     * Checks if the server is healthy, otherwise an error will be thrown.\r\n     *\r\n     * @returns Promise returning an object with health details\r\n     */\r\n    Client.prototype.health = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"health\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    /**\r\n     * Checks if the server is healthy, return true or false.\r\n     *\r\n     * @returns Promise returning a boolean\r\n     */\r\n    Client.prototype.isHealthy = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        _a.trys.push([0, 2, , 3]);\r\n                        url = \"health\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1:\r\n                        _a.sent();\r\n                        return [2 /*return*/, true];\r\n                    case 2:\r\n                        _a.sent();\r\n                        return [2 /*return*/, false];\r\n                    case 3: return [2 /*return*/];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// STATS\r\n    ///\r\n    /**\r\n     * Get the stats of all the database\r\n     *\r\n     * @returns Promise returning object of all the stats\r\n     */\r\n    Client.prototype.getStats = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"stats\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// VERSION\r\n    ///\r\n    /**\r\n     * Get the version of MeiliSearch\r\n     *\r\n     * @returns Promise returning object with version details\r\n     */\r\n    Client.prototype.getVersion = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"version\";\r\n                        return [4 /*yield*/, this.httpRequest.get(url)];\r\n                    case 1: return [2 /*return*/, _a.sent()];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// DUMPS\r\n    ///\r\n    /**\r\n     * Creates a dump\r\n     *\r\n     * @returns Promise returning object of the enqueued task\r\n     */\r\n    Client.prototype.createDump = function () {\r\n        return __awaiter(this, void 0, void 0, function () {\r\n            var url, task;\r\n            return __generator(this, function (_a) {\r\n                switch (_a.label) {\r\n                    case 0:\r\n                        url = \"dumps\";\r\n                        return [4 /*yield*/, this.httpRequest.post(url)];\r\n                    case 1:\r\n                        task = _a.sent();\r\n                        return [2 /*return*/, new EnqueuedTask(task)];\r\n                }\r\n            });\r\n        });\r\n    };\r\n    ///\r\n    /// TOKENS\r\n    ///\r\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @param apiKeyUid - The uid of the api key used as issuer of the token.\r\n     * @param searchRules - Search rules that are applied to every search.\r\n     * @param options - Token options to customize some aspect of the token.\r\n     * @returns The token in JWT format.\r\n     */\r\n    Client.prototype.generateTenantToken = function (_apiKeyUid, _searchRules, _options) {\r\n        var error = new Error();\r\n        throw new Error(\"Meilisearch: failed to generate a tenant token. Generation of a token only works in a node environment \\n \".concat(error.stack, \".\"));\r\n    };\r\n    return Client;\r\n}());\n\nfunction encode64(data) {\r\n    return Buffer.from(JSON.stringify(data)).toString('base64');\r\n}\r\n/**\r\n * Create the header of the token.\r\n *\r\n * @param apiKey - API key used to sign the token.\r\n * @param encodedHeader - Header of the token in base64.\r\n * @param encodedPayload - Payload of the token in base64.\r\n * @returns The signature of the token in base64.\r\n */\r\nfunction sign(apiKey, encodedHeader, encodedPayload) {\r\n    return crypto__WEBPACK_IMPORTED_MODULE_1___default().createHmac('sha256', apiKey)\r\n        .update(\"\".concat(encodedHeader, \".\").concat(encodedPayload))\r\n        .digest('base64')\r\n        .replace(/\\+/g, '-')\r\n        .replace(/\\//g, '_')\r\n        .replace(/=/g, '');\r\n}\r\n/**\r\n * Create the header of the token.\r\n *\r\n * @returns The header encoded in base64.\r\n */\r\nfunction createHeader() {\r\n    var header = {\r\n        alg: 'HS256',\r\n        typ: 'JWT'\r\n    };\r\n    return encode64(header).replace(/=/g, '');\r\n}\r\n/**\r\n * Validate the parameter used for the payload of the token.\r\n *\r\n * @param searchRules - Search rules that are applied to every search.\r\n * @param apiKey - Api key used as issuer of the token.\r\n * @param uid - The uid of the api key used as issuer of the token.\r\n * @param expiresAt - Date at which the token expires.\r\n */\r\nfunction validateTokenParameters(tokenParams) {\r\n    var searchRules = tokenParams.searchRules, uid = tokenParams.uid, apiKey = tokenParams.apiKey, expiresAt = tokenParams.expiresAt;\r\n    if (expiresAt) {\r\n        if (!(expiresAt instanceof Date)) {\r\n            throw new MeiliSearchError(\"Meilisearch: The expiredAt field must be an instance of Date.\");\r\n        }\r\n        else if (expiresAt.getTime() < Date.now()) {\r\n            throw new MeiliSearchError(\"Meilisearch: The expiresAt field must be a date in the future.\");\r\n        }\r\n    }\r\n    if (searchRules) {\r\n        if (!(typeof searchRules === 'object' || Array.isArray(searchRules))) {\r\n            throw new MeiliSearchError(\"Meilisearch: The search rules added in the token generation must be of type array or object.\");\r\n        }\r\n    }\r\n    if (!apiKey || typeof apiKey !== 'string') {\r\n        throw new MeiliSearchError(\"Meilisearch: The API key used for the token generation must exist and be of type string.\");\r\n    }\r\n    if (!uid || typeof uid !== 'string') {\r\n        throw new MeiliSearchError(\"Meilisearch: The uid of the api key used for the token generation must exist, be of type string and comply to the uuid4 format.\");\r\n    }\r\n    if (!validateUuid4(uid)) {\r\n        throw new MeiliSearchError(\"Meilisearch: The uid of your key is not a valid uuid4. To find out the uid of your key use getKey().\");\r\n    }\r\n}\r\n/**\r\n * Create the payload of the token.\r\n *\r\n * @param searchRules - Search rules that are applied to every search.\r\n * @param uid - The uid of the api key used as issuer of the token.\r\n * @param expiresAt - Date at which the token expires.\r\n * @returns The payload encoded in base64.\r\n */\r\nfunction createPayload(payloadParams) {\r\n    var searchRules = payloadParams.searchRules, uid = payloadParams.uid, expiresAt = payloadParams.expiresAt;\r\n    var payload = {\r\n        searchRules: searchRules,\r\n        apiKeyUid: uid,\r\n        exp: expiresAt === null || expiresAt === void 0 ? void 0 : expiresAt.getTime()\r\n    };\r\n    return encode64(payload).replace(/=/g, '');\r\n}\r\nvar Token = /** @class */ (function () {\r\n    function Token(config) {\r\n        this.config = config;\r\n    }\r\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @param apiKeyUid - The uid of the api key used as issuer of the token.\r\n     * @param searchRules - Search rules that are applied to every search.\r\n     * @param options - Token options to customize some aspect of the token.\r\n     * @returns The token in JWT format.\r\n     */\r\n    Token.prototype.generateTenantToken = function (apiKeyUid, searchRules, options) {\r\n        var apiKey = (options === null || options === void 0 ? void 0 : options.apiKey) || this.config.apiKey || '';\r\n        var uid = apiKeyUid || '';\r\n        var expiresAt = options === null || options === void 0 ? void 0 : options.expiresAt;\r\n        validateTokenParameters({ apiKey: apiKey, uid: uid, expiresAt: expiresAt, searchRules: searchRules });\r\n        var encodedHeader = createHeader();\r\n        var encodedPayload = createPayload({ searchRules: searchRules, uid: uid, expiresAt: expiresAt });\r\n        var signature = sign(apiKey, encodedHeader, encodedPayload);\r\n        return \"\".concat(encodedHeader, \".\").concat(encodedPayload, \".\").concat(signature);\r\n    };\r\n    return Token;\r\n}());\n\nvar MeiliSearch = /** @class */ (function (_super) {\r\n    __extends(MeiliSearch, _super);\r\n    function MeiliSearch(config) {\r\n        var _this = _super.call(this, config) || this;\r\n        _this.tokens = new Token(config);\r\n        return _this;\r\n    }\r\n    /**\r\n     * Generate a tenant token\r\n     *\r\n     * @param apiKeyUid - The uid of the api key used as issuer of the token.\r\n     * @param searchRules - Search rules that are applied to every search.\r\n     * @param options - Token options to customize some aspect of the token.\r\n     * @returns The token in JWT format.\r\n     */\r\n    MeiliSearch.prototype.generateTenantToken = function (apiKeyUid, searchRules, options) {\r\n        if (typeof window === 'undefined') {\r\n            return this.tokens.generateTenantToken(apiKeyUid, searchRules, options);\r\n        }\r\n        return _super.prototype.generateTenantToken.call(this, apiKeyUid, searchRules, options);\r\n    };\r\n    return MeiliSearch;\r\n}(Client));\n\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQG1laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvbm9kZV9tb2R1bGVzL21laWxpc2VhcmNoL2Rpc3QvYnVuZGxlcy9tZWlsaXNlYXJjaC5lc20uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7QUFBOEI7QUFDRjs7QUFFNUI7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFdBQVcsZ0JBQWdCLHNDQUFzQyxrQkFBa0I7QUFDbkYsMEJBQTBCO0FBQzFCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0JBQW9CO0FBQ3BCO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpREFBaUQsT0FBTztBQUN4RDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw0QkFBNEIsK0RBQStELGlCQUFpQjtBQUM1RztBQUNBLG9DQUFvQyxNQUFNLCtCQUErQixZQUFZO0FBQ3JGLG1DQUFtQyxNQUFNLG1DQUFtQyxZQUFZO0FBQ3hGLGdDQUFnQztBQUNoQztBQUNBLEtBQUs7QUFDTDtBQUNBO0FBQ0E7QUFDQSxjQUFjLDZCQUE2QiwwQkFBMEIsY0FBYyxxQkFBcUI7QUFDeEcsaUJBQWlCLG9EQUFvRCxxRUFBcUUsY0FBYztBQUN4Six1QkFBdUIsc0JBQXNCO0FBQzdDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHdDQUF3QztBQUN4QyxtQ0FBbUMsU0FBUztBQUM1QyxtQ0FBbUMsV0FBVyxVQUFVO0FBQ3hELDBDQUEwQyxjQUFjO0FBQ3hEO0FBQ0EsOEdBQThHLE9BQU87QUFDckgsaUZBQWlGLGlCQUFpQjtBQUNsRyx5REFBeUQsZ0JBQWdCLFFBQVE7QUFDakYsK0NBQStDLGdCQUFnQixnQkFBZ0I7QUFDL0U7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBLFVBQVUsWUFBWSxhQUFhLFNBQVMsVUFBVTtBQUN0RCxvQ0FBb0MsU0FBUztBQUM3QztBQUNBOztBQUVBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLFNBQVM7QUFDVCxLQUFLO0FBQ0w7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7O0FBRUE7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLEtBQUssSUFBSTtBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw4RUFBOEUsaUNBQWlDO0FBQy9HO0FBQ0E7QUFDQSxTQUFTO0FBQ1QsS0FBSztBQUNMO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxpQ0FBaUMsRUFBRSxlQUFlLEVBQUUsZUFBZSxFQUFFLGVBQWUsRUFBRSxlQUFlLEdBQUc7QUFDeEc7QUFDQTs7QUFFQTs7QUFFQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0E7QUFDQSx1Q0FBdUMsZ0JBQWdCO0FBQ3ZEO0FBQ0EsbUNBQW1DLGdCQUFnQjtBQUNuRCxLQUFLLElBQUk7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0NBQWtDLG1CQUFtQjtBQUNyRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxnREFBZ0Q7QUFDaEQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHVEQUF1RCw0QkFBNEI7QUFDbkYsb0RBQW9ELHlDQUF5QztBQUM3RjtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsZ0dBQWdHLGFBQWEsbUVBQW1FLHlCQUF5Qix1Q0FBdUM7QUFDaFA7QUFDQTtBQUNBLG9GQUFvRixtQkFBbUI7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBLENBQUM7O0FBRUQ7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxDQUFDO0FBQ0Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esa0VBQWtFLFlBQVksNkNBQTZDLHdCQUF3QixHQUFHO0FBQ3RKO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esb0NBQW9DO0FBQ3BDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSw2QkFBNkI7QUFDN0I7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EscUNBQXFDO0FBQ3JDO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDBFQUEwRTtBQUMxRTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSwrRUFBK0U7QUFDL0U7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDZHQUE2RyxVQUFVO0FBQ3ZIO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0Esd0RBQXdELFVBQVUsY0FBYyxnekJBQWd6QjtBQUNoNEI7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQztBQUNsQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLCtFQUErRSxjQUFjLFVBQVU7QUFDdkc7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQSx5RkFBeUYsaUJBQWlCLHVCQUF1QjtBQUNqSTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCLHFIQUFxSCxpQkFBaUIsZ0JBQWdCO0FBQ3RKO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHlCQUF5QjtBQUN6QixxSEFBcUgsaUJBQWlCLGdCQUFnQjtBQUN0SjtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQSxDQUFDOztBQUVEO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLDRFQUE0RSw4REFBOEQ7QUFDMUksa0VBQWtFLGlCQUFpQixrQkFBa0I7QUFDckc7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxrQ0FBa0M7QUFDbEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxvQ0FBb0M7QUFDcEM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUJBQXlCO0FBQ3pCO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLG9DQUFvQztBQUNwQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSx5QkFBeUI7QUFDekI7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLHFDQUFxQztBQUNyQztBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxxQ0FBcUM7QUFDckM7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EseUVBQXlFLDRCQUE0QixVQUFVLHNFQUFzRSxLQUFLO0FBQzFMO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxhQUFhO0FBQ2IsU0FBUztBQUNUO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGFBQWE7QUFDYixTQUFTO0FBQ1Q7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsYUFBYTtBQUNiLFNBQVM7QUFDVDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQSxXQUFXLHdEQUNRO0FBQ25CO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLGtDQUFrQywwRUFBMEU7QUFDNUc7QUFDQSw2Q0FBNkMsMERBQTBEO0FBQ3ZHO0FBQ0E7QUFDQTtBQUNBO0FBQ0EsQ0FBQzs7QUFFRDtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBO0FBQ0E7QUFDQTtBQUNBLENBQUM7O0FBRW9QIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vc3RhcnR1cC1uZXh0anMtdGVtcGxhdGUvLi9ub2RlX21vZHVsZXMvQG1laWxpc2VhcmNoL2luc3RhbnQtbWVpbGlzZWFyY2gvbm9kZV9tb2R1bGVzL21laWxpc2VhcmNoL2Rpc3QvYnVuZGxlcy9tZWlsaXNlYXJjaC5lc20uanM/MWI0NCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgJ2Nyb3NzLWZldGNoL3BvbHlmaWxsJztcbmltcG9ydCBjcnlwdG8gZnJvbSAnY3J5cHRvJztcblxuLy8gVHlwZSBkZWZpbml0aW9ucyBmb3IgbWVpbGlzZWFyY2hcclxuLy8gUHJvamVjdDogaHR0cHM6Ly9naXRodWIuY29tL21laWxpc2VhcmNoL21laWxpc2VhcmNoLWpzXHJcbi8vIERlZmluaXRpb25zIGJ5OiBxZGVxdWVsZSA8cXVlbnRpbkBtZWlsaXNlYXJjaC5jb20+IDxodHRwczovL2dpdGh1Yi5jb20vbWVpbGlzZWFyY2g+XHJcbi8vIERlZmluaXRpb25zOiBodHRwczovL2dpdGh1Yi5jb20vbWVpbGlzZWFyY2gvbWVpbGlzZWFyY2gtanNcclxuLy8gVHlwZVNjcmlwdCBWZXJzaW9uOiBeMy44LjNcclxuLypcclxuICogU0VBUkNIIFBBUkFNRVRFUlNcclxuICovXHJcbnZhciBNYXRjaGluZ1N0cmF0ZWdpZXMgPSB7XHJcbiAgICBBTEw6ICdhbGwnLFxyXG4gICAgTEFTVDogJ2xhc3QnXHJcbn07XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKipcclxuQ29weXJpZ2h0IChjKSBNaWNyb3NvZnQgQ29ycG9yYXRpb24uXHJcblxyXG5QZXJtaXNzaW9uIHRvIHVzZSwgY29weSwgbW9kaWZ5LCBhbmQvb3IgZGlzdHJpYnV0ZSB0aGlzIHNvZnR3YXJlIGZvciBhbnlcclxucHVycG9zZSB3aXRoIG9yIHdpdGhvdXQgZmVlIGlzIGhlcmVieSBncmFudGVkLlxyXG5cclxuVEhFIFNPRlRXQVJFIElTIFBST1ZJREVEIFwiQVMgSVNcIiBBTkQgVEhFIEFVVEhPUiBESVNDTEFJTVMgQUxMIFdBUlJBTlRJRVMgV0lUSFxyXG5SRUdBUkQgVE8gVEhJUyBTT0ZUV0FSRSBJTkNMVURJTkcgQUxMIElNUExJRUQgV0FSUkFOVElFUyBPRiBNRVJDSEFOVEFCSUxJVFlcclxuQU5EIEZJVE5FU1MuIElOIE5PIEVWRU5UIFNIQUxMIFRIRSBBVVRIT1IgQkUgTElBQkxFIEZPUiBBTlkgU1BFQ0lBTCwgRElSRUNULFxyXG5JTkRJUkVDVCwgT1IgQ09OU0VRVUVOVElBTCBEQU1BR0VTIE9SIEFOWSBEQU1BR0VTIFdIQVRTT0VWRVIgUkVTVUxUSU5HIEZST01cclxuTE9TUyBPRiBVU0UsIERBVEEgT1IgUFJPRklUUywgV0hFVEhFUiBJTiBBTiBBQ1RJT04gT0YgQ09OVFJBQ1QsIE5FR0xJR0VOQ0UgT1JcclxuT1RIRVIgVE9SVElPVVMgQUNUSU9OLCBBUklTSU5HIE9VVCBPRiBPUiBJTiBDT05ORUNUSU9OIFdJVEggVEhFIFVTRSBPUlxyXG5QRVJGT1JNQU5DRSBPRiBUSElTIFNPRlRXQVJFLlxyXG4qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiAqL1xyXG4vKiBnbG9iYWwgUmVmbGVjdCwgUHJvbWlzZSAqL1xyXG5cclxudmFyIGV4dGVuZFN0YXRpY3MgPSBmdW5jdGlvbihkLCBiKSB7XHJcbiAgICBleHRlbmRTdGF0aWNzID0gT2JqZWN0LnNldFByb3RvdHlwZU9mIHx8XHJcbiAgICAgICAgKHsgX19wcm90b19fOiBbXSB9IGluc3RhbmNlb2YgQXJyYXkgJiYgZnVuY3Rpb24gKGQsIGIpIHsgZC5fX3Byb3RvX18gPSBiOyB9KSB8fFxyXG4gICAgICAgIGZ1bmN0aW9uIChkLCBiKSB7IGZvciAodmFyIHAgaW4gYikgaWYgKE9iamVjdC5wcm90b3R5cGUuaGFzT3duUHJvcGVydHkuY2FsbChiLCBwKSkgZFtwXSA9IGJbcF07IH07XHJcbiAgICByZXR1cm4gZXh0ZW5kU3RhdGljcyhkLCBiKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fZXh0ZW5kcyhkLCBiKSB7XHJcbiAgICBpZiAodHlwZW9mIGIgIT09IFwiZnVuY3Rpb25cIiAmJiBiICE9PSBudWxsKVxyXG4gICAgICAgIHRocm93IG5ldyBUeXBlRXJyb3IoXCJDbGFzcyBleHRlbmRzIHZhbHVlIFwiICsgU3RyaW5nKGIpICsgXCIgaXMgbm90IGEgY29uc3RydWN0b3Igb3IgbnVsbFwiKTtcclxuICAgIGV4dGVuZFN0YXRpY3MoZCwgYik7XHJcbiAgICBmdW5jdGlvbiBfXygpIHsgdGhpcy5jb25zdHJ1Y3RvciA9IGQ7IH1cclxuICAgIGQucHJvdG90eXBlID0gYiA9PT0gbnVsbCA/IE9iamVjdC5jcmVhdGUoYikgOiAoX18ucHJvdG90eXBlID0gYi5wcm90b3R5cGUsIG5ldyBfXygpKTtcclxufVxyXG5cclxudmFyIF9fYXNzaWduID0gZnVuY3Rpb24oKSB7XHJcbiAgICBfX2Fzc2lnbiA9IE9iamVjdC5hc3NpZ24gfHwgZnVuY3Rpb24gX19hc3NpZ24odCkge1xyXG4gICAgICAgIGZvciAodmFyIHMsIGkgPSAxLCBuID0gYXJndW1lbnRzLmxlbmd0aDsgaSA8IG47IGkrKykge1xyXG4gICAgICAgICAgICBzID0gYXJndW1lbnRzW2ldO1xyXG4gICAgICAgICAgICBmb3IgKHZhciBwIGluIHMpIGlmIChPYmplY3QucHJvdG90eXBlLmhhc093blByb3BlcnR5LmNhbGwocywgcCkpIHRbcF0gPSBzW3BdO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gdDtcclxuICAgIH07XHJcbiAgICByZXR1cm4gX19hc3NpZ24uYXBwbHkodGhpcywgYXJndW1lbnRzKTtcclxufTtcclxuXHJcbmZ1bmN0aW9uIF9fYXdhaXRlcih0aGlzQXJnLCBfYXJndW1lbnRzLCBQLCBnZW5lcmF0b3IpIHtcclxuICAgIGZ1bmN0aW9uIGFkb3B0KHZhbHVlKSB7IHJldHVybiB2YWx1ZSBpbnN0YW5jZW9mIFAgPyB2YWx1ZSA6IG5ldyBQKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJlc29sdmUodmFsdWUpOyB9KTsgfVxyXG4gICAgcmV0dXJuIG5ldyAoUCB8fCAoUCA9IFByb21pc2UpKShmdW5jdGlvbiAocmVzb2x2ZSwgcmVqZWN0KSB7XHJcbiAgICAgICAgZnVuY3Rpb24gZnVsZmlsbGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yLm5leHQodmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHJlamVjdGVkKHZhbHVlKSB7IHRyeSB7IHN0ZXAoZ2VuZXJhdG9yW1widGhyb3dcIl0odmFsdWUpKTsgfSBjYXRjaCAoZSkgeyByZWplY3QoZSk7IH0gfVxyXG4gICAgICAgIGZ1bmN0aW9uIHN0ZXAocmVzdWx0KSB7IHJlc3VsdC5kb25lID8gcmVzb2x2ZShyZXN1bHQudmFsdWUpIDogYWRvcHQocmVzdWx0LnZhbHVlKS50aGVuKGZ1bGZpbGxlZCwgcmVqZWN0ZWQpOyB9XHJcbiAgICAgICAgc3RlcCgoZ2VuZXJhdG9yID0gZ2VuZXJhdG9yLmFwcGx5KHRoaXNBcmcsIF9hcmd1bWVudHMgfHwgW10pKS5uZXh0KCkpO1xyXG4gICAgfSk7XHJcbn1cclxuXHJcbmZ1bmN0aW9uIF9fZ2VuZXJhdG9yKHRoaXNBcmcsIGJvZHkpIHtcclxuICAgIHZhciBfID0geyBsYWJlbDogMCwgc2VudDogZnVuY3Rpb24oKSB7IGlmICh0WzBdICYgMSkgdGhyb3cgdFsxXTsgcmV0dXJuIHRbMV07IH0sIHRyeXM6IFtdLCBvcHM6IFtdIH0sIGYsIHksIHQsIGc7XHJcbiAgICByZXR1cm4gZyA9IHsgbmV4dDogdmVyYigwKSwgXCJ0aHJvd1wiOiB2ZXJiKDEpLCBcInJldHVyblwiOiB2ZXJiKDIpIH0sIHR5cGVvZiBTeW1ib2wgPT09IFwiZnVuY3Rpb25cIiAmJiAoZ1tTeW1ib2wuaXRlcmF0b3JdID0gZnVuY3Rpb24oKSB7IHJldHVybiB0aGlzOyB9KSwgZztcclxuICAgIGZ1bmN0aW9uIHZlcmIobikgeyByZXR1cm4gZnVuY3Rpb24gKHYpIHsgcmV0dXJuIHN0ZXAoW24sIHZdKTsgfTsgfVxyXG4gICAgZnVuY3Rpb24gc3RlcChvcCkge1xyXG4gICAgICAgIGlmIChmKSB0aHJvdyBuZXcgVHlwZUVycm9yKFwiR2VuZXJhdG9yIGlzIGFscmVhZHkgZXhlY3V0aW5nLlwiKTtcclxuICAgICAgICB3aGlsZSAoXykgdHJ5IHtcclxuICAgICAgICAgICAgaWYgKGYgPSAxLCB5ICYmICh0ID0gb3BbMF0gJiAyID8geVtcInJldHVyblwiXSA6IG9wWzBdID8geVtcInRocm93XCJdIHx8ICgodCA9IHlbXCJyZXR1cm5cIl0pICYmIHQuY2FsbCh5KSwgMCkgOiB5Lm5leHQpICYmICEodCA9IHQuY2FsbCh5LCBvcFsxXSkpLmRvbmUpIHJldHVybiB0O1xyXG4gICAgICAgICAgICBpZiAoeSA9IDAsIHQpIG9wID0gW29wWzBdICYgMiwgdC52YWx1ZV07XHJcbiAgICAgICAgICAgIHN3aXRjaCAob3BbMF0pIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDogY2FzZSAxOiB0ID0gb3A7IGJyZWFrO1xyXG4gICAgICAgICAgICAgICAgY2FzZSA0OiBfLmxhYmVsKys7IHJldHVybiB7IHZhbHVlOiBvcFsxXSwgZG9uZTogZmFsc2UgfTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogXy5sYWJlbCsrOyB5ID0gb3BbMV07IG9wID0gWzBdOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNzogb3AgPSBfLm9wcy5wb3AoKTsgXy50cnlzLnBvcCgpOyBjb250aW51ZTtcclxuICAgICAgICAgICAgICAgIGRlZmF1bHQ6XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKCEodCA9IF8udHJ5cywgdCA9IHQubGVuZ3RoID4gMCAmJiB0W3QubGVuZ3RoIC0gMV0pICYmIChvcFswXSA9PT0gNiB8fCBvcFswXSA9PT0gMikpIHsgXyA9IDA7IGNvbnRpbnVlOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKG9wWzBdID09PSAzICYmICghdCB8fCAob3BbMV0gPiB0WzBdICYmIG9wWzFdIDwgdFszXSkpKSB7IF8ubGFiZWwgPSBvcFsxXTsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAob3BbMF0gPT09IDYgJiYgXy5sYWJlbCA8IHRbMV0pIHsgXy5sYWJlbCA9IHRbMV07IHQgPSBvcDsgYnJlYWs7IH1cclxuICAgICAgICAgICAgICAgICAgICBpZiAodCAmJiBfLmxhYmVsIDwgdFsyXSkgeyBfLmxhYmVsID0gdFsyXTsgXy5vcHMucHVzaChvcCk7IGJyZWFrOyB9XHJcbiAgICAgICAgICAgICAgICAgICAgaWYgKHRbMl0pIF8ub3BzLnBvcCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIF8udHJ5cy5wb3AoKTsgY29udGludWU7XHJcbiAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgb3AgPSBib2R5LmNhbGwodGhpc0FyZywgXyk7XHJcbiAgICAgICAgfSBjYXRjaCAoZSkgeyBvcCA9IFs2LCBlXTsgeSA9IDA7IH0gZmluYWxseSB7IGYgPSB0ID0gMDsgfVxyXG4gICAgICAgIGlmIChvcFswXSAmIDUpIHRocm93IG9wWzFdOyByZXR1cm4geyB2YWx1ZTogb3BbMF0gPyBvcFsxXSA6IHZvaWQgMCwgZG9uZTogdHJ1ZSB9O1xyXG4gICAgfVxyXG59XG5cbnZhciBNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvciwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yKG1lc3NhZ2UsIGJvZHksIHVybCwgc3RhY2spIHtcclxuICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgIHZhciBfYSwgX2IsIF9jO1xyXG4gICAgICAgIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcclxuICAgICAgICAvLyBNYWtlIGVycm9ycyBjb21wYXJpc29uIHBvc3NpYmxlLiBleDogZXJyb3IgaW5zdGFuY2VvZiBNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvci5cclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yLnByb3RvdHlwZSk7XHJcbiAgICAgICAgX3RoaXMubmFtZSA9ICdNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvcic7XHJcbiAgICAgICAgaWYgKGJvZHkgaW5zdGFuY2VvZiBSZXNwb25zZSkge1xyXG4gICAgICAgICAgICBfdGhpcy5tZXNzYWdlID0gYm9keS5zdGF0dXNUZXh0O1xyXG4gICAgICAgICAgICBfdGhpcy5zdGF0dXNDb2RlID0gYm9keS5zdGF0dXM7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGlmIChib2R5IGluc3RhbmNlb2YgRXJyb3IpIHtcclxuICAgICAgICAgICAgX3RoaXMuZXJybm8gPSBib2R5LmVycm5vO1xyXG4gICAgICAgICAgICBfdGhpcy5jb2RlID0gYm9keS5jb2RlO1xyXG4gICAgICAgIH1cclxuICAgICAgICBpZiAoc3RhY2spIHtcclxuICAgICAgICAgICAgX3RoaXMuc3RhY2sgPSBzdGFjaztcclxuICAgICAgICAgICAgX3RoaXMuc3RhY2sgPSAoX2EgPSBfdGhpcy5zdGFjaykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLnJlcGxhY2UoLyhUeXBlRXJyb3J8RmV0Y2hFcnJvcikvLCBfdGhpcy5uYW1lKTtcclxuICAgICAgICAgICAgX3RoaXMuc3RhY2sgPSAoX2IgPSBfdGhpcy5zdGFjaykgPT09IG51bGwgfHwgX2IgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9iLnJlcGxhY2UoJ0ZhaWxlZCB0byBmZXRjaCcsIFwicmVxdWVzdCB0byBcIi5jb25jYXQodXJsLCBcIiBmYWlsZWQsIHJlYXNvbjogY29ubmVjdCBFQ09OTlJFRlVTRURcIikpO1xyXG4gICAgICAgICAgICBfdGhpcy5zdGFjayA9IChfYyA9IF90aGlzLnN0YWNrKSA9PT0gbnVsbCB8fCBfYyA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2MucmVwbGFjZSgnTm90IEZvdW5kJywgXCJOb3QgRm91bmQ6IFwiLmNvbmNhdCh1cmwpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgZWxzZSB7XHJcbiAgICAgICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICAgICAgRXJyb3IuY2FwdHVyZVN0YWNrVHJhY2UoX3RoaXMsIE1laWxpU2VhcmNoQ29tbXVuaWNhdGlvbkVycm9yKTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3I7XHJcbn0oRXJyb3IpKTtcblxudmFyIE1laWxpU2VhcmNoQXBpRXJyb3IgPSAvKiogQGNsYXNzICovIChmdW5jdGlvbiAoX3N1cGVyKSB7XHJcbiAgICBfX2V4dGVuZHMoY2xhc3NfMSwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIGNsYXNzXzEoZXJyb3IsIHN0YXR1cykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGVycm9yLm1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgLy8gTWFrZSBlcnJvcnMgY29tcGFyaXNvbiBwb3NzaWJsZS4gZXg6IGVycm9yIGluc3RhbmNlb2YgTWVpbGlTZWFyY2hBcGlFcnJvci5cclxuICAgICAgICBPYmplY3Quc2V0UHJvdG90eXBlT2YoX3RoaXMsIE1laWxpU2VhcmNoQXBpRXJyb3IucHJvdG90eXBlKTtcclxuICAgICAgICBfdGhpcy5uYW1lID0gJ01laWxpU2VhcmNoQXBpRXJyb3InO1xyXG4gICAgICAgIF90aGlzLmNvZGUgPSBlcnJvci5jb2RlO1xyXG4gICAgICAgIF90aGlzLnR5cGUgPSBlcnJvci50eXBlO1xyXG4gICAgICAgIF90aGlzLmxpbmsgPSBlcnJvci5saW5rO1xyXG4gICAgICAgIF90aGlzLm1lc3NhZ2UgPSBlcnJvci5tZXNzYWdlO1xyXG4gICAgICAgIF90aGlzLmh0dHBTdGF0dXMgPSBzdGF0dXM7XHJcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBNZWlsaVNlYXJjaEFwaUVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGNsYXNzXzE7XHJcbn0oRXJyb3IpKTtcblxuZnVuY3Rpb24gaHR0cFJlc3BvbnNlRXJyb3JIYW5kbGVyKHJlc3BvbnNlKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgdmFyIHJlc3BvbnNlQm9keTtcclxuICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICBpZiAoISFyZXNwb25zZS5vaykgcmV0dXJuIFszIC8qYnJlYWsqLywgNV07XHJcbiAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2VCb2R5ID0gdm9pZCAwO1xyXG4gICAgICAgICAgICAgICAgICAgIF9hLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzEsIDMsICwgNF0pO1xyXG4gICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHJlc3BvbnNlLmpzb24oKV07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSWYgaXQgaXMgbm90IHBvc3NpYmxlIHRvIHBhcnNlIHRoZSByZXR1cm4gYm9keSBpdCBtZWFucyB0aGVyZSBpcyBub25lXHJcbiAgICAgICAgICAgICAgICAgICAgLy8gSW4gd2hpY2ggY2FzZSBpdCBpcyBhIGNvbW11bmljYXRpb24gZXJyb3Igd2l0aCB0aGUgTWVpbGlzZWFyY2ggaW5zdGFuY2VcclxuICAgICAgICAgICAgICAgICAgICByZXNwb25zZUJvZHkgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgIC8vIE5vdCBzdXJlIG9uIGhvdyB0byB0ZXN0IHRoaXMgcGFydCBvZiB0aGUgY29kZS5cclxuICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IocmVzcG9uc2Uuc3RhdHVzVGV4dCwgcmVzcG9uc2UsIHJlc3BvbnNlLnVybCk7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDQ6IFxyXG4gICAgICAgICAgICAgICAgLy8gSWYgdGhlIGJvZHkgaXMgcGFyc2FibGUsIHRoZW4gaXQgbWVhbnMgTWVpbGlzZWFyY2ggcmV0dXJuZWQgYSBib2R5IHdpdGhcclxuICAgICAgICAgICAgICAgIC8vIGluZm9ybWF0aW9uIG9uIHRoZSBlcnJvci5cclxuICAgICAgICAgICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaEFwaUVycm9yKHJlc3BvbnNlQm9keSwgcmVzcG9uc2Uuc3RhdHVzKTtcclxuICAgICAgICAgICAgICAgIGNhc2UgNTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gaHR0cEVycm9ySGFuZGxlcihyZXNwb25zZSwgc3RhY2ssIHVybCkge1xyXG4gICAgaWYgKHJlc3BvbnNlLm5hbWUgIT09ICdNZWlsaVNlYXJjaEFwaUVycm9yJykge1xyXG4gICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaENvbW11bmljYXRpb25FcnJvcihyZXNwb25zZS5tZXNzYWdlLCByZXNwb25zZSwgdXJsLCBzdGFjayk7XHJcbiAgICB9XHJcbiAgICB0aHJvdyByZXNwb25zZTtcclxufVxuXG52YXIgTWVpbGlTZWFyY2hFcnJvciA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNZWlsaVNlYXJjaEVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWVpbGlTZWFyY2hFcnJvcihtZXNzYWdlKSB7XHJcbiAgICAgICAgdmFyIF90aGlzID0gX3N1cGVyLmNhbGwodGhpcywgbWVzc2FnZSkgfHwgdGhpcztcclxuICAgICAgICAvLyBNYWtlIGVycm9ycyBjb21wYXJpc29uIHBvc3NpYmxlLiBleDogZXJyb3IgaW5zdGFuY2VvZiBNZWlsaVNlYXJjaEVycm9yLlxyXG4gICAgICAgIE9iamVjdC5zZXRQcm90b3R5cGVPZihfdGhpcywgTWVpbGlTZWFyY2hFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hFcnJvcic7XHJcbiAgICAgICAgaWYgKEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKSB7XHJcbiAgICAgICAgICAgIEVycm9yLmNhcHR1cmVTdGFja1RyYWNlKF90aGlzLCBNZWlsaVNlYXJjaEVycm9yKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF90aGlzO1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIE1laWxpU2VhcmNoRXJyb3I7XHJcbn0oRXJyb3IpKTtcblxudmFyIE1laWxpU2VhcmNoVGltZU91dEVycm9yID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKF9zdXBlcikge1xyXG4gICAgX19leHRlbmRzKE1laWxpU2VhcmNoVGltZU91dEVycm9yLCBfc3VwZXIpO1xyXG4gICAgZnVuY3Rpb24gTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IobWVzc2FnZSkge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIG1lc3NhZ2UpIHx8IHRoaXM7XHJcbiAgICAgICAgLy8gTWFrZSBlcnJvcnMgY29tcGFyaXNvbiBwb3NzaWJsZS4gZXg6IGVycm9yIGluc3RhbmNlb2YgTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IuXHJcbiAgICAgICAgT2JqZWN0LnNldFByb3RvdHlwZU9mKF90aGlzLCBNZWlsaVNlYXJjaFRpbWVPdXRFcnJvci5wcm90b3R5cGUpO1xyXG4gICAgICAgIF90aGlzLm5hbWUgPSAnTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3InO1xyXG4gICAgICAgIGlmIChFcnJvci5jYXB0dXJlU3RhY2tUcmFjZSkge1xyXG4gICAgICAgICAgICBFcnJvci5jYXB0dXJlU3RhY2tUcmFjZShfdGhpcywgTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3IpO1xyXG4gICAgICAgIH1cclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gTWVpbGlTZWFyY2hUaW1lT3V0RXJyb3I7XHJcbn0oRXJyb3IpKTtcblxuLyoqIFJlbW92ZXMgdW5kZWZpbmVkIGVudHJpZXMgZnJvbSBvYmplY3QgKi9cclxuZnVuY3Rpb24gcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdChvYmopIHtcclxuICAgIHJldHVybiBPYmplY3QuZW50cmllcyhvYmopLnJlZHVjZShmdW5jdGlvbiAoYWNjLCBjdXJFbnRyeSkge1xyXG4gICAgICAgIHZhciBrZXkgPSBjdXJFbnRyeVswXSwgdmFsID0gY3VyRW50cnlbMV07XHJcbiAgICAgICAgaWYgKHZhbCAhPT0gdW5kZWZpbmVkKVxyXG4gICAgICAgICAgICBhY2Nba2V5XSA9IHZhbDtcclxuICAgICAgICByZXR1cm4gYWNjO1xyXG4gICAgfSwge30pO1xyXG59XHJcbmZ1bmN0aW9uIHNsZWVwKG1zKSB7XHJcbiAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBQcm9taXNlKGZ1bmN0aW9uIChyZXNvbHZlKSB7IHJldHVybiBzZXRUaW1lb3V0KHJlc29sdmUsIG1zKTsgfSldO1xyXG4gICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgfVxyXG4gICAgICAgIH0pO1xyXG4gICAgfSk7XHJcbn1cclxuZnVuY3Rpb24gYWRkUHJvdG9jb2xJZk5vdFByZXNlbnQoaG9zdCkge1xyXG4gICAgaWYgKCEoaG9zdC5zdGFydHNXaXRoKCdodHRwczovLycpIHx8IGhvc3Quc3RhcnRzV2l0aCgnaHR0cDovLycpKSkge1xyXG4gICAgICAgIHJldHVybiBcImh0dHA6Ly9cIi5jb25jYXQoaG9zdCk7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gaG9zdDtcclxufVxyXG5mdW5jdGlvbiBhZGRUcmFpbGluZ1NsYXNoKHVybCkge1xyXG4gICAgaWYgKCF1cmwuZW5kc1dpdGgoJy8nKSkge1xyXG4gICAgICAgIHVybCArPSAnLyc7XHJcbiAgICB9XHJcbiAgICByZXR1cm4gdXJsO1xyXG59XHJcbmZ1bmN0aW9uIHZhbGlkYXRlVXVpZDQodXVpZCkge1xyXG4gICAgdmFyIHJlZ2V4RXhwID0gL15bMC05YS1mQS1GXXs4fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXs0fVxcYi1bMC05YS1mQS1GXXsxMn0kL2dpO1xyXG4gICAgcmV0dXJuIHJlZ2V4RXhwLnRlc3QodXVpZCk7XHJcbn1cblxudmFyIFBBQ0tBR0VfVkVSU0lPTiA9ICcwLjMxLjEnO1xuXG5mdW5jdGlvbiB0b1F1ZXJ5UGFyYW1zKHBhcmFtZXRlcnMpIHtcclxuICAgIHZhciBwYXJhbXMgPSBPYmplY3Qua2V5cyhwYXJhbWV0ZXJzKTtcclxuICAgIHZhciBxdWVyeVBhcmFtcyA9IHBhcmFtcy5yZWR1Y2UoZnVuY3Rpb24gKGFjYywga2V5KSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2M7XHJcbiAgICAgICAgdmFyIHZhbHVlID0gcGFyYW1ldGVyc1trZXldO1xyXG4gICAgICAgIGlmICh2YWx1ZSA9PT0gdW5kZWZpbmVkKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBhY2M7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkodmFsdWUpKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2Fzc2lnbihfX2Fzc2lnbih7fSwgYWNjKSwgKF9hID0ge30sIF9hW2tleV0gPSB2YWx1ZS5qb2luKCcsJyksIF9hKSk7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKHZhbHVlIGluc3RhbmNlb2YgRGF0ZSkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19hc3NpZ24oX19hc3NpZ24oe30sIGFjYyksIChfYiA9IHt9LCBfYltrZXldID0gdmFsdWUudG9JU09TdHJpbmcoKSwgX2IpKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXNzaWduKF9fYXNzaWduKHt9LCBhY2MpLCAoX2MgPSB7fSwgX2Nba2V5XSA9IHZhbHVlLCBfYykpO1xyXG4gICAgfSwge30pO1xyXG4gICAgcmV0dXJuIHF1ZXJ5UGFyYW1zO1xyXG59XHJcbmZ1bmN0aW9uIGNvbnN0cnVjdEhvc3RVUkwoaG9zdCkge1xyXG4gICAgdHJ5IHtcclxuICAgICAgICBob3N0ID0gYWRkUHJvdG9jb2xJZk5vdFByZXNlbnQoaG9zdCk7XHJcbiAgICAgICAgaG9zdCA9IGFkZFRyYWlsaW5nU2xhc2goaG9zdCk7XHJcbiAgICAgICAgcmV0dXJuIGhvc3Q7XHJcbiAgICB9XHJcbiAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaEVycm9yKCdUaGUgcHJvdmlkZWQgaG9zdCBpcyBub3QgdmFsaWQuJyk7XHJcbiAgICB9XHJcbn1cclxuZnVuY3Rpb24gY3JlYXRlSGVhZGVycyhjb25maWcpIHtcclxuICAgIHZhciBhZ2VudEhlYWRlciA9ICdYLU1laWxpc2VhcmNoLUNsaWVudCc7XHJcbiAgICB2YXIgcGFja2FnZUFnZW50ID0gXCJNZWlsaXNlYXJjaCBKYXZhU2NyaXB0ICh2XCIuY29uY2F0KFBBQ0tBR0VfVkVSU0lPTiwgXCIpXCIpO1xyXG4gICAgdmFyIGNvbnRlbnRUeXBlID0gJ0NvbnRlbnQtVHlwZSc7XHJcbiAgICBjb25maWcuaGVhZGVycyA9IGNvbmZpZy5oZWFkZXJzIHx8IHt9O1xyXG4gICAgdmFyIGhlYWRlcnMgPSBPYmplY3QuYXNzaWduKHt9LCBjb25maWcuaGVhZGVycyk7IC8vIENyZWF0ZSBhIGhhcmQgY29weSBhbmQgbm90IGEgcmVmZXJlbmNlIHRvIGNvbmZpZy5oZWFkZXJzXHJcbiAgICBpZiAoY29uZmlnLmFwaUtleSkge1xyXG4gICAgICAgIGhlYWRlcnNbJ0F1dGhvcml6YXRpb24nXSA9IFwiQmVhcmVyIFwiLmNvbmNhdChjb25maWcuYXBpS2V5KTtcclxuICAgIH1cclxuICAgIGlmICghY29uZmlnLmhlYWRlcnNbY29udGVudFR5cGVdKSB7XHJcbiAgICAgICAgaGVhZGVyc1snQ29udGVudC1UeXBlJ10gPSAnYXBwbGljYXRpb24vanNvbic7XHJcbiAgICB9XHJcbiAgICAvLyBDcmVhdGVzIHRoZSBjdXN0b20gdXNlciBhZ2VudCB3aXRoIGluZm9ybWF0aW9uIG9uIHRoZSBwYWNrYWdlIHVzZWQuXHJcbiAgICBpZiAoY29uZmlnLmNsaWVudEFnZW50cyAmJiBBcnJheS5pc0FycmF5KGNvbmZpZy5jbGllbnRBZ2VudHMpKSB7XHJcbiAgICAgICAgdmFyIGNsaWVudHMgPSBjb25maWcuY2xpZW50QWdlbnRzLmNvbmNhdChwYWNrYWdlQWdlbnQpO1xyXG4gICAgICAgIGhlYWRlcnNbYWdlbnRIZWFkZXJdID0gY2xpZW50cy5qb2luKCcgOyAnKTtcclxuICAgIH1cclxuICAgIGVsc2UgaWYgKGNvbmZpZy5jbGllbnRBZ2VudHMgJiYgIUFycmF5LmlzQXJyYXkoY29uZmlnLmNsaWVudEFnZW50cykpIHtcclxuICAgICAgICAvLyBJZiB0aGUgaGVhZGVyIGlzIGRlZmluZWQgYnV0IG5vdCBhbiBhcnJheVxyXG4gICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaEVycm9yKFwiTWVpbGlzZWFyY2g6IFRoZSBoZWFkZXIgXFxcIlwiLmNvbmNhdChhZ2VudEhlYWRlciwgXCJcXFwiIHNob3VsZCBiZSBhbiBhcnJheSBvZiBzdHJpbmcocykuXFxuXCIpKTtcclxuICAgIH1cclxuICAgIGVsc2Uge1xyXG4gICAgICAgIGhlYWRlcnNbYWdlbnRIZWFkZXJdID0gcGFja2FnZUFnZW50O1xyXG4gICAgfVxyXG4gICAgcmV0dXJuIGhlYWRlcnM7XHJcbn1cclxudmFyIEh0dHBSZXF1ZXN0cyA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIEh0dHBSZXF1ZXN0cyhjb25maWcpIHtcclxuICAgICAgICB0aGlzLmhlYWRlcnMgPSBjcmVhdGVIZWFkZXJzKGNvbmZpZyk7XHJcbiAgICAgICAgdHJ5IHtcclxuICAgICAgICAgICAgdmFyIGhvc3QgPSBjb25zdHJ1Y3RIb3N0VVJMKGNvbmZpZy5ob3N0KTtcclxuICAgICAgICAgICAgdGhpcy51cmwgPSBuZXcgVVJMKGhvc3QpO1xyXG4gICAgICAgIH1cclxuICAgICAgICBjYXRjaCAoZSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcignVGhlIHByb3ZpZGVkIGhvc3QgaXMgbm90IHZhbGlkLicpO1xyXG4gICAgICAgIH1cclxuICAgIH1cclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucmVxdWVzdCA9IGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgIHZhciBtZXRob2QgPSBfYS5tZXRob2QsIHVybCA9IF9hLnVybCwgcGFyYW1zID0gX2EucGFyYW1zLCBib2R5ID0gX2EuYm9keSwgY29uZmlnID0gX2EuY29uZmlnO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIGNvbnN0cnVjdFVSTCwgcXVlcnlQYXJhbXNfMSwgcmVzcG9uc2UsIHBhcnNlZEJvZHksIGVfMSwgc3RhY2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2IpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2IubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGNvbnN0cnVjdFVSTCA9IG5ldyBVUkwodXJsLCB0aGlzLnVybCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChwYXJhbXMpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHF1ZXJ5UGFyYW1zXzEgPSBuZXcgVVJMU2VhcmNoUGFyYW1zKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBPYmplY3Qua2V5cyhwYXJhbXMpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgLmZpbHRlcihmdW5jdGlvbiAoeCkgeyByZXR1cm4gcGFyYW1zW3hdICE9PSBudWxsOyB9KVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgIC5tYXAoZnVuY3Rpb24gKHgpIHsgcmV0dXJuIHF1ZXJ5UGFyYW1zXzEuc2V0KHgsIHBhcmFtc1t4XSk7IH0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uc3RydWN0VVJMLnNlYXJjaCA9IHF1ZXJ5UGFyYW1zXzEudG9TdHJpbmcoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi50cnlzLnB1c2goWzEsIDQsICwgNV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCBmZXRjaChjb25zdHJ1Y3RVUkwudG9TdHJpbmcoKSwgX19hc3NpZ24oX19hc3NpZ24oe30sIGNvbmZpZyksIHsgbWV0aG9kOiBtZXRob2QsIGJvZHk6IEpTT04uc3RyaW5naWZ5KGJvZHkpLCBoZWFkZXJzOiB0aGlzLmhlYWRlcnMgfSkpLnRoZW4oZnVuY3Rpb24gKHJlcykgeyByZXR1cm4gaHR0cFJlc3BvbnNlRXJyb3JIYW5kbGVyKHJlcyk7IH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDI6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlc3BvbnNlID0gX2Iuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXNwb25zZS5qc29uKClbXCJjYXRjaFwiXShmdW5jdGlvbiAoKSB7IHJldHVybiB1bmRlZmluZWQ7IH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHBhcnNlZEJvZHkgPSBfYi5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBwYXJzZWRCb2R5XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGVfMSA9IF9iLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhY2sgPSBlXzEuc3RhY2s7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGh0dHBFcnJvckhhbmRsZXIoZV8xLCBzdGFjaywgY29uc3RydWN0VVJMLnRvU3RyaW5nKCkpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCA1XTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDU6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgSHR0cFJlcXVlc3RzLnByb3RvdHlwZS5nZXQgPSBmdW5jdGlvbiAodXJsLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0dFVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucG9zdCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHBhcmFtcywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUE9TVCcsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICBIdHRwUmVxdWVzdHMucHJvdG90eXBlLnB1dCA9IGZ1bmN0aW9uICh1cmwsIGRhdGEsIHBhcmFtcywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnJlcXVlc3Qoe1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgbWV0aG9kOiAnUFVUJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGUucGF0Y2ggPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ1BBVENIJyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHVybDogdXJsLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgYm9keTogZGF0YSxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHBhcmFtczogcGFyYW1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgY29uZmlnOiBjb25maWdcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIEh0dHBSZXF1ZXN0cy5wcm90b3R5cGVbXCJkZWxldGVcIl0gPSBmdW5jdGlvbiAodXJsLCBkYXRhLCBwYXJhbXMsIGNvbmZpZykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5yZXF1ZXN0KHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIG1ldGhvZDogJ0RFTEVURScsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB1cmw6IHVybCxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJvZHk6IGRhdGEsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBwYXJhbXM6IHBhcmFtcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGNvbmZpZzogY29uZmlnXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSHR0cFJlcXVlc3RzO1xyXG59KCkpO1xuXG52YXIgRW5xdWV1ZWRUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gRW5xdWV1ZWRUYXNrKHRhc2spIHtcclxuICAgICAgICB0aGlzLnRhc2tVaWQgPSB0YXNrLnRhc2tVaWQ7XHJcbiAgICAgICAgdGhpcy5pbmRleFVpZCA9IHRhc2suaW5kZXhVaWQ7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB0YXNrLnN0YXR1cztcclxuICAgICAgICB0aGlzLnR5cGUgPSB0YXNrLnR5cGU7XHJcbiAgICAgICAgdGhpcy5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBFbnF1ZXVlZFRhc2s7XHJcbn0oKSk7XG5cbnZhciBUYXNrID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVGFzayh0YXNrKSB7XHJcbiAgICAgICAgdGhpcy5pbmRleFVpZCA9IHRhc2suaW5kZXhVaWQ7XHJcbiAgICAgICAgdGhpcy5zdGF0dXMgPSB0YXNrLnN0YXR1cztcclxuICAgICAgICB0aGlzLnR5cGUgPSB0YXNrLnR5cGU7XHJcbiAgICAgICAgdGhpcy51aWQgPSB0YXNrLnVpZDtcclxuICAgICAgICB0aGlzLmRldGFpbHMgPSB0YXNrLmRldGFpbHM7XHJcbiAgICAgICAgdGhpcy5jYW5jZWxlZEJ5ID0gdGFzay5jYW5jZWxlZEJ5O1xyXG4gICAgICAgIHRoaXMuZXJyb3IgPSB0YXNrLmVycm9yO1xyXG4gICAgICAgIHRoaXMuZHVyYXRpb24gPSB0YXNrLmR1cmF0aW9uO1xyXG4gICAgICAgIHRoaXMuc3RhcnRlZEF0ID0gbmV3IERhdGUodGFzay5zdGFydGVkQXQpO1xyXG4gICAgICAgIHRoaXMuZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XHJcbiAgICAgICAgdGhpcy5maW5pc2hlZEF0ID0gbmV3IERhdGUodGFzay5maW5pc2hlZEF0KTtcclxuICAgIH1cclxuICAgIHJldHVybiBUYXNrO1xyXG59KCkpO1xyXG52YXIgVGFza0NsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIGZ1bmN0aW9uIFRhc2tDbGllbnQoY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5odHRwUmVxdWVzdCA9IG5ldyBIdHRwUmVxdWVzdHMoY29uZmlnKTtcclxuICAgIH1cclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9uZSB0YXNrXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVpZCAtIFVuaXF1ZSBpZGVudGlmaWVyIG9mIHRoZSB0YXNrXHJcbiAgICAgKiBAcmV0dXJuc1xyXG4gICAgICovXHJcbiAgICBUYXNrQ2xpZW50LnByb3RvdHlwZS5nZXRUYXNrID0gZnVuY3Rpb24gKHVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFza0l0ZW07XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwidGFza3MvXCIuY29uY2F0KHVpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza0l0ZW0gPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgVGFzayh0YXNrSXRlbSldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCB0YXNrc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVycyB0byBicm93c2UgdGhlIHRhc2tzXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYWxsIHRhc2tzXHJcbiAgICAgKi9cclxuICAgIFRhc2tDbGllbnQucHJvdG90eXBlLmdldFRhc2tzID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICBpZiAocGFyYW1ldGVycyA9PT0gdm9pZCAwKSB7IHBhcmFtZXRlcnMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFza3M7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwidGFza3NcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsLCB0b1F1ZXJ5UGFyYW1zKHBhcmFtZXRlcnMpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrcyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9fYXNzaWduKF9fYXNzaWduKHt9LCB0YXNrcyksIHsgcmVzdWx0czogdGFza3MucmVzdWx0cy5tYXAoZnVuY3Rpb24gKHRhc2spIHsgcmV0dXJuIG5ldyBUYXNrKHRhc2spOyB9KSB9KV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FpdCBmb3IgYSB0YXNrIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFza1VpZCAtIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBBZGRpdGlvbmFsIGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgYSB0YXNrIGFmdGVyIGl0IGhhcyBiZWVuIHByb2Nlc3NlZFxyXG4gICAgICovXHJcbiAgICBUYXNrQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9yVGFzayA9IGZ1bmN0aW9uICh0YXNrVWlkLCBfYSkge1xyXG4gICAgICAgIHZhciBfYiA9IF9hID09PSB2b2lkIDAgPyB7fSA6IF9hLCBfYyA9IF9iLnRpbWVPdXRNcywgdGltZU91dE1zID0gX2MgPT09IHZvaWQgMCA/IDUwMDAgOiBfYywgX2QgPSBfYi5pbnRlcnZhbE1zLCBpbnRlcnZhbE1zID0gX2QgPT09IHZvaWQgMCA/IDUwIDogX2Q7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgc3RhcnRpbmdUaW1lLCByZXNwb25zZTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgc3RhcnRpbmdUaW1lID0gRGF0ZS5ub3coKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAxO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaWYgKCEoRGF0ZS5ub3coKSAtIHN0YXJ0aW5nVGltZSA8IHRpbWVPdXRNcykpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFRhc2sodGFza1VpZCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVzcG9uc2UgPSBfZS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghW1wiZW5xdWV1ZWRcIiAvKiBUYXNrU3RhdHVzLlRBU0tfRU5RVUVVRUQgKi8sIFwicHJvY2Vzc2luZ1wiIC8qIFRhc2tTdGF0dXMuVEFTS19QUk9DRVNTSU5HICovXS5pbmNsdWRlcyhyZXNwb25zZS5zdGF0dXMpKVxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHJlc3BvbnNlXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgc2xlZXAoaW50ZXJ2YWxNcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Uuc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzMgLypicmVhayovLCAxXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDQ6IHRocm93IG5ldyBNZWlsaVNlYXJjaFRpbWVPdXRFcnJvcihcInRpbWVvdXQgb2YgXCIuY29uY2F0KHRpbWVPdXRNcywgXCJtcyBoYXMgZXhjZWVkZWQgb24gcHJvY2VzcyBcIikuY29uY2F0KHRhc2tVaWQsIFwiIHdoZW4gd2FpdGluZyBhIHRhc2sgdG8gYmUgcmVzb2x2ZWQuXCIpKTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0cyBmb3IgbXVsdGlwbGUgdGFza3MgdG8gYmUgcHJvY2Vzc2VkXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhc2tVaWRzIC0gVGFza3MgaWRlbnRpZmllciBsaXN0XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFdhaXQgb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgYSBsaXN0IG9mIHRhc2tzIGFmdGVyIHRoZXkgaGF2ZSBiZWVuIHByb2Nlc3NlZFxyXG4gICAgICovXHJcbiAgICBUYXNrQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9yVGFza3MgPSBmdW5jdGlvbiAodGFza1VpZHMsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB0YXNrcywgX2ksIHRhc2tVaWRzXzEsIHRhc2tVaWQsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9pID0gMCwgdGFza1VpZHNfMSA9IHRhc2tVaWRzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfZS5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShfaSA8IHRhc2tVaWRzXzEubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2tVaWQgPSB0YXNrVWlkc18xW19pXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy53YWl0Rm9yVGFzayh0YXNrVWlkLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dE1zOiB0aW1lT3V0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9lLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFza3MucHVzaCh0YXNrKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2UubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2krKztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdGFza3NdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbCBhIGxpc3Qgb2YgZW5xdWV1ZWQgb3IgcHJvY2Vzc2luZyB0YXNrcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyAtIFBhcmFtZXRlcnMgdG8gZmlsdGVyIHRoZSB0YXNrcy5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAqL1xyXG4gICAgVGFza0NsaWVudC5wcm90b3R5cGUuY2FuY2VsVGFza3MgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xyXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB2b2lkIDApIHsgcGFyYW1ldGVycyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcInRhc2tzL2NhbmNlbFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCB7fSwgdG9RdWVyeVBhcmFtcyhwYXJhbWV0ZXJzKSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBhIGxpc3QgdGFza3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJzIHRvIGZpbHRlciB0aGUgdGFza3MuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIFRhc2tDbGllbnQucHJvdG90eXBlLmRlbGV0ZVRhc2tzID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICBpZiAocGFyYW1ldGVycyA9PT0gdm9pZCAwKSB7IHBhcmFtZXRlcnMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJ0YXNrc1wiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCwge30sIHRvUXVlcnlQYXJhbXMocGFyYW1ldGVycykpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIFRhc2tDbGllbnQ7XHJcbn0oKSk7XG5cbi8qXHJcbiAqIEJ1bmRsZTogTWVpbGlTZWFyY2ggLyBJbmRleGVzXHJcbiAqIFByb2plY3Q6IE1laWxpU2VhcmNoIC0gSmF2YXNjcmlwdCBBUElcclxuICogQXV0aG9yOiBRdWVudGluIGRlIFF1ZWxlbiA8cXVlbnRpbkBtZWlsaXNlYXJjaC5jb20+XHJcbiAqIENvcHlyaWdodDogMjAxOSwgTWVpbGlTZWFyY2hcclxuICovXHJcbnZhciBJbmRleCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFJlcXVlc3QgY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gdWlkIC0gVUlEIG9mIHRoZSBpbmRleFxyXG4gICAgICogQHBhcmFtIHByaW1hcnlLZXkgLSBQcmltYXJ5IEtleSBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gSW5kZXgoY29uZmlnLCB1aWQsIHByaW1hcnlLZXkpIHtcclxuICAgICAgICB0aGlzLnVpZCA9IHVpZDtcclxuICAgICAgICB0aGlzLnByaW1hcnlLZXkgPSBwcmltYXJ5S2V5O1xyXG4gICAgICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBuZXcgSHR0cFJlcXVlc3RzKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy50YXNrcyA9IG5ldyBUYXNrQ2xpZW50KGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICAvLy9cclxuICAgIC8vLyBTRUFSQ0hcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2ggZm9yIGRvY3VtZW50cyBpbnRvIGFuIGluZGV4XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gUXVlcnkgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFNlYXJjaCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQWRkaXRpb25hbCByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBzZWFyY2ggcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnNlYXJjaCA9IGZ1bmN0aW9uIChxdWVyeSwgb3B0aW9ucywgY29uZmlnKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZWFyY2hcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwsIHJlbW92ZVVuZGVmaW5lZEZyb21PYmplY3QoX19hc3NpZ24oeyBxOiBxdWVyeSB9LCBvcHRpb25zKSksIHVuZGVmaW5lZCwgY29uZmlnKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTZWFyY2ggZm9yIGRvY3VtZW50cyBpbnRvIGFuIGluZGV4IHVzaW5nIHRoZSBHRVQgbWV0aG9kXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHF1ZXJ5IC0gUXVlcnkgc3RyaW5nXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFNlYXJjaCBvcHRpb25zXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQWRkaXRpb25hbCByZXF1ZXN0IGNvbmZpZ3VyYXRpb24gb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBzZWFyY2ggcmVzcG9uc2VcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnNlYXJjaEdldCA9IGZ1bmN0aW9uIChxdWVyeSwgb3B0aW9ucywgY29uZmlnKSB7XHJcbiAgICAgICAgdmFyIF9hLCBfYiwgX2MsIF9kLCBfZTtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHBhcnNlRmlsdGVyLCBnZXRQYXJhbXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2YpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2YubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NlYXJjaFwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcGFyc2VGaWx0ZXIgPSBmdW5jdGlvbiAoZmlsdGVyKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpZiAodHlwZW9mIGZpbHRlciA9PT0gJ3N0cmluZycpXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIGZpbHRlcjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2UgaWYgKEFycmF5LmlzQXJyYXkoZmlsdGVyKSlcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcignVGhlIGZpbHRlciBxdWVyeSBwYXJhbWV0ZXIgc2hvdWxkIGJlIGluIHN0cmluZyBmb3JtYXQgd2hlbiB1c2luZyBzZWFyY2hHZXQnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGVsc2VcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gdW5kZWZpbmVkO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9O1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBnZXRQYXJhbXMgPSBfX2Fzc2lnbihfX2Fzc2lnbih7IHE6IHF1ZXJ5IH0sIG9wdGlvbnMpLCB7IGZpbHRlcjogcGFyc2VGaWx0ZXIob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmZpbHRlciksIHNvcnQ6IChfYSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5zb3J0KSA9PT0gbnVsbCB8fCBfYSA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Euam9pbignLCcpLCBmYWNldHM6IChfYiA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5mYWNldHMpID09PSBudWxsIHx8IF9iID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYi5qb2luKCcsJyksIGF0dHJpYnV0ZXNUb1JldHJpZXZlOiAoX2MgPSBvcHRpb25zID09PSBudWxsIHx8IG9wdGlvbnMgPT09IHZvaWQgMCA/IHZvaWQgMCA6IG9wdGlvbnMuYXR0cmlidXRlc1RvUmV0cmlldmUpID09PSBudWxsIHx8IF9jID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfYy5qb2luKCcsJyksIGF0dHJpYnV0ZXNUb0Nyb3A6IChfZCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzVG9Dcm9wKSA9PT0gbnVsbCB8fCBfZCA9PT0gdm9pZCAwID8gdm9pZCAwIDogX2Quam9pbignLCcpLCBhdHRyaWJ1dGVzVG9IaWdobGlnaHQ6IChfZSA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5hdHRyaWJ1dGVzVG9IaWdobGlnaHQpID09PSBudWxsIHx8IF9lID09PSB2b2lkIDAgPyB2b2lkIDAgOiBfZS5qb2luKCcsJykgfSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdChnZXRQYXJhbXMpLCBjb25maWcpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfZi5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBJTkRFWFxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCBpbmRleCBpbmZvcm1hdGlvbi5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgaW5kZXggaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFJhd0luZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCByZXM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlcyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGhpcy5wcmltYXJ5S2V5ID0gcmVzLnByaW1hcnlLZXk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMudXBkYXRlZEF0ID0gbmV3IERhdGUocmVzLnVwZGF0ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRoaXMuY3JlYXRlZEF0ID0gbmV3IERhdGUocmVzLmNyZWF0ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCByZXNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEZldGNoIGFuZCB1cGRhdGUgSW5kZXggaW5mb3JtYXRpb24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB0byB0aGUgY3VycmVudCBJbmRleCBvYmplY3Qgd2l0aCB1cGRhdGVkIGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5mZXRjaEluZm8gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJhd0luZm8oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0aGlzXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgUHJpbWFyeSBLZXkuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIHRoZSBQcmltYXJ5IEtleSBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmZldGNoUHJpbWFyeUtleSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciBfYTtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYikge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYi5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2EgPSB0aGlzO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJhd0luZm8oKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5wcmltYXJ5S2V5ID0gKF9iLnNlbnQoKSkucHJpbWFyeUtleTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRoaXMucHJpbWFyeUtleV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGFuIGluZGV4LlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1aWQgLSBVbmlxdWUgaWRlbnRpZmllciBvZiB0aGUgSW5kZXhcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gSW5kZXggb3B0aW9uc1xyXG4gICAgICogQHBhcmFtIGNvbmZpZyAtIFJlcXVlc3QgY29uZmlndXJhdGlvbiBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyBOZXdseSBjcmVhdGVkIEluZGV4IG9iamVjdFxyXG4gICAgICovXHJcbiAgICBJbmRleC5jcmVhdGUgPSBmdW5jdGlvbiAodWlkLCBvcHRpb25zLCBjb25maWcpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgcmVxLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmVxID0gbmV3IEh0dHBSZXF1ZXN0cyhjb25maWcpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCByZXEucG9zdCh1cmwsIF9fYXNzaWduKF9fYXNzaWduKHt9LCBvcHRpb25zKSwgeyB1aWQ6IHVpZCB9KSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhbiBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZGF0YSAtIERhdGEgdG8gdXBkYXRlXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHRvIHRoZSBjdXJyZW50IEluZGV4IG9iamVjdCB3aXRoIHVwZGF0ZWQgaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZSA9IGZ1bmN0aW9uIChkYXRhKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wYXRjaCh1cmwsIGRhdGEpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0YXNrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYW4gaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSB3aGljaCByZXNvbHZlcyB3aGVuIGluZGV4IGlzIGRlbGV0ZWQgc3VjY2Vzc2Z1bGx5XHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZVtcImRlbGV0ZVwiXSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBUQVNLU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgbGlzdCBvZiBhbGwgdGhlIHRhc2tzIG9mIHRoZSBpbmRleC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyAtIFBhcmFtZXRlcnMgdG8gYnJvd3NlIHRoZSB0YXNrc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFsbCB0YXNrc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0VGFza3MgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xyXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB2b2lkIDApIHsgcGFyYW1ldGVycyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldFRhc2tzKF9fYXNzaWduKF9fYXNzaWduKHt9LCBwYXJhbWV0ZXJzKSwgeyBpbmRleFVpZHM6IFt0aGlzLnVpZF0gfSkpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvbmUgdGFzayBvZiB0aGUgaW5kZXguXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhc2tVaWQgLSBUYXNrIGlkZW50aWZpZXJcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhIHRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFRhc2sgPSBmdW5jdGlvbiAodGFza1VpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50YXNrcy5nZXRUYXNrKHRhc2tVaWQpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFdhaXQgZm9yIG11bHRpcGxlIHRhc2tzIHRvIGJlIHByb2Nlc3NlZC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFza1VpZHMgLSBUYXNrcyBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLndhaXRGb3JUYXNrcyA9IGZ1bmN0aW9uICh0YXNrVWlkcywgX2EpIHtcclxuICAgICAgICB2YXIgX2IgPSBfYSA9PT0gdm9pZCAwID8ge30gOiBfYSwgX2MgPSBfYi50aW1lT3V0TXMsIHRpbWVPdXRNcyA9IF9jID09PSB2b2lkIDAgPyA1MDAwIDogX2MsIF9kID0gX2IuaW50ZXJ2YWxNcywgaW50ZXJ2YWxNcyA9IF9kID09PSB2b2lkIDAgPyA1MCA6IF9kO1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfZSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfZS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy50YXNrcy53YWl0Rm9yVGFza3ModGFza1VpZHMsIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHRpbWVPdXRNczogdGltZU91dE1zLFxyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaW50ZXJ2YWxNczogaW50ZXJ2YWxNc1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9KV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Uuc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBXYWl0IGZvciBhIHRhc2sgdG8gYmUgcHJvY2Vzc2VkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXNrVWlkIC0gVGFzayBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLndhaXRGb3JUYXNrID0gZnVuY3Rpb24gKHRhc2tVaWQsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvclRhc2sodGFza1VpZCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dE1zOiB0aW1lT3V0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbE1zOiBpbnRlcnZhbE1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfZS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBTVEFUU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCBzdGF0cyBvZiBhbiBpbmRleFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgd2l0aCBzdGF0cyBvZiB0aGUgaW5kZXhcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFN0YXRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc3RhdHNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIERPQ1VNRU5UU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCBkb2N1bWVudHMgb2YgYW4gaW5kZXhcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyAtIFBhcmFtZXRlcnMgdG8gYnJvd3NlIHRoZSBkb2N1bWVudHNcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBEb2N1bWVudCByZXNwb25zZXNcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldERvY3VtZW50cyA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHZvaWQgMCkgeyBwYXJhbWV0ZXJzID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIGZpZWxkcztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycyA9PT0gbnVsbCB8fCBwYXJhbWV0ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbWV0ZXJzLmZpZWxkcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gcGFyYW1ldGVycyA9PT0gbnVsbCB8fCBwYXJhbWV0ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbWV0ZXJzLmZpZWxkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1ldGVycyksIHsgZmllbGRzOiBmaWVsZHMgfSkpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgb25lIGRvY3VtZW50XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50SWQgLSBEb2N1bWVudCBJRFxyXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJzIGFwcGxpZWQgb24gYSBkb2N1bWVudFxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIERvY3VtZW50IHJlc3BvbnNlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXREb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudElkLCBwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCBmaWVsZHM7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL2RvY3VtZW50cy9cIikuY29uY2F0KGRvY3VtZW50SWQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBmaWVsZHMgPSAoZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9hO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgaWYgKEFycmF5LmlzQXJyYXkocGFyYW1ldGVycyA9PT0gbnVsbCB8fCBwYXJhbWV0ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbWV0ZXJzLmZpZWxkcykpIHtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gKF9hID0gcGFyYW1ldGVycyA9PT0gbnVsbCB8fCBwYXJhbWV0ZXJzID09PSB2b2lkIDAgPyB2b2lkIDAgOiBwYXJhbWV0ZXJzLmZpZWxkcykgPT09IG51bGwgfHwgX2EgPT09IHZvaWQgMCA/IHZvaWQgMCA6IF9hLmpvaW4oJywnKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiB1bmRlZmluZWQ7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pKCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcmVtb3ZlVW5kZWZpbmVkRnJvbU9iamVjdChfX2Fzc2lnbihfX2Fzc2lnbih7fSwgcGFyYW1ldGVycyksIHsgZmllbGRzOiBmaWVsZHMgfSkpKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgb3IgcmVwbGFjZSBtdWx0aXBsZXMgZG9jdW1lbnRzIHRvIGFuIGluZGV4XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRvY3VtZW50cyAtIEFycmF5IG9mIERvY3VtZW50IG9iamVjdHMgdG8gYWRkL3JlcGxhY2VcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBvbiBkb2N1bWVudCBhZGRpdGlvblxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuYWRkRG9jdW1lbnRzID0gZnVuY3Rpb24gKGRvY3VtZW50cywgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvZG9jdW1lbnRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBkb2N1bWVudHMsIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgb3IgcmVwbGFjZSBtdWx0aXBsZXMgZG9jdW1lbnRzIHRvIGFuIGluZGV4IGluIGJhdGNoZXNcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gZG9jdW1lbnRzIC0gQXJyYXkgb2YgRG9jdW1lbnQgb2JqZWN0cyB0byBhZGQvcmVwbGFjZVxyXG4gICAgICogQHBhcmFtIGJhdGNoU2l6ZSAtIFNpemUgb2YgdGhlIGJhdGNoXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIE9wdGlvbnMgb24gZG9jdW1lbnQgYWRkaXRpb25cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBlbnF1ZXVlZCB0YXNrIG9iamVjdHMgZm9yIGVhY2ggYmF0Y2hcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmFkZERvY3VtZW50c0luQmF0Y2hlcyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIGJhdGNoU2l6ZSwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChiYXRjaFNpemUgPT09IHZvaWQgMCkgeyBiYXRjaFNpemUgPSAxMDAwOyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXBkYXRlcywgaSwgX2EsIF9iO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9jKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9jLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cGRhdGVzID0gW107XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGkgPSAwO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDE7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpZiAoIShpIDwgZG9jdW1lbnRzLmxlbmd0aCkpIHJldHVybiBbMyAvKmJyZWFrKi8sIDRdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYiA9IChfYSA9IHVwZGF0ZXMpLnB1c2g7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuYWRkRG9jdW1lbnRzKGRvY3VtZW50cy5zbGljZShpLCBpICsgYmF0Y2hTaXplKSwgb3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMjpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2IuYXBwbHkoX2EsIFtfYy5zZW50KCldKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2MubGFiZWwgPSAzO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMzpcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSArPSBiYXRjaFNpemU7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMyAvKmJyZWFrKi8sIDFdO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgNDogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHVwZGF0ZXNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEFkZCBvciB1cGRhdGUgbXVsdGlwbGVzIGRvY3VtZW50cyB0byBhbiBpbmRleFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudHMgLSBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC91cGRhdGVcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gT3B0aW9ucyBvbiBkb2N1bWVudCB1cGRhdGVcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZURvY3VtZW50cyA9IGZ1bmN0aW9uIChkb2N1bWVudHMsIG9wdGlvbnMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL2RvY3VtZW50c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBkb2N1bWVudHMsIG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBBZGQgb3IgdXBkYXRlIG11bHRpcGxlcyBkb2N1bWVudHMgdG8gYW4gaW5kZXggaW4gYmF0Y2hlc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudHMgLSBBcnJheSBvZiBEb2N1bWVudCBvYmplY3RzIHRvIGFkZC91cGRhdGVcclxuICAgICAqIEBwYXJhbSBiYXRjaFNpemUgLSBTaXplIG9mIHRoZSBiYXRjaFxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBPcHRpb25zIG9uIGRvY3VtZW50IHVwZGF0ZVxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFycmF5IG9mIGVucXVldWVkIHRhc2sgb2JqZWN0cyBmb3IgZWFjaCBiYXRjaFxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRG9jdW1lbnRzSW5CYXRjaGVzID0gZnVuY3Rpb24gKGRvY3VtZW50cywgYmF0Y2hTaXplLCBvcHRpb25zKSB7XHJcbiAgICAgICAgaWYgKGJhdGNoU2l6ZSA9PT0gdm9pZCAwKSB7IGJhdGNoU2l6ZSA9IDEwMDA7IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cGRhdGVzLCBpLCBfYSwgX2I7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2MpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2MubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVwZGF0ZXMgPSBbXTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaSA9IDA7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9jLmxhYmVsID0gMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmICghKGkgPCBkb2N1bWVudHMubGVuZ3RoKSkgcmV0dXJuIFszIC8qYnJlYWsqLywgNF07XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9iID0gKF9hID0gdXBkYXRlcykucHVzaDtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy51cGRhdGVEb2N1bWVudHMoZG9jdW1lbnRzLnNsaWNlKGksIGkgKyBiYXRjaFNpemUpLCBvcHRpb25zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYi5hcHBseShfYSwgW19jLnNlbnQoKV0pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYy5sYWJlbCA9IDM7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBpICs9IGJhdGNoU2l6ZTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFszIC8qYnJlYWsqLywgMV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSA0OiByZXR1cm4gWzIgLypyZXR1cm4qLywgdXBkYXRlc107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogRGVsZXRlIG9uZSBkb2N1bWVudFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudElkIC0gSWQgb2YgRG9jdW1lbnQgdG8gZGVsZXRlXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVEb2N1bWVudCA9IGZ1bmN0aW9uIChkb2N1bWVudElkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHMvXCIpLmNvbmNhdChkb2N1bWVudElkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0YXNrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgbXVsdGlwbGVzIGRvY3VtZW50cyBvZiBhbiBpbmRleFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBkb2N1bWVudHNJZHMgLSBBcnJheSBvZiBEb2N1bWVudCBJZHMgdG8gZGVsZXRlXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5kZWxldGVEb2N1bWVudHMgPSBmdW5jdGlvbiAoZG9jdW1lbnRzSWRzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9kb2N1bWVudHMvZGVsZXRlLWJhdGNoXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBvc3QodXJsLCBkb2N1bWVudHNJZHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgYWxsIGRvY3VtZW50cyBvZiBhbiBpbmRleFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmRlbGV0ZUFsbERvY3VtZW50cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL2RvY3VtZW50c1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0YXNrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU0VUVElOR1NcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXRyaWV2ZSBhbGwgc2V0dGluZ3NcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgU2V0dGluZ3Mgb2JqZWN0XHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRTZXR0aW5ncyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhbGwgc2V0dGluZ3MgQW55IHBhcmFtZXRlcnMgbm90IHByb3ZpZGVkIHdpbGwgYmUgbGVmdCB1bmNoYW5nZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHNldHRpbmdzIC0gT2JqZWN0IGNvbnRhaW5pbmcgcGFyYW1ldGVycyB3aXRoIHRoZWlyIHVwZGF0ZWQgdmFsdWVzXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVTZXR0aW5ncyA9IGZ1bmN0aW9uIChzZXR0aW5ncykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3NcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucGF0Y2godXJsLCBzZXR0aW5ncyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0YXNrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFNldHRpbmdzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3NcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGFza107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFBBR0lOQVRJT04gU0VUVElOR1NcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHBhZ2luYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiBwYWdpbmF0aW9uIHNldHRpbmdzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRQYWdpbmF0aW9uID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvcGFnaW5hdGlvblwiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIHBhZ2luYXRpb24gc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhZ2luYXRpb24gLSBQYWdpbmF0aW9uIG9iamVjdFxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlUGFnaW5hdGlvbiA9IGZ1bmN0aW9uIChwYWdpbmF0aW9uKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9wYWdpbmF0aW9uXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBhdGNoKHVybCwgcGFnaW5hdGlvbildO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBwYWdpbmF0aW9uIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0UGFnaW5hdGlvbiA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3BhZ2luYXRpb25cIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFNZTk9OWU1TXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGFsbCBzeW5vbnltc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBvYmplY3Qgb2Ygc3lub255bSBtYXBwaW5nc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0U3lub255bXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zeW5vbnltc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGxpc3Qgb2Ygc3lub255bXMuIE92ZXJ3cml0ZSB0aGUgb2xkIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHN5bm9ueW1zIC0gTWFwcGluZyBvZiBzeW5vbnltcyB3aXRoIHRoZWlyIGFzc29jaWF0ZWQgd29yZHNcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnVwZGF0ZVN5bm9ueW1zID0gZnVuY3Rpb24gKHN5bm9ueW1zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zeW5vbnltc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBzeW5vbnltcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzeW5vbnltIGxpc3QgdG8gYmUgZW1wdHkgYWdhaW5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFN5bm9ueW1zID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3lub255bXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGFza107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFNUT1AgV09SRFNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWxsIHN0b3Atd29yZHNcclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYXJyYXkgb2Ygc3RvcC13b3Jkc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0U3RvcFdvcmRzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3RvcC13b3Jkc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGxpc3Qgb2Ygc3RvcC13b3Jkcy4gT3ZlcndyaXRlIHRoZSBvbGQgbGlzdC5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc3RvcFdvcmRzIC0gQXJyYXkgb2Ygc3RyaW5ncyB0aGF0IGNvbnRhaW5zIHRoZSBzdG9wLXdvcmRzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlU3RvcFdvcmRzID0gZnVuY3Rpb24gKHN0b3BXb3Jkcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc3RvcC13b3Jkc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBzdG9wV29yZHMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgc3RvcC13b3JkcyBsaXN0IHRvIGJlIGVtcHR5IGFnYWluXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRTdG9wV29yZHMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zdG9wLXdvcmRzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRhc2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBSQU5LSU5HIFJVTEVTXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBsaXN0IG9mIGFsbCByYW5raW5nLXJ1bGVzXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFycmF5IG9mIHJhbmtpbmctcnVsZXNcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFJhbmtpbmdSdWxlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3JhbmtpbmctcnVsZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBsaXN0IG9mIHJhbmtpbmctcnVsZXMuIE92ZXJ3cml0ZSB0aGUgb2xkIGxpc3QuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHJhbmtpbmdSdWxlcyAtIEFycmF5IHRoYXQgY29udGFpbiByYW5raW5nIHJ1bGVzIHNvcnRlZCBieSBvcmRlciBvZlxyXG4gICAgICogICBpbXBvcnRhbmNlLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlUmFua2luZ1J1bGVzID0gZnVuY3Rpb24gKHJhbmtpbmdSdWxlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvcmFua2luZy1ydWxlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCByYW5raW5nUnVsZXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgcmFua2luZyBydWxlcyBsaXN0IHRvIGl0cyBkZWZhdWx0IHZhbHVlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRSYW5raW5nUnVsZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9yYW5raW5nLXJ1bGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRhc2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBESVNUSU5DVCBBVFRSSUJVVEVcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGRpc3RpbmN0LWF0dHJpYnV0ZVxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyB0aGUgZGlzdGluY3QtYXR0cmlidXRlIG9mIHRoZSBpbmRleFxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RGlzdGluY3RBdHRyaWJ1dGUgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9kaXN0aW5jdC1hdHRyaWJ1dGVcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIHRoZSBkaXN0aW5jdC1hdHRyaWJ1dGUuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRpc3RpbmN0QXR0cmlidXRlIC0gRmllbGQgbmFtZSBvZiB0aGUgZGlzdGluY3QtYXR0cmlidXRlXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVEaXN0aW5jdEF0dHJpYnV0ZSA9IGZ1bmN0aW9uIChkaXN0aW5jdEF0dHJpYnV0ZSkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzdGluY3QtYXR0cmlidXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnB1dCh1cmwsIGRpc3RpbmN0QXR0cmlidXRlKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIGRpc3RpbmN0LWF0dHJpYnV0ZS5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldERpc3RpbmN0QXR0cmlidXRlID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzdGluY3QtYXR0cmlidXRlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRhc2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBGSUxURVJBQkxFIEFUVFJJQlVURVNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGZpbHRlcmFibGUtYXR0cmlidXRlc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhbiBhcnJheSBvZiBmaWx0ZXJhYmxlLWF0dHJpYnV0ZXNcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldEZpbHRlcmFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZmlsdGVyYWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZmlsdGVyYWJsZS1hdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmaWx0ZXJhYmxlQXR0cmlidXRlcyAtIEFycmF5IG9mIHN0cmluZ3MgY29udGFpbmluZyB0aGUgYXR0cmlidXRlc1xyXG4gICAgICogICB0aGF0IGNhbiBiZSB1c2VkIGFzIGZpbHRlcnMgYXQgcXVlcnkgdGltZVxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRmlsdGVyYWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoZmlsdGVyYWJsZUF0dHJpYnV0ZXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2ZpbHRlcmFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wdXQodXJsLCBmaWx0ZXJhYmxlQXR0cmlidXRlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBmaWx0ZXJhYmxlLWF0dHJpYnV0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRGaWx0ZXJhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2ZpbHRlcmFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0YXNrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU09SVEFCTEUgQVRUUklCVVRFU1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgc29ydGFibGUtYXR0cmlidXRlc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBzb3J0YWJsZS1hdHRyaWJ1dGVzXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5nZXRTb3J0YWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zb3J0YWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgc29ydGFibGUtYXR0cmlidXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gc29ydGFibGVBdHRyaWJ1dGVzIC0gQXJyYXkgb2Ygc3RyaW5ncyBjb250YWluaW5nIHRoZSBhdHRyaWJ1dGVzIHRoYXRcclxuICAgICAqICAgY2FuIGJlIHVzZWQgdG8gc29ydCBzZWFyY2ggcmVzdWx0cyBhdCBxdWVyeSB0aW1lXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVTb3J0YWJsZUF0dHJpYnV0ZXMgPSBmdW5jdGlvbiAoc29ydGFibGVBdHRyaWJ1dGVzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9zb3J0YWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnB1dCh1cmwsIHNvcnRhYmxlQXR0cmlidXRlcyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSBzb3J0YWJsZS1hdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0U29ydGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc29ydGFibGUtYXR0cmlidXRlc1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2suZW5xdWV1ZWRBdCA9IG5ldyBEYXRlKHRhc2suZW5xdWV1ZWRBdCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCB0YXNrXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gU0VBUkNIQUJMRSBBVFRSSUJVVEVcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIHNlYXJjaGFibGUtYXR0cmlidXRlc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBzZWFyY2hhYmxlLWF0dHJpYnV0ZXNcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLmdldFNlYXJjaGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc2VhcmNoYWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgc2VhcmNoYWJsZS1hdHRyaWJ1dGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBzZWFyY2hhYmxlQXR0cmlidXRlcyAtIEFycmF5IG9mIHN0cmluZ3MgdGhhdCBjb250YWlucyBzZWFyY2hhYmxlXHJcbiAgICAgKiAgIGF0dHJpYnV0ZXMgc29ydGVkIGJ5IG9yZGVyIG9mIGltcG9ydGFuY2UobW9zdCB0byBsZWFzdCBpbXBvcnRhbnQpXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVTZWFyY2hhYmxlQXR0cmlidXRlcyA9IGZ1bmN0aW9uIChzZWFyY2hhYmxlQXR0cmlidXRlcykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc2VhcmNoYWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnB1dCh1cmwsIHNlYXJjaGFibGVBdHRyaWJ1dGVzKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgbmV3IEVucXVldWVkVGFzayh0YXNrKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogUmVzZXQgdGhlIHNlYXJjaGFibGUtYXR0cmlidXRlcy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS5yZXNldFNlYXJjaGFibGVBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3Mvc2VhcmNoYWJsZS1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRhc2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBESVNQTEFZRUQgQVRUUklCVVRFXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBkaXNwbGF5ZWQtYXR0cmlidXRlc1xyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhcnJheSBvZiBkaXNwbGF5ZWQtYXR0cmlidXRlc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RGlzcGxheWVkQXR0cmlidXRlcyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3BsYXllZC1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgZGlzcGxheWVkLWF0dHJpYnV0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGRpc3BsYXllZEF0dHJpYnV0ZXMgLSBBcnJheSBvZiBzdHJpbmdzIHRoYXQgY29udGFpbnMgYXR0cmlidXRlcyBvZlxyXG4gICAgICogICBhbiBpbmRleCB0byBkaXNwbGF5XHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVEaXNwbGF5ZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKGRpc3BsYXllZEF0dHJpYnV0ZXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2Rpc3BsYXllZC1hdHRyaWJ1dGVzXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnB1dCh1cmwsIGRpc3BsYXllZEF0dHJpYnV0ZXMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgZGlzcGxheWVkLWF0dHJpYnV0ZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXREaXNwbGF5ZWRBdHRyaWJ1dGVzID0gZnVuY3Rpb24gKCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwgdGFzaztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzL1wiLmNvbmNhdCh0aGlzLnVpZCwgXCIvc2V0dGluZ3MvZGlzcGxheWVkLWF0dHJpYnV0ZXNcIik7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3RbXCJkZWxldGVcIl0odXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrID0gX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB0YXNrLmVucXVldWVkQXQgPSBuZXcgRGF0ZSh0YXNrLmVucXVldWVkQXQpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdGFza107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFRZUE8gVE9MRVJBTkNFXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSB0eXBvIHRvbGVyYW5jZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgdGhlIHR5cG8gdG9sZXJhbmNlIHNldHRpbmdzLlxyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0VHlwb1RvbGVyYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3R5cG8tdG9sZXJhbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSB0aGUgdHlwbyB0b2xlcmFuY2Ugc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHR5cG9Ub2xlcmFuY2UgLSBPYmplY3QgY29udGFpbmluZyB0aGUgY3VzdG9tIHR5cG8gdG9sZXJhbmNlXHJcbiAgICAgKiAgIHNldHRpbmdzLlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdXBkYXRlXHJcbiAgICAgKi9cclxuICAgIEluZGV4LnByb3RvdHlwZS51cGRhdGVUeXBvVG9sZXJhbmNlID0gZnVuY3Rpb24gKHR5cG9Ub2xlcmFuY2UpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3R5cG8tdG9sZXJhbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBhdGNoKHVybCwgdHlwb1RvbGVyYW5jZSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRhc2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFJlc2V0IHRoZSB0eXBvIHRvbGVyYW5jZSBzZXR0aW5ncy5cclxuICAgICAqXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgb2JqZWN0IG9mIHRoZSBlbnF1ZXVlZCB1cGRhdGVcclxuICAgICAqL1xyXG4gICAgSW5kZXgucHJvdG90eXBlLnJlc2V0VHlwb1RvbGVyYW5jZSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL3R5cG8tdG9sZXJhbmNlXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzay5lbnF1ZXVlZEF0ID0gbmV3IERhdGUodGFzay5lbnF1ZXVlZEF0KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIHRhc2tdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBGQUNFVElOR1xyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgZmFjZXRpbmcgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIG9iamVjdCBvZiBmYWNldGluZyBpbmRleCBzZXR0aW5nc1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUuZ2V0RmFjZXRpbmcgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImluZGV4ZXMvXCIuY29uY2F0KHRoaXMudWlkLCBcIi9zZXR0aW5ncy9mYWNldGluZ1wiKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBVcGRhdGUgdGhlIGZhY2V0aW5nIHNldHRpbmdzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBmYWNldGluZyAtIEZhY2V0aW5nIGluZGV4IHNldHRpbmdzIG9iamVjdFxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUudXBkYXRlRmFjZXRpbmcgPSBmdW5jdGlvbiAoZmFjZXRpbmcpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2ZhY2V0aW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LnBhdGNoKHVybCwgZmFjZXRpbmcpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBSZXNldCB0aGUgZmFjZXRpbmcgc2V0dGluZ3MuXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSBjb250YWluaW5nIGFuIEVucXVldWVkVGFza1xyXG4gICAgICovXHJcbiAgICBJbmRleC5wcm90b3R5cGUucmVzZXRGYWNldGluZyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmwsIHRhc2s7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaW5kZXhlcy9cIi5jb25jYXQodGhpcy51aWQsIFwiL3NldHRpbmdzL2ZhY2V0aW5nXCIpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0W1wiZGVsZXRlXCJdKHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdGFzayA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBFbnF1ZXVlZFRhc2sodGFzayldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gSW5kZXg7XHJcbn0oKSk7XG5cbi8qXHJcbiAqIEJ1bmRsZTogTWVpbGlTZWFyY2hcclxuICogUHJvamVjdDogTWVpbGlTZWFyY2ggLSBKYXZhc2NyaXB0IEFQSVxyXG4gKiBBdXRob3I6IFF1ZW50aW4gZGUgUXVlbGVuIDxxdWVudGluQG1laWxpc2VhcmNoLmNvbT5cclxuICogQ29weXJpZ2h0OiAyMDE5LCBNZWlsaVNlYXJjaFxyXG4gKi9cclxudmFyIENsaWVudCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uICgpIHtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlcyBuZXcgTWVpbGlTZWFyY2ggaW5zdGFuY2VcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gY29uZmlnIC0gQ29uZmlndXJhdGlvbiBvYmplY3RcclxuICAgICAqL1xyXG4gICAgZnVuY3Rpb24gQ2xpZW50KGNvbmZpZykge1xyXG4gICAgICAgIHRoaXMuY29uZmlnID0gY29uZmlnO1xyXG4gICAgICAgIHRoaXMuaHR0cFJlcXVlc3QgPSBuZXcgSHR0cFJlcXVlc3RzKGNvbmZpZyk7XHJcbiAgICAgICAgdGhpcy50YXNrcyA9IG5ldyBUYXNrQ2xpZW50KGNvbmZpZyk7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIFJldHVybiBhbiBJbmRleCBpbnN0YW5jZVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleFVpZCAtIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIEluc3RhbmNlIG9mIEluZGV4XHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuaW5kZXggPSBmdW5jdGlvbiAoaW5kZXhVaWQpIHtcclxuICAgICAgICByZXR1cm4gbmV3IEluZGV4KHRoaXMuY29uZmlnLCBpbmRleFVpZCk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHYXRoZXIgaW5mb3JtYXRpb24gYWJvdXQgYW4gaW5kZXggYnkgY2FsbGluZyBNZWlsaVNlYXJjaCBhbmQgcmV0dXJuIGFuXHJcbiAgICAgKiBJbmRleCBpbnN0YW5jZSB3aXRoIHRoZSBnYXRoZXJlZCBpbmZvcm1hdGlvblxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBpbmRleFVpZCAtIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmV0dXJuaW5nIEluZGV4IGluc3RhbmNlXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXggPSBmdW5jdGlvbiAoaW5kZXhVaWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgSW5kZXgodGhpcy5jb25maWcsIGluZGV4VWlkKS5mZXRjaEluZm8oKV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2F0aGVyIGluZm9ybWF0aW9uIGFib3V0IGFuIGluZGV4IGJ5IGNhbGxpbmcgTWVpbGlTZWFyY2ggYW5kIHJldHVybiB0aGUgcmF3XHJcbiAgICAgKiBKU09OIHJlc3BvbnNlXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGluZGV4VWlkIC0gVGhlIGluZGV4IFVJRFxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgaW5kZXggaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRSYXdJbmRleCA9IGZ1bmN0aW9uIChpbmRleFVpZCkge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgaW5kZXhVaWQpLmdldFJhd0luZm8oKV07XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCB0aGUgaW5kZXhlcyBhcyBJbmRleCBpbnN0YW5jZXMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJzIHRvIGJyb3dzZSB0aGUgaW5kZXhlc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgYXJyYXkgb2YgcmF3IGluZGV4IGluZm9ybWF0aW9uXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0SW5kZXhlcyA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHZvaWQgMCkgeyBwYXJhbWV0ZXJzID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciByYXdJbmRleGVzLCBpbmRleGVzO1xyXG4gICAgICAgICAgICB2YXIgX3RoaXMgPSB0aGlzO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmdldFJhd0luZGV4ZXMocGFyYW1ldGVycyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmF3SW5kZXhlcyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgaW5kZXhlcyA9IHJhd0luZGV4ZXMucmVzdWx0cy5tYXAoZnVuY3Rpb24gKGluZGV4KSB7IHJldHVybiBuZXcgSW5kZXgoX3RoaXMuY29uZmlnLCBpbmRleC51aWQsIGluZGV4LnByaW1hcnlLZXkpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9fYXNzaWduKF9fYXNzaWduKHt9LCByYXdJbmRleGVzKSwgeyByZXN1bHRzOiBpbmRleGVzIH0pXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgYWxsIHRoZSBpbmRleGVzIGluIHRoZWlyIHJhdyB2YWx1ZSAobm8gSW5kZXggaW5zdGFuY2VzKS5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyAtIFBhcmFtZXRlcnMgdG8gYnJvd3NlIHRoZSBpbmRleGVzXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJldHVybmluZyBhcnJheSBvZiByYXcgaW5kZXggaW5mb3JtYXRpb25cclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRSYXdJbmRleGVzID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICBpZiAocGFyYW1ldGVycyA9PT0gdm9pZCAwKSB7IHBhcmFtZXRlcnMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJpbmRleGVzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcGFyYW1ldGVycyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogQ3JlYXRlIGEgbmV3IGluZGV4XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVpZCAtIFRoZSBpbmRleCBVSURcclxuICAgICAqIEBwYXJhbSBvcHRpb25zIC0gSW5kZXggb3B0aW9uc1xyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgSW5kZXggaW5zdGFuY2VcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5jcmVhdGVJbmRleCA9IGZ1bmN0aW9uICh1aWQsIG9wdGlvbnMpIHtcclxuICAgICAgICBpZiAob3B0aW9ucyA9PT0gdm9pZCAwKSB7IG9wdGlvbnMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDogcmV0dXJuIFs0IC8qeWllbGQqLywgSW5kZXguY3JlYXRlKHVpZCwgb3B0aW9ucywgdGhpcy5jb25maWcpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIFVwZGF0ZSBhbiBpbmRleFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1aWQgLSBUaGUgaW5kZXggVUlEXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEluZGV4IG9wdGlvbnMgdG8gdXBkYXRlXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJldHVybmluZyBJbmRleCBpbnN0YW5jZSBhZnRlciB1cGRhdGluZ1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLnVwZGF0ZUluZGV4ID0gZnVuY3Rpb24gKHVpZCwgb3B0aW9ucykge1xyXG4gICAgICAgIGlmIChvcHRpb25zID09PSB2b2lkIDApIHsgb3B0aW9ucyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCBuZXcgSW5kZXgodGhpcy5jb25maWcsIHVpZCkudXBkYXRlKG9wdGlvbnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBhbiBpbmRleFxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB1aWQgLSBUaGUgaW5kZXggVUlEXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHdoaWNoIHJlc29sdmVzIHdoZW4gaW5kZXggaXMgZGVsZXRlZCBzdWNjZXNzZnVsbHlcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5kZWxldGVJbmRleCA9IGZ1bmN0aW9uICh1aWQpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIG5ldyBJbmRleCh0aGlzLmNvbmZpZywgdWlkKVtcImRlbGV0ZVwiXSgpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZXMgYW4gaW5kZXggaWYgaXQgYWxyZWFkeSBleGlzdHMuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHVpZCAtIFRoZSBpbmRleCBVSURcclxuICAgICAqIEByZXR1cm5zIFByb21pc2Ugd2hpY2ggcmVzb2x2ZXMgdG8gdHJ1ZSB3aGVuIGluZGV4IGV4aXN0cyBhbmQgaXMgZGVsZXRlZFxyXG4gICAgICogICBzdWNjZXNzZnVsbHksIG90aGVyd2lzZSBmYWxzZSBpZiBpdCBkb2VzIG5vdCBleGlzdFxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmRlbGV0ZUluZGV4SWZFeGlzdHMgPSBmdW5jdGlvbiAodWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgZV8xO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS50cnlzLnB1c2goWzAsIDIsICwgM10pO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmRlbGV0ZUluZGV4KHVpZCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJ1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBlXzEgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIGlmIChlXzEuY29kZSA9PT0gXCJpbmRleF9ub3RfZm91bmRcIiAvKiBFcnJvclN0YXR1c0NvZGUuSU5ERVhfTk9UX0ZPVU5EICovKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgZmFsc2VdO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRocm93IGVfMTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDM6IHJldHVybiBbMiAvKnJldHVybiovXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBTd2FwcyBhIGxpc3Qgb2YgaW5kZXggdHVwbGVzLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbXMgLSBMaXN0IG9mIGluZGV4ZXMgdHVwbGVzIHRvIHN3YXAuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJldHVybmluZyBvYmplY3Qgb2YgdGhlIGVucXVldWVkIHRhc2tcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5zd2FwSW5kZXhlcyA9IGZ1bmN0aW9uIChwYXJhbXMpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9ICcvc3dhcC1pbmRleGVzJztcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgcGFyYW1zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gVEFTS1NcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBHZXQgdGhlIGxpc3Qgb2YgYWxsIGNsaWVudCB0YXNrc1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVycyB0byBicm93c2UgdGhlIHRhc2tzXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJldHVybmluZyBhbGwgdGFza3NcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRUYXNrcyA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgaWYgKHBhcmFtZXRlcnMgPT09IHZvaWQgMCkgeyBwYXJhbWV0ZXJzID0ge307IH1cclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudGFza3MuZ2V0VGFza3MocGFyYW1ldGVycyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogR2V0IG9uZSB0YXNrIG9uIHRoZSBjbGllbnQgc2NvcGVcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gdGFza1VpZCAtIFRhc2sgaWRlbnRpZmllclxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgYSB0YXNrXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0VGFzayA9IGZ1bmN0aW9uICh0YXNrVWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmdldFRhc2sodGFza1VpZCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FpdCBmb3IgbXVsdGlwbGUgdGFza3MgdG8gYmUgZmluaXNoZWQuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHRhc2tVaWRzIC0gVGFza3MgaWRlbnRpZmllclxyXG4gICAgICogQHBhcmFtIHdhaXRPcHRpb25zIC0gT3B0aW9ucyBvbiB0aW1lb3V0IGFuZCBpbnRlcnZhbFxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgYW4gYXJyYXkgb2YgdGFza3NcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS53YWl0Rm9yVGFza3MgPSBmdW5jdGlvbiAodGFza1VpZHMsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvclRhc2tzKHRhc2tVaWRzLCB7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICB0aW1lT3V0TXM6IHRpbWVPdXRNcyxcclxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGludGVydmFsTXM6IGludGVydmFsTXNcclxuICAgICAgICAgICAgICAgICAgICAgICAgfSldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9lLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogV2FpdCBmb3IgYSB0YXNrIHRvIGJlIGZpbmlzaGVkLlxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSB0YXNrVWlkIC0gVGFzayBpZGVudGlmaWVyXHJcbiAgICAgKiBAcGFyYW0gd2FpdE9wdGlvbnMgLSBPcHRpb25zIG9uIHRpbWVvdXQgYW5kIGludGVydmFsXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJldHVybmluZyBhbiBhcnJheSBvZiB0YXNrc1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLndhaXRGb3JUYXNrID0gZnVuY3Rpb24gKHRhc2tVaWQsIF9hKSB7XHJcbiAgICAgICAgdmFyIF9iID0gX2EgPT09IHZvaWQgMCA/IHt9IDogX2EsIF9jID0gX2IudGltZU91dE1zLCB0aW1lT3V0TXMgPSBfYyA9PT0gdm9pZCAwID8gNTAwMCA6IF9jLCBfZCA9IF9iLmludGVydmFsTXMsIGludGVydmFsTXMgPSBfZCA9PT0gdm9pZCAwID8gNTAgOiBfZDtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2UpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2UubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6IHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMudGFza3Mud2FpdEZvclRhc2sodGFza1VpZCwge1xyXG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgdGltZU91dE1zOiB0aW1lT3V0TXMsXHJcbiAgICAgICAgICAgICAgICAgICAgICAgICAgICBpbnRlcnZhbE1zOiBpbnRlcnZhbE1zXHJcbiAgICAgICAgICAgICAgICAgICAgICAgIH0pXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfZS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENhbmNlbCBhIGxpc3Qgb2YgZW5xdWV1ZWQgb3IgcHJvY2Vzc2luZyB0YXNrcy5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gcGFyYW1ldGVycyAtIFBhcmFtZXRlcnMgdG8gZmlsdGVyIHRoZSB0YXNrcy5cclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgY29udGFpbmluZyBhbiBFbnF1ZXVlZFRhc2tcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5jYW5jZWxUYXNrcyA9IGZ1bmN0aW9uIChwYXJhbWV0ZXJzKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmNhbmNlbFRhc2tzKHBhcmFtZXRlcnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIERlbGV0ZSBhIGxpc3Qgb2YgdGFza3MuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIHBhcmFtZXRlcnMgLSBQYXJhbWV0ZXJzIHRvIGZpbHRlciB0aGUgdGFza3MuXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIGNvbnRhaW5pbmcgYW4gRW5xdWV1ZWRUYXNrXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZGVsZXRlVGFza3MgPSBmdW5jdGlvbiAocGFyYW1ldGVycykge1xyXG4gICAgICAgIGlmIChwYXJhbWV0ZXJzID09PSB2b2lkIDApIHsgcGFyYW1ldGVycyA9IHt9OyB9XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOiByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLnRhc2tzLmRlbGV0ZVRhc2tzKHBhcmFtZXRlcnMpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBLRVlTXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IGFsbCBBUEkga2V5c1xyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBwYXJhbWV0ZXJzIC0gUGFyYW1ldGVycyB0byBicm93c2UgdGhlIGluZGV4ZXNcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmV0dXJuaW5nIGFuIG9iamVjdCB3aXRoIGtleXNcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRLZXlzID0gZnVuY3Rpb24gKHBhcmFtZXRlcnMpIHtcclxuICAgICAgICBpZiAocGFyYW1ldGVycyA9PT0gdm9pZCAwKSB7IHBhcmFtZXRlcnMgPSB7fTsgfVxyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybCwga2V5cztcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJrZXlzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCwgcGFyYW1ldGVycyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cyA9IF9hLnNlbnQoKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAga2V5cy5yZXN1bHRzID0ga2V5cy5yZXN1bHRzLm1hcChmdW5jdGlvbiAoa2V5KSB7IHJldHVybiAoX19hc3NpZ24oX19hc3NpZ24oe30sIGtleSksIHsgY3JlYXRlZEF0OiBuZXcgRGF0ZShrZXkuY3JlYXRlZEF0KSwgdXBkYXRlQXQ6IG5ldyBEYXRlKGtleS51cGRhdGVBdCkgfSkpOyB9KTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFsyIC8qcmV0dXJuKi8sIGtleXNdO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIEdldCBvbmUgQVBJIGtleVxyXG4gICAgICpcclxuICAgICAqIEBwYXJhbSBrZXlPclVpZCAtIEtleSBvciB1aWQgb2YgdGhlIEFQSSBrZXlcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmV0dXJuaW5nIGEga2V5XHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZ2V0S2V5ID0gZnVuY3Rpb24gKGtleU9yVWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImtleXMvXCIuY29uY2F0KGtleU9yVWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGUgb25lIEFQSSBrZXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEtleSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJldHVybmluZyBhIGtleVxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmNyZWF0ZUtleSA9IGZ1bmN0aW9uIChvcHRpb25zKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImtleXNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5wb3N0KHVybCwgb3B0aW9ucyldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTogcmV0dXJuIFsyIC8qcmV0dXJuKi8sIF9hLnNlbnQoKV07XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8qKlxyXG4gICAgICogVXBkYXRlIG9uZSBBUEkga2V5XHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGtleU9yVWlkIC0gS2V5XHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIEtleSBvcHRpb25zXHJcbiAgICAgKiBAcmV0dXJucyBQcm9taXNlIHJldHVybmluZyBhIGtleVxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLnVwZGF0ZUtleSA9IGZ1bmN0aW9uIChrZXlPclVpZCwgb3B0aW9ucykge1xyXG4gICAgICAgIHJldHVybiBfX2F3YWl0ZXIodGhpcywgdm9pZCAwLCB2b2lkIDAsIGZ1bmN0aW9uICgpIHtcclxuICAgICAgICAgICAgdmFyIHVybDtcclxuICAgICAgICAgICAgcmV0dXJuIF9fZ2VuZXJhdG9yKHRoaXMsIGZ1bmN0aW9uIChfYSkge1xyXG4gICAgICAgICAgICAgICAgc3dpdGNoIChfYS5sYWJlbCkge1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMDpcclxuICAgICAgICAgICAgICAgICAgICAgICAgdXJsID0gXCJrZXlzL1wiLmNvbmNhdChrZXlPclVpZCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucGF0Y2godXJsLCBvcHRpb25zKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLyoqXHJcbiAgICAgKiBEZWxldGUgb25lIEFQSSBrZXlcclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0ga2V5T3JVaWQgLSBLZXlcclxuICAgICAqIEByZXR1cm5zXHJcbiAgICAgKi9cclxuICAgIENsaWVudC5wcm90b3R5cGUuZGVsZXRlS2V5ID0gZnVuY3Rpb24gKGtleU9yVWlkKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImtleXMvXCIuY29uY2F0KGtleU9yVWlkKTtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdFtcImRlbGV0ZVwiXSh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvLy9cclxuICAgIC8vLyBIRUFMVEhcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDaGVja3MgaWYgdGhlIHNlcnZlciBpcyBoZWFsdGh5LCBvdGhlcndpc2UgYW4gZXJyb3Igd2lsbCBiZSB0aHJvd24uXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgYW4gb2JqZWN0IHdpdGggaGVhbHRoIGRldGFpbHNcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5oZWFsdGggPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImhlYWx0aFwiO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzQgLyp5aWVsZCovLCB0aGlzLmh0dHBSZXF1ZXN0LmdldCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6IHJldHVybiBbMiAvKnJldHVybiovLCBfYS5zZW50KCldO1xyXG4gICAgICAgICAgICAgICAgfVxyXG4gICAgICAgICAgICB9KTtcclxuICAgICAgICB9KTtcclxuICAgIH07XHJcbiAgICAvKipcclxuICAgICAqIENoZWNrcyBpZiB0aGUgc2VydmVyIGlzIGhlYWx0aHksIHJldHVybiB0cnVlIG9yIGZhbHNlLlxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmV0dXJuaW5nIGEgYm9vbGVhblxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmlzSGVhbHRoeSA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIF9hLnRyeXMucHVzaChbMCwgMiwgLCAzXSk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwiaGVhbHRoXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QuZ2V0KHVybCldO1xyXG4gICAgICAgICAgICAgICAgICAgIGNhc2UgMTpcclxuICAgICAgICAgICAgICAgICAgICAgICAgX2Euc2VudCgpO1xyXG4gICAgICAgICAgICAgICAgICAgICAgICByZXR1cm4gWzIgLypyZXR1cm4qLywgdHJ1ZV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAyOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBmYWxzZV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAzOiByZXR1cm4gWzIgLypyZXR1cm4qL107XHJcbiAgICAgICAgICAgICAgICB9XHJcbiAgICAgICAgICAgIH0pO1xyXG4gICAgICAgIH0pO1xyXG4gICAgfTtcclxuICAgIC8vL1xyXG4gICAgLy8vIFNUQVRTXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2V0IHRoZSBzdGF0cyBvZiBhbGwgdGhlIGRhdGFiYXNlXHJcbiAgICAgKlxyXG4gICAgICogQHJldHVybnMgUHJvbWlzZSByZXR1cm5pbmcgb2JqZWN0IG9mIGFsbCB0aGUgc3RhdHNcclxuICAgICAqL1xyXG4gICAgQ2xpZW50LnByb3RvdHlwZS5nZXRTdGF0cyA9IGZ1bmN0aW9uICgpIHtcclxuICAgICAgICByZXR1cm4gX19hd2FpdGVyKHRoaXMsIHZvaWQgMCwgdm9pZCAwLCBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgICAgIHZhciB1cmw7XHJcbiAgICAgICAgICAgIHJldHVybiBfX2dlbmVyYXRvcih0aGlzLCBmdW5jdGlvbiAoX2EpIHtcclxuICAgICAgICAgICAgICAgIHN3aXRjaCAoX2EubGFiZWwpIHtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDA6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHVybCA9IFwic3RhdHNcIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gVkVSU0lPTlxyXG4gICAgLy8vXHJcbiAgICAvKipcclxuICAgICAqIEdldCB0aGUgdmVyc2lvbiBvZiBNZWlsaVNlYXJjaFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmV0dXJuaW5nIG9iamVjdCB3aXRoIHZlcnNpb24gZGV0YWlsc1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdldFZlcnNpb24gPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcInZlcnNpb25cIjtcclxuICAgICAgICAgICAgICAgICAgICAgICAgcmV0dXJuIFs0IC8qeWllbGQqLywgdGhpcy5odHRwUmVxdWVzdC5nZXQodXJsKV07XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAxOiByZXR1cm4gWzIgLypyZXR1cm4qLywgX2Euc2VudCgpXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gRFVNUFNcclxuICAgIC8vL1xyXG4gICAgLyoqXHJcbiAgICAgKiBDcmVhdGVzIGEgZHVtcFxyXG4gICAgICpcclxuICAgICAqIEByZXR1cm5zIFByb21pc2UgcmV0dXJuaW5nIG9iamVjdCBvZiB0aGUgZW5xdWV1ZWQgdGFza1xyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmNyZWF0ZUR1bXAgPSBmdW5jdGlvbiAoKSB7XHJcbiAgICAgICAgcmV0dXJuIF9fYXdhaXRlcih0aGlzLCB2b2lkIDAsIHZvaWQgMCwgZnVuY3Rpb24gKCkge1xyXG4gICAgICAgICAgICB2YXIgdXJsLCB0YXNrO1xyXG4gICAgICAgICAgICByZXR1cm4gX19nZW5lcmF0b3IodGhpcywgZnVuY3Rpb24gKF9hKSB7XHJcbiAgICAgICAgICAgICAgICBzd2l0Y2ggKF9hLmxhYmVsKSB7XHJcbiAgICAgICAgICAgICAgICAgICAgY2FzZSAwOlxyXG4gICAgICAgICAgICAgICAgICAgICAgICB1cmwgPSBcImR1bXBzXCI7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbNCAvKnlpZWxkKi8sIHRoaXMuaHR0cFJlcXVlc3QucG9zdCh1cmwpXTtcclxuICAgICAgICAgICAgICAgICAgICBjYXNlIDE6XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHRhc2sgPSBfYS5zZW50KCk7XHJcbiAgICAgICAgICAgICAgICAgICAgICAgIHJldHVybiBbMiAvKnJldHVybiovLCBuZXcgRW5xdWV1ZWRUYXNrKHRhc2spXTtcclxuICAgICAgICAgICAgICAgIH1cclxuICAgICAgICAgICAgfSk7XHJcbiAgICAgICAgfSk7XHJcbiAgICB9O1xyXG4gICAgLy8vXHJcbiAgICAvLy8gVE9LRU5TXHJcbiAgICAvLy9cclxuICAgIC8qKlxyXG4gICAgICogR2VuZXJhdGUgYSB0ZW5hbnQgdG9rZW5cclxuICAgICAqXHJcbiAgICAgKiBAcGFyYW0gYXBpS2V5VWlkIC0gVGhlIHVpZCBvZiB0aGUgYXBpIGtleSB1c2VkIGFzIGlzc3VlciBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcGFyYW0gc2VhcmNoUnVsZXMgLSBTZWFyY2ggcnVsZXMgdGhhdCBhcmUgYXBwbGllZCB0byBldmVyeSBzZWFyY2guXHJcbiAgICAgKiBAcGFyYW0gb3B0aW9ucyAtIFRva2VuIG9wdGlvbnMgdG8gY3VzdG9taXplIHNvbWUgYXNwZWN0IG9mIHRoZSB0b2tlbi5cclxuICAgICAqIEByZXR1cm5zIFRoZSB0b2tlbiBpbiBKV1QgZm9ybWF0LlxyXG4gICAgICovXHJcbiAgICBDbGllbnQucHJvdG90eXBlLmdlbmVyYXRlVGVuYW50VG9rZW4gPSBmdW5jdGlvbiAoX2FwaUtleVVpZCwgX3NlYXJjaFJ1bGVzLCBfb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBlcnJvciA9IG5ldyBFcnJvcigpO1xyXG4gICAgICAgIHRocm93IG5ldyBFcnJvcihcIk1laWxpc2VhcmNoOiBmYWlsZWQgdG8gZ2VuZXJhdGUgYSB0ZW5hbnQgdG9rZW4uIEdlbmVyYXRpb24gb2YgYSB0b2tlbiBvbmx5IHdvcmtzIGluIGEgbm9kZSBlbnZpcm9ubWVudCBcXG4gXCIuY29uY2F0KGVycm9yLnN0YWNrLCBcIi5cIikpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBDbGllbnQ7XHJcbn0oKSk7XG5cbmZ1bmN0aW9uIGVuY29kZTY0KGRhdGEpIHtcclxuICAgIHJldHVybiBCdWZmZXIuZnJvbShKU09OLnN0cmluZ2lmeShkYXRhKSkudG9TdHJpbmcoJ2Jhc2U2NCcpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgdGhlIGhlYWRlciBvZiB0aGUgdG9rZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSBhcGlLZXkgLSBBUEkga2V5IHVzZWQgdG8gc2lnbiB0aGUgdG9rZW4uXHJcbiAqIEBwYXJhbSBlbmNvZGVkSGVhZGVyIC0gSGVhZGVyIG9mIHRoZSB0b2tlbiBpbiBiYXNlNjQuXHJcbiAqIEBwYXJhbSBlbmNvZGVkUGF5bG9hZCAtIFBheWxvYWQgb2YgdGhlIHRva2VuIGluIGJhc2U2NC5cclxuICogQHJldHVybnMgVGhlIHNpZ25hdHVyZSBvZiB0aGUgdG9rZW4gaW4gYmFzZTY0LlxyXG4gKi9cclxuZnVuY3Rpb24gc2lnbihhcGlLZXksIGVuY29kZWRIZWFkZXIsIGVuY29kZWRQYXlsb2FkKSB7XHJcbiAgICByZXR1cm4gY3J5cHRvXHJcbiAgICAgICAgLmNyZWF0ZUhtYWMoJ3NoYTI1NicsIGFwaUtleSlcclxuICAgICAgICAudXBkYXRlKFwiXCIuY29uY2F0KGVuY29kZWRIZWFkZXIsIFwiLlwiKS5jb25jYXQoZW5jb2RlZFBheWxvYWQpKVxyXG4gICAgICAgIC5kaWdlc3QoJ2Jhc2U2NCcpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcKy9nLCAnLScpXHJcbiAgICAgICAgLnJlcGxhY2UoL1xcLy9nLCAnXycpXHJcbiAgICAgICAgLnJlcGxhY2UoLz0vZywgJycpO1xyXG59XHJcbi8qKlxyXG4gKiBDcmVhdGUgdGhlIGhlYWRlciBvZiB0aGUgdG9rZW4uXHJcbiAqXHJcbiAqIEByZXR1cm5zIFRoZSBoZWFkZXIgZW5jb2RlZCBpbiBiYXNlNjQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVIZWFkZXIoKSB7XHJcbiAgICB2YXIgaGVhZGVyID0ge1xyXG4gICAgICAgIGFsZzogJ0hTMjU2JyxcclxuICAgICAgICB0eXA6ICdKV1QnXHJcbiAgICB9O1xyXG4gICAgcmV0dXJuIGVuY29kZTY0KGhlYWRlcikucmVwbGFjZSgvPS9nLCAnJyk7XHJcbn1cclxuLyoqXHJcbiAqIFZhbGlkYXRlIHRoZSBwYXJhbWV0ZXIgdXNlZCBmb3IgdGhlIHBheWxvYWQgb2YgdGhlIHRva2VuLlxyXG4gKlxyXG4gKiBAcGFyYW0gc2VhcmNoUnVsZXMgLSBTZWFyY2ggcnVsZXMgdGhhdCBhcmUgYXBwbGllZCB0byBldmVyeSBzZWFyY2guXHJcbiAqIEBwYXJhbSBhcGlLZXkgLSBBcGkga2V5IHVzZWQgYXMgaXNzdWVyIG9mIHRoZSB0b2tlbi5cclxuICogQHBhcmFtIHVpZCAtIFRoZSB1aWQgb2YgdGhlIGFwaSBrZXkgdXNlZCBhcyBpc3N1ZXIgb2YgdGhlIHRva2VuLlxyXG4gKiBAcGFyYW0gZXhwaXJlc0F0IC0gRGF0ZSBhdCB3aGljaCB0aGUgdG9rZW4gZXhwaXJlcy5cclxuICovXHJcbmZ1bmN0aW9uIHZhbGlkYXRlVG9rZW5QYXJhbWV0ZXJzKHRva2VuUGFyYW1zKSB7XHJcbiAgICB2YXIgc2VhcmNoUnVsZXMgPSB0b2tlblBhcmFtcy5zZWFyY2hSdWxlcywgdWlkID0gdG9rZW5QYXJhbXMudWlkLCBhcGlLZXkgPSB0b2tlblBhcmFtcy5hcGlLZXksIGV4cGlyZXNBdCA9IHRva2VuUGFyYW1zLmV4cGlyZXNBdDtcclxuICAgIGlmIChleHBpcmVzQXQpIHtcclxuICAgICAgICBpZiAoIShleHBpcmVzQXQgaW5zdGFuY2VvZiBEYXRlKSkge1xyXG4gICAgICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcihcIk1laWxpc2VhcmNoOiBUaGUgZXhwaXJlZEF0IGZpZWxkIG11c3QgYmUgYW4gaW5zdGFuY2Ugb2YgRGF0ZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgICAgIGVsc2UgaWYgKGV4cGlyZXNBdC5nZXRUaW1lKCkgPCBEYXRlLm5vdygpKSB7XHJcbiAgICAgICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaEVycm9yKFwiTWVpbGlzZWFyY2g6IFRoZSBleHBpcmVzQXQgZmllbGQgbXVzdCBiZSBhIGRhdGUgaW4gdGhlIGZ1dHVyZS5cIik7XHJcbiAgICAgICAgfVxyXG4gICAgfVxyXG4gICAgaWYgKHNlYXJjaFJ1bGVzKSB7XHJcbiAgICAgICAgaWYgKCEodHlwZW9mIHNlYXJjaFJ1bGVzID09PSAnb2JqZWN0JyB8fCBBcnJheS5pc0FycmF5KHNlYXJjaFJ1bGVzKSkpIHtcclxuICAgICAgICAgICAgdGhyb3cgbmV3IE1laWxpU2VhcmNoRXJyb3IoXCJNZWlsaXNlYXJjaDogVGhlIHNlYXJjaCBydWxlcyBhZGRlZCBpbiB0aGUgdG9rZW4gZ2VuZXJhdGlvbiBtdXN0IGJlIG9mIHR5cGUgYXJyYXkgb3Igb2JqZWN0LlwiKTtcclxuICAgICAgICB9XHJcbiAgICB9XHJcbiAgICBpZiAoIWFwaUtleSB8fCB0eXBlb2YgYXBpS2V5ICE9PSAnc3RyaW5nJykge1xyXG4gICAgICAgIHRocm93IG5ldyBNZWlsaVNlYXJjaEVycm9yKFwiTWVpbGlzZWFyY2g6IFRoZSBBUEkga2V5IHVzZWQgZm9yIHRoZSB0b2tlbiBnZW5lcmF0aW9uIG11c3QgZXhpc3QgYW5kIGJlIG9mIHR5cGUgc3RyaW5nLlwiKTtcclxuICAgIH1cclxuICAgIGlmICghdWlkIHx8IHR5cGVvZiB1aWQgIT09ICdzdHJpbmcnKSB7XHJcbiAgICAgICAgdGhyb3cgbmV3IE1laWxpU2VhcmNoRXJyb3IoXCJNZWlsaXNlYXJjaDogVGhlIHVpZCBvZiB0aGUgYXBpIGtleSB1c2VkIGZvciB0aGUgdG9rZW4gZ2VuZXJhdGlvbiBtdXN0IGV4aXN0LCBiZSBvZiB0eXBlIHN0cmluZyBhbmQgY29tcGx5IHRvIHRoZSB1dWlkNCBmb3JtYXQuXCIpO1xyXG4gICAgfVxyXG4gICAgaWYgKCF2YWxpZGF0ZVV1aWQ0KHVpZCkpIHtcclxuICAgICAgICB0aHJvdyBuZXcgTWVpbGlTZWFyY2hFcnJvcihcIk1laWxpc2VhcmNoOiBUaGUgdWlkIG9mIHlvdXIga2V5IGlzIG5vdCBhIHZhbGlkIHV1aWQ0LiBUbyBmaW5kIG91dCB0aGUgdWlkIG9mIHlvdXIga2V5IHVzZSBnZXRLZXkoKS5cIik7XHJcbiAgICB9XHJcbn1cclxuLyoqXHJcbiAqIENyZWF0ZSB0aGUgcGF5bG9hZCBvZiB0aGUgdG9rZW4uXHJcbiAqXHJcbiAqIEBwYXJhbSBzZWFyY2hSdWxlcyAtIFNlYXJjaCBydWxlcyB0aGF0IGFyZSBhcHBsaWVkIHRvIGV2ZXJ5IHNlYXJjaC5cclxuICogQHBhcmFtIHVpZCAtIFRoZSB1aWQgb2YgdGhlIGFwaSBrZXkgdXNlZCBhcyBpc3N1ZXIgb2YgdGhlIHRva2VuLlxyXG4gKiBAcGFyYW0gZXhwaXJlc0F0IC0gRGF0ZSBhdCB3aGljaCB0aGUgdG9rZW4gZXhwaXJlcy5cclxuICogQHJldHVybnMgVGhlIHBheWxvYWQgZW5jb2RlZCBpbiBiYXNlNjQuXHJcbiAqL1xyXG5mdW5jdGlvbiBjcmVhdGVQYXlsb2FkKHBheWxvYWRQYXJhbXMpIHtcclxuICAgIHZhciBzZWFyY2hSdWxlcyA9IHBheWxvYWRQYXJhbXMuc2VhcmNoUnVsZXMsIHVpZCA9IHBheWxvYWRQYXJhbXMudWlkLCBleHBpcmVzQXQgPSBwYXlsb2FkUGFyYW1zLmV4cGlyZXNBdDtcclxuICAgIHZhciBwYXlsb2FkID0ge1xyXG4gICAgICAgIHNlYXJjaFJ1bGVzOiBzZWFyY2hSdWxlcyxcclxuICAgICAgICBhcGlLZXlVaWQ6IHVpZCxcclxuICAgICAgICBleHA6IGV4cGlyZXNBdCA9PT0gbnVsbCB8fCBleHBpcmVzQXQgPT09IHZvaWQgMCA/IHZvaWQgMCA6IGV4cGlyZXNBdC5nZXRUaW1lKClcclxuICAgIH07XHJcbiAgICByZXR1cm4gZW5jb2RlNjQocGF5bG9hZCkucmVwbGFjZSgvPS9nLCAnJyk7XHJcbn1cclxudmFyIFRva2VuID0gLyoqIEBjbGFzcyAqLyAoZnVuY3Rpb24gKCkge1xyXG4gICAgZnVuY3Rpb24gVG9rZW4oY29uZmlnKSB7XHJcbiAgICAgICAgdGhpcy5jb25maWcgPSBjb25maWc7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgdGVuYW50IHRva2VuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFwaUtleVVpZCAtIFRoZSB1aWQgb2YgdGhlIGFwaSBrZXkgdXNlZCBhcyBpc3N1ZXIgb2YgdGhlIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHNlYXJjaFJ1bGVzIC0gU2VhcmNoIHJ1bGVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gZXZlcnkgc2VhcmNoLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUb2tlbiBvcHRpb25zIHRvIGN1c3RvbWl6ZSBzb21lIGFzcGVjdCBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG9rZW4gaW4gSldUIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgVG9rZW4ucHJvdG90eXBlLmdlbmVyYXRlVGVuYW50VG9rZW4gPSBmdW5jdGlvbiAoYXBpS2V5VWlkLCBzZWFyY2hSdWxlcywgb3B0aW9ucykge1xyXG4gICAgICAgIHZhciBhcGlLZXkgPSAob3B0aW9ucyA9PT0gbnVsbCB8fCBvcHRpb25zID09PSB2b2lkIDAgPyB2b2lkIDAgOiBvcHRpb25zLmFwaUtleSkgfHwgdGhpcy5jb25maWcuYXBpS2V5IHx8ICcnO1xyXG4gICAgICAgIHZhciB1aWQgPSBhcGlLZXlVaWQgfHwgJyc7XHJcbiAgICAgICAgdmFyIGV4cGlyZXNBdCA9IG9wdGlvbnMgPT09IG51bGwgfHwgb3B0aW9ucyA9PT0gdm9pZCAwID8gdm9pZCAwIDogb3B0aW9ucy5leHBpcmVzQXQ7XHJcbiAgICAgICAgdmFsaWRhdGVUb2tlblBhcmFtZXRlcnMoeyBhcGlLZXk6IGFwaUtleSwgdWlkOiB1aWQsIGV4cGlyZXNBdDogZXhwaXJlc0F0LCBzZWFyY2hSdWxlczogc2VhcmNoUnVsZXMgfSk7XHJcbiAgICAgICAgdmFyIGVuY29kZWRIZWFkZXIgPSBjcmVhdGVIZWFkZXIoKTtcclxuICAgICAgICB2YXIgZW5jb2RlZFBheWxvYWQgPSBjcmVhdGVQYXlsb2FkKHsgc2VhcmNoUnVsZXM6IHNlYXJjaFJ1bGVzLCB1aWQ6IHVpZCwgZXhwaXJlc0F0OiBleHBpcmVzQXQgfSk7XHJcbiAgICAgICAgdmFyIHNpZ25hdHVyZSA9IHNpZ24oYXBpS2V5LCBlbmNvZGVkSGVhZGVyLCBlbmNvZGVkUGF5bG9hZCk7XHJcbiAgICAgICAgcmV0dXJuIFwiXCIuY29uY2F0KGVuY29kZWRIZWFkZXIsIFwiLlwiKS5jb25jYXQoZW5jb2RlZFBheWxvYWQsIFwiLlwiKS5jb25jYXQoc2lnbmF0dXJlKTtcclxuICAgIH07XHJcbiAgICByZXR1cm4gVG9rZW47XHJcbn0oKSk7XG5cbnZhciBNZWlsaVNlYXJjaCA9IC8qKiBAY2xhc3MgKi8gKGZ1bmN0aW9uIChfc3VwZXIpIHtcclxuICAgIF9fZXh0ZW5kcyhNZWlsaVNlYXJjaCwgX3N1cGVyKTtcclxuICAgIGZ1bmN0aW9uIE1laWxpU2VhcmNoKGNvbmZpZykge1xyXG4gICAgICAgIHZhciBfdGhpcyA9IF9zdXBlci5jYWxsKHRoaXMsIGNvbmZpZykgfHwgdGhpcztcclxuICAgICAgICBfdGhpcy50b2tlbnMgPSBuZXcgVG9rZW4oY29uZmlnKTtcclxuICAgICAgICByZXR1cm4gX3RoaXM7XHJcbiAgICB9XHJcbiAgICAvKipcclxuICAgICAqIEdlbmVyYXRlIGEgdGVuYW50IHRva2VuXHJcbiAgICAgKlxyXG4gICAgICogQHBhcmFtIGFwaUtleVVpZCAtIFRoZSB1aWQgb2YgdGhlIGFwaSBrZXkgdXNlZCBhcyBpc3N1ZXIgb2YgdGhlIHRva2VuLlxyXG4gICAgICogQHBhcmFtIHNlYXJjaFJ1bGVzIC0gU2VhcmNoIHJ1bGVzIHRoYXQgYXJlIGFwcGxpZWQgdG8gZXZlcnkgc2VhcmNoLlxyXG4gICAgICogQHBhcmFtIG9wdGlvbnMgLSBUb2tlbiBvcHRpb25zIHRvIGN1c3RvbWl6ZSBzb21lIGFzcGVjdCBvZiB0aGUgdG9rZW4uXHJcbiAgICAgKiBAcmV0dXJucyBUaGUgdG9rZW4gaW4gSldUIGZvcm1hdC5cclxuICAgICAqL1xyXG4gICAgTWVpbGlTZWFyY2gucHJvdG90eXBlLmdlbmVyYXRlVGVuYW50VG9rZW4gPSBmdW5jdGlvbiAoYXBpS2V5VWlkLCBzZWFyY2hSdWxlcywgb3B0aW9ucykge1xyXG4gICAgICAgIGlmICh0eXBlb2Ygd2luZG93ID09PSAndW5kZWZpbmVkJykge1xyXG4gICAgICAgICAgICByZXR1cm4gdGhpcy50b2tlbnMuZ2VuZXJhdGVUZW5hbnRUb2tlbihhcGlLZXlVaWQsIHNlYXJjaFJ1bGVzLCBvcHRpb25zKTtcclxuICAgICAgICB9XHJcbiAgICAgICAgcmV0dXJuIF9zdXBlci5wcm90b3R5cGUuZ2VuZXJhdGVUZW5hbnRUb2tlbi5jYWxsKHRoaXMsIGFwaUtleVVpZCwgc2VhcmNoUnVsZXMsIG9wdGlvbnMpO1xyXG4gICAgfTtcclxuICAgIHJldHVybiBNZWlsaVNlYXJjaDtcclxufShDbGllbnQpKTtcblxuZXhwb3J0IHsgRW5xdWV1ZWRUYXNrLCBJbmRleCwgTWF0Y2hpbmdTdHJhdGVnaWVzLCBNZWlsaVNlYXJjaCwgTWVpbGlTZWFyY2hBcGlFcnJvciwgTWVpbGlTZWFyY2hDb21tdW5pY2F0aW9uRXJyb3IsIE1laWxpU2VhcmNoRXJyb3IsIE1laWxpU2VhcmNoVGltZU91dEVycm9yLCBUYXNrLCBUYXNrQ2xpZW50LCBNZWlsaVNlYXJjaCBhcyBkZWZhdWx0LCBodHRwRXJyb3JIYW5kbGVyLCBodHRwUmVzcG9uc2VFcnJvckhhbmRsZXIgfTtcbiJdLCJuYW1lcyI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@meilisearch/instant-meilisearch/node_modules/meilisearch/dist/bundles/meilisearch.esm.js\n");

/***/ })

};
;